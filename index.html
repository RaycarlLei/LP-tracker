<!DOCTYPE html>
<html id="htmlLang" lang="en">
<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/svg+xml" href="favicon.svg" />
  <title>Liquidity Pool ToolBox SolanaÊµÅÂä®ÊÄßÊ±†Âä©Êâã</title>
  <!-- Chart.js for charts -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    :root {
      color-scheme: dark;
      --bg: #020617;
      --bg-elevated: rgba(15, 23, 42, 0.98);
      --border-subtle: rgba(148, 163, 184, 0.22);
      --accent: #49e55e;
      --accent-soft: rgba(16, 229, 94, 0.18);
      --text-main: #e5e7eb;
      --text-muted: #94a3b8;
      --danger: #f97373;
      --radius-lg: 14px;
      --radius-md: 10px;
      --shadow-soft: 0 22px 60px rgba(15, 23, 42, 0.85);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 32px 16px 40px;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background:
        radial-gradient(circle at top, #1f2937 0, #020617 55%, #000 100%);
      color: var(--text-main);
    }

    .main {
      width: 100%;
      max-width: 960px;
    }

    .page-header {
      margin-bottom: 18px;
    }

    .page-title-row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 10px;
      margin-bottom: 6px;
    }

    h1 {
      font-size: 26px;
      letter-spacing: 0.02em;
      margin: 0;
    }

    .pill {
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 11px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      border: 1px solid rgba(148, 163, 184, 0.28);
      color: var(--text-muted);
      background: rgba(15, 23, 42, 0.75);
    }

    .tagline {
      margin: 0;
      font-size: 13px;
      color: var(--text-muted);
    }

    .small {
      font-size: 12px;
      color: var(--text-muted);
    }

    .card {
      border-radius: var(--radius-lg);
      padding: 18px 20px;
      margin-top: 18px;
      background:
        linear-gradient(145deg, rgba(15, 23, 42, 0.96), rgba(12, 18, 33, 0.96));
      border: 1px solid var(--border-subtle);
      box-shadow: var(--shadow-soft);
      backdrop-filter: blur(18px);
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      gap: 8px;
    }

    .card-title {
      font-size: 15px;
      font-weight: 600;
    }

    .badge {
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 999px;
      background: rgba(15, 118, 110, 0.15);
      border: 1px solid rgba(45, 212, 191, 0.4);
      color: #a5f3fc;
    }

    label {
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
      font-size: 13px;
      color: var(--text-muted);
    }

    .input-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    input {
      flex: 1 1 260px;
      min-width: 0;
      padding: 9px 11px;
      border-radius: var(--radius-md);
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(15, 23, 42, 0.9);
      color: var(--text-main);
      font-size: 13px;
      outline: none;
      transition: border-color 0.16s ease, box-shadow 0.16s ease, background-color 0.16s ease;
    }

    input::placeholder {
      color: rgba(148, 163, 184, 0.7);
    }

    input:focus {
      border-color: rgba(34, 197, 94, 0.8);
      box-shadow: 0 0 0 1px rgba(34, 197, 94, 0.55);
      background: rgba(15, 23, 42, 1);
    }

    button {
      padding: 9px 16px;
      cursor: pointer;
      border-radius: var(--radius-md);
      border: 1px solid rgba(34, 197, 94, 0.25);
      background: rgba(34, 197, 94, 0.12);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      color: var(--text-main);
      font-weight: 500;
      font-size: 13px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      box-shadow: 0 4px 12px rgba(15, 23, 42, 0.4), inset 0 1px 0 rgba(34, 197, 94, 0.15);
      transition: background-color 0.16s ease, transform 0.08s ease, box-shadow 0.16s ease, border-color 0.16s ease;
      white-space: nowrap;
    }

    button:hover {
      background: rgba(34, 197, 94, 0.18);
      border-color: rgba(34, 197, 94, 0.35);
      transform: translateY(-1px);
      box-shadow: 0 6px 16px rgba(15, 23, 42, 0.5), inset 0 1px 0 rgba(34, 197, 94, 0.2);
    }

    button:active {
      transform: translateY(0);
      background: rgba(34, 197, 94, 0.15);
      box-shadow: 0 2px 8px rgba(15, 23, 42, 0.3), inset 0 1px 0 rgba(34, 197, 94, 0.15);
    }

    button:disabled {
      opacity: 0.5;
      cursor: default;
      box-shadow: none;
      background: rgba(34, 197, 94, 0.08);
    }

    .button-icon {
      width: 14px;
      height: 14px;
      border-radius: 999px;
      border: 1px solid rgba(34, 197, 94, 0.3);
      background: rgba(34, 197, 94, 0.25);
      backdrop-filter: blur(4px);
      -webkit-backdrop-filter: blur(4px);
    }

    .days-quick-btn,
    .vol-quick-btn {
      padding: 3px 8px;
      font-size: 9px;
      min-width: auto;
      height: auto;
      border-radius: 6px;
      background: rgba(34, 197, 94, 0.12);
      border: 1px solid rgba(34, 197, 94, 0.25);
      color: var(--accent);
      cursor: pointer;
      transition: all 0.2s ease;
      font-weight: 500;
      white-space: nowrap;
    }

    .days-quick-btn:hover,
    .vol-quick-btn:hover {
      background: rgba(34, 197, 94, 0.22);
      border-color: rgba(34, 197, 94, 0.4);
      transform: translateY(-1px);
    }

    .days-quick-btn:active,
    .vol-quick-btn:active {
      transform: translateY(0);
      background: rgba(34, 197, 94, 0.18);
    }

    .run-simulation-btn {
      padding: 10px 18px !important;
      font-size: 13px !important;
      font-weight: 600 !important;
      background: linear-gradient(135deg, rgba(34, 197, 94, 0.25), rgba(16, 185, 129, 0.2)) !important;
      border: 2px solid rgba(34, 197, 94, 0.5) !important;
      box-shadow: 
        0 6px 20px rgba(34, 197, 94, 0.3),
        0 0 0 1px rgba(34, 197, 94, 0.2),
        inset 0 1px 0 rgba(255, 255, 255, 0.1) !important;
      gap: 6px !important;
      position: relative;
      overflow: hidden;
    }

    .run-simulation-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
      transition: left 0.5s ease;
    }

    .run-simulation-btn:hover::before {
      left: 100%;
    }

    .run-simulation-btn:hover {
      background: linear-gradient(135deg, rgba(34, 197, 94, 0.35), rgba(16, 185, 129, 0.3)) !important;
      border-color: rgba(34, 197, 94, 0.7) !important;
      transform: translateY(-2px) !important;
      box-shadow: 
        0 8px 28px rgba(34, 197, 94, 0.4),
        0 0 0 1px rgba(34, 197, 94, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.15) !important;
    }

    .run-simulation-btn:active {
      transform: translateY(0) !important;
      box-shadow: 
        0 4px 16px rgba(34, 197, 94, 0.25),
        0 0 0 1px rgba(34, 197, 94, 0.2),
        inset 0 1px 0 rgba(255, 255, 255, 0.1) !important;
    }

    #loadBtn {
      padding: 10px 18px !important;
      font-size: 13px !important;
      font-weight: 600 !important;
      background: linear-gradient(135deg, rgba(34, 197, 94, 0.25), rgba(16, 185, 129, 0.2)) !important;
      border: 2px solid rgba(34, 197, 94, 0.5) !important;
      box-shadow: 
        0 6px 20px rgba(34, 197, 94, 0.3),
        0 0 0 1px rgba(34, 197, 94, 0.2),
        inset 0 1px 0 rgba(255, 255, 255, 0.1) !important;
      gap: 6px !important;
      position: relative;
      overflow: hidden;
    }

    #loadBtn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
      transition: left 0.5s ease;
    }

    #loadBtn:hover::before {
      left: 100%;
    }

    #loadBtn:hover {
      background: linear-gradient(135deg, rgba(34, 197, 94, 0.35), rgba(16, 185, 129, 0.3)) !important;
      border-color: rgba(34, 197, 94, 0.7) !important;
      transform: translateY(-2px) !important;
      box-shadow: 
        0 8px 28px rgba(34, 197, 94, 0.4),
        0 0 0 1px rgba(34, 197, 94, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.15) !important;
    }

    #loadBtn:active {
      transform: translateY(0) !important;
      box-shadow: 
        0 4px 16px rgba(34, 197, 94, 0.25),
        0 0 0 1px rgba(34, 197, 94, 0.2),
        inset 0 1px 0 rgba(255, 255, 255, 0.1) !important;
    }

    .play-icon {
      font-size: 14px;
      line-height: 1;
      color: rgba(34, 197, 94, 1);
      text-shadow: 0 0 8px rgba(34, 197, 94, 0.6);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 18px;
      height: 18px;
      background: rgba(34, 197, 94, 0.2);
      border-radius: 50%;
      border: 1px solid rgba(34, 197, 94, 0.4);
    }

    .loading-text {
      min-height: 16px;
    }

    .error {
      color: var(--danger);
      margin-top: 8px;
      font-size: 12px;
    }

    .results-card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }

    .results-title {
      font-size: 16px;
      font-weight: 600;
    }

    .muted-label {
      font-size: 11px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.12em;
    }

    .stat-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(210px, 1fr));
      gap: 10px 18px;
      margin-bottom: 10px;
    }

    .stat {
      padding: 8px 10px;
      border-radius: 10px;
      background: radial-gradient(circle at top left, rgba(34, 197, 94, 0.06), transparent 55%);
      border: 1px solid rgba(148, 163, 184, 0.26);
    }

    .stat-label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      color: var(--text-muted);
      margin-bottom: 4px;
    }

    .clickable-stat .stat-label {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
    }

    .stat-value {
      font-size: 13px;
      font-weight: 500;
      color: var(--text-main);
      word-break: break-all;
    }

    .stat.dex-clickable {
      cursor: pointer;
      position: relative;
      overflow: hidden;
      transition: background-color 0.2s ease, border-color 0.2s ease, transform 0.1s ease, box-shadow 0.3s ease;
      user-select: none;
    }

    .stat.dex-clickable::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
      transition: left 0.5s ease;
    }

    .stat.dex-clickable:hover::before {
      left: 100%;
    }

    .stat.dex-clickable:hover {
      transform: translateY(-1px);
      box-shadow: 
        0 8px 28px rgba(59, 130, 246, 0.4),
        0 0 0 1px rgba(148, 163, 184, 0.26) !important;
      background: radial-gradient(circle at top left, rgba(34, 197, 94, 0.06), transparent 55%) !important;
      border-color: rgba(148, 163, 184, 0.26) !important;
    }

    .stat.dex-clickable:active {
      transform: translateY(0);
      box-shadow: 
        0 4px 16px rgba(59, 130, 246, 0.25),
        0 0 0 1px rgba(148, 163, 184, 0.26) !important;
      background: radial-gradient(circle at top left, rgba(34, 197, 94, 0.06), transparent 55%) !important;
      border-color: rgba(148, 163, 184, 0.26) !important;
    }

    .clickable-stat {
      cursor: pointer;
      transition: background-color 0.2s ease, border-color 0.2s ease, transform 0.1s ease;
      user-select: none;
    }

    .clickable-stat:hover {
      background: radial-gradient(circle at top left, rgba(34, 197, 94, 0.12), transparent 55%);
      border-color: rgba(34, 197, 94, 0.4);
      transform: translateY(-1px);
    }

    .clickable-stat:active {
      transform: translateY(0);
      background: radial-gradient(circle at top left, rgba(34, 197, 94, 0.08), transparent 55%);
    }

    .glow-green {
      box-shadow: 0 0 20px rgba(34, 197, 94, 0.5), 0 0 40px rgba(34, 197, 94, 0.3), 0 0 60px rgba(34, 197, 94, 0.15);
      border-color: rgba(34, 197, 94, 0.6) !important;
      background: radial-gradient(circle at top left, rgba(34, 197, 94, 0.15), transparent 55%) !important;
    }

    .glow-red {
      box-shadow: 0 0 20px rgba(249, 115, 115, 0.5), 0 0 40px rgba(249, 115, 115, 0.3), 0 0 60px rgba(249, 115, 115, 0.15);
      border-color: rgba(249, 115, 115, 0.6) !important;
      background: radial-gradient(circle at top left, rgba(249, 115, 115, 0.15), transparent 55%) !important;
    }

    .clickable-stat[style*="border: none"]:hover {
      background: radial-gradient(circle at top left, rgba(34, 197, 94, 0.08), transparent 55%);
      border-color: transparent;
    }

    .clickable-stat[style*="border: none"]:active {
      background: radial-gradient(circle at top left, rgba(34, 197, 94, 0.05), transparent 55%);
    }

    .swap-icon {
      font-size: 14px;
      color: var(--accent);
      opacity: 0.7;
      transition: transform 0.3s ease, opacity 0.2s ease;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 18px;
      height: 18px;
      border-radius: 4px;
      background: rgba(34, 197, 94, 0.1);
      border: 1px solid rgba(34, 197, 94, 0.2);
    }

    .clickable-stat:hover .swap-icon {
      opacity: 1;
      transform: rotate(180deg);
      background: rgba(34, 197, 94, 0.2);
      border-color: rgba(34, 197, 94, 0.4);
    }

    pre {
      font-size: 11px;
      white-space: pre-wrap;
      word-wrap: break-word;
      background: rgba(15, 23, 42, 0.96);
      border-radius: 12px;
      padding: 10px 12px;
      max-height: 320px;
      overflow: auto;
      border: 1px solid rgba(30, 64, 175, 0.5);
      box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.8);
    }

    code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono",
        "Courier New", monospace;
      font-size: 11px;
      color: #a5b4fc;
    }

    /* chart card */
    .chart-container {
      margin-top: 16px;
    }

    .range-control {
      margin: 12px 0 6px;
      padding: 12px 14px 14px;
      border-radius: 14px;
      border: 1px solid rgba(34, 197, 94, 0.25);
      background:
        linear-gradient(135deg, rgba(15, 118, 110, 0.15), rgba(34, 197, 94, 0.05)),
        rgba(15, 23, 42, 0.85);
      box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.45), 0 10px 25px rgba(15, 23, 42, 0.5);
    }

    .range-meta {
      display: flex;
      justify-content: space-between;
      font-size: 10px;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: rgba(226, 232, 240, 0.75);
    }

    #daysRange {
      width: 100%;
      appearance: none;
      -webkit-appearance: none;
      margin-top: 12px;
      height: 6px;
      background: transparent;
      cursor: pointer;
    }

    #daysRange::-webkit-slider-runnable-track {
      height: 6px;
      border-radius: 999px;
      background:
        linear-gradient(90deg, rgba(16, 185, 129, 0.15), rgba(16, 185, 129, 0.8));
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.08);
    }

    #daysRange::-moz-range-track {
      height: 6px;
      border-radius: 999px;
      background:
        linear-gradient(90deg, rgba(16, 185, 129, 0.15), rgba(16, 185, 129, 0.8));
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.08);
    }

    #daysRange::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      border: 2px solid rgba(15, 23, 42, 0.95);
      background:
        radial-gradient(circle at 30% 30%, rgba(34, 197, 94, 0.4), #216e3e, #15803d);
      box-shadow: 0 4px 12px rgba(21, 128, 61, 0.35), inset 0 1px 0 rgba(34, 197, 94, 0.2);
      margin-top: -7px;
      transition: box-shadow 0.2s ease;
    }

    #daysRange::-webkit-slider-thumb:hover {
      box-shadow: 0 5px 16px rgba(21, 128, 61, 0.45), inset 0 1px 0 rgba(34, 197, 94, 0.3);
    }

    #daysRange::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      border: 2px solid rgba(15, 23, 42, 0.95);
      background:
        radial-gradient(circle at 30% 30%, rgba(34, 197, 94, 0.4), #136e34, #15803d);
      box-shadow: 0 4px 12px rgba(21, 128, 61, 0.35), inset 0 1px 0 rgba(34, 197, 94, 0.2);
      transition: box-shadow 0.2s ease;
    }

    #daysRange::-moz-range-thumb:hover {
      box-shadow: 0 5px 16px rgba(21, 128, 61, 0.45), inset 0 1px 0 rgba(34, 197, 94, 0.3);
    }

    #daysRange:focus-visible {
      outline: none;
      box-shadow: 0 0 0 2px rgba(34, 197, 94, 0.4);
    }

    .chart-wrapper {
      position: relative;
      width: 100%;
      height: 260px;
      margin-top: 10px;
      border-radius: 12px;
      background: radial-gradient(circle at top left, rgba(34, 197, 94, 0.06), rgba(15, 23, 42, 0.96));
      border: 1px solid rgba(148, 163, 184, 0.3);
      padding: 10px 12px 12px;
    }

    .chart-legend {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 8px;
      font-size: 11px;
      color: var(--text-muted);
    }

    .chart-legend-item {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      transition: opacity 0.2s ease;
    }

    .chart-legend-item:hover {
      opacity: 0.8;
    }

    .chart-legend-item.legend-hidden {
      opacity: 0.4;
    }

    .chart-legend-item.legend-hidden .legend-dot {
      opacity: 0.4;
    }

    .chart-legend-item.legend-hidden span:not(.legend-dot) {
      text-decoration: line-through;
    }

    .legend-dot {
      width: 10px;
      height: 10px;
      border-radius: 999px;
    }

    .collapsible-section {
      margin-bottom: 6px;
    }

    .collapsible-header {
      cursor: pointer;
      display: flex;
      align-items: center;
      padding: 4px 0;
      user-select: none;
      transition: opacity 0.2s ease;
    }

    .collapsible-header:hover {
      opacity: 0.8;
    }

    .collapsible-arrow {
      display: inline-block;
      font-size: 10px;
      color: var(--text-muted);
      transition: transform 0.2s ease;
      width: 12px;
      text-align: center;
    }

    .collapsible-content {
      margin-top: 8px;
      animation: fadeIn 0.2s ease;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }

    /* Popular pools selection bar */
    .popular-pools-container {
      margin-bottom: 12px;
      overflow: hidden;
      position: relative;
      padding: 8px 0;
      mask-image: linear-gradient(to right, transparent 0%, black 5%, black 95%, transparent 100%);
      -webkit-mask-image: linear-gradient(to right, transparent 0%, black 5%, black 95%, transparent 100%);
    }

    .popular-pools-scroll {
      display: flex;
      gap: 8px;
      animation: scrollHorizontal 40s linear infinite;
      width: fit-content;
    }

    .popular-pools-scroll:hover {
      animation-play-state: paused;
    }

    @keyframes scrollHorizontal {
      0% {
        transform: translateX(0);
      }
      100% {
        transform: translateX(-50%);
      }
    }

    .popular-pool-item {
      padding: 6px 12px;
      border-radius: var(--radius-md);
      border: 1px solid rgba(148, 163, 184, 0.3);
      background: rgba(15, 23, 42, 0.6);
      color: var(--text-main);
      font-size: 12px;
      cursor: pointer;
      white-space: nowrap;
      transition: all 0.2s ease;
      user-select: none;
      flex-shrink: 0;
    }

    .popular-pool-item:hover {
      background: rgba(34, 197, 94, 0.15);
      border-color: rgba(34, 197, 94, 0.4);
      transform: translateY(-1px);
    }

    .popular-pool-item:active {
      transform: translateY(0);
      background: rgba(34, 197, 94, 0.2);
    }

    .popular-pools-scroll::after {
      content: '';
      position: absolute;
      top: 0;
      right: 0;
      width: 40px;
      height: 100%;
      background: linear-gradient(to right, transparent, rgba(15, 23, 42, 0.95));
      pointer-events: none;
      z-index: 1;
    }

    /* Language switcher button */
    .lang-switcher {
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.28);
      background: rgba(15, 23, 42, 0.75);
      color: var(--text-muted);
      font-size: 11px;
      letter-spacing: 0.08em;
      font-weight: 500;
      cursor: pointer;
      transition: background-color 0.2s ease, border-color 0.2s ease, transform 0.1s ease;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      user-select: none;
    }

    .lang-switcher:hover {
      background: radial-gradient(circle at top left, rgba(34, 197, 94, 0.12), transparent 55%);
      border-color: rgba(34, 197, 94, 0.4);
      transform: translateY(-1px);
      color: var(--text-main);
    }

    .lang-switcher:active {
      transform: translateY(0);
      background: radial-gradient(circle at top left, rgba(34, 197, 94, 0.08), transparent 55%);
    }

    .lang-switcher-icon {
      font-size: 11px;
      opacity: 0.7;
      transition: transform 0.3s ease, opacity 0.2s ease;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .lang-switcher:hover .lang-switcher-icon {
      opacity: 1;
      transform: rotate(180deg);
    }

    @media (max-width: 640px) {
      body {
        padding-top: 22px;
      }

      .lang-switcher {
        padding: 4px 10px;
        font-size: 11px;
      }

      .card {
        padding: 16px 14px;
      }

      h1 {
        font-size: 22px;
      }

      button {
        width: 100%;
        justify-content: center;
      }

      .chart-wrapper {
        height: 240px;
      }
    }
  </style>
</head>
<body>
  <main class="main">
    <header class="page-header">
      <div class="page-title-row">
        <h1 id="pageTitle">Liquidity Pool ToolBox</h1>
        <span class="pill">Solana Liquidity Pool ToolBox</span>
      </div>
      <div class="page-title-row">
        <button class="lang-switcher" id="langSwitcher" title="Switch Language / ÂàáÊç¢ËØ≠Ë®Ä">
          <span class="lang-switcher-icon">üåê</span>
          <span id="langSwitcherText">EN</span>
        </button>
      </div>
      <p class="tagline">
        <code id="pageTagline">Live Pool Metrics and Impermanent Loss Calculator</code>
      </p>
    </header>

    <div class="card">
      <div class="card-header">
        <div class="card-title" id="poolIdTitle">Pool ID</div>
        <span class="badge" id="geckoBadge">Popular Liquidity Pools</span>
      </div>

      <div class="popular-pools-container">
        <div class="popular-pools-scroll" id="popularPoolsScroll">
          <!-- Popular pools will be duplicated for seamless loop -->
        </div>
      </div>

      <label for="poolId" id="poolIdLabel">Paste any Solana pool address to inspect its stats.</label>
      <div class="input-row">
        <input
          id="poolId"
          type="text"
          value="DJNtGuBGEQiUCWE8F981M2C3ZghZt2XLD8f2sQdZ6rsZ"
          placeholder="DJNtGuBGEQiUCWE8F981M2C3ZghZt2XLD8f2sQdZ6rsZ"
        />
        <button id="loadBtn">
          <img src="favicon.svg" style="width: 14px; height: 14px;" alt="" />
          <span id="loadBtnText">Load Pool</span>
        </button>
      </div>
      <div style="margin-top: 10px;">
        <button 
          id="toggleCustomKeyBtn" 
          type="button"
          style="padding: 0; margin: 0; border: none; background: transparent; box-shadow: none; outline: none; cursor: pointer;"
        >
          <span id="toggleCustomKeyText" style="color: rgba(148, 163, 184, 0.4); font-size: 10px; font-family: monospace;">api_key_config</span>
          <span id="toggleCustomKeyArrow" style="margin-left: 6px; color: rgba(148, 163, 184, 0.4); font-size: 10px;">‚ñº</span>
        </button>
        <div id="customKeySection" style="display: none; margin-top: 8px;">
          <div class="input-row">
          <input
            id="birdeyeApiKey"
            type="password"
            placeholder="Enter your Birdeye API Key"
            autocomplete="off"
          />
          <button id="toggleKeyVisibilityBtn" type="button" title="Show/Hide API Key" style="padding: 9px 12px;">
            üëÅÔ∏è
          </button>
          <button id="checkBirdeyeKeyBtn">
            <span class="button-icon"></span>
            <span id="checkKeyBtnText">Check Key</span>
          </button>
          </div>
          <div class="small" id="birdeyeStatus" style="margin-top: 4px; opacity: 0.9;"></div>

        </div>
        <div class="small" id="defaultKeyNote" style="margin-top: 6px; opacity: 0.8; color: var(--text-muted);">
          Default uses built-in API Key. To use your own Key, please click the button above.
        </div>
      </div>
      <div class="small loading-text" id="loading"></div>
      <div id="error" class="error"></div>
    </div>

    <div id="results" class="card" style="display:none;">
      <div class="results-card-header">
        <div>
          <div class="results-title" id="resultsTitle">Pool Data</div>
          <div class="muted-label" id="keyMetricsLabel">Key metrics</div>
        </div>
        <div class="muted-label" id="liveFromLabel">Live from GeckoTerminal</div>
      </div>
      <!-- chart area -->
      <div class="chart-container">
        <div class="muted-label">
          <span id="lastDaysLabel">Last</span> <span id="daysLabel">30</span> <span id="daysLabelSuffix">Days Liquidity & Volume</span>
        </div>


        <div class="range-control">
          <div class="range-meta">
            <span id="lookbackWindowLabel">Lookback window</span>
            <span></span>
          </div>
          <input
            id="daysRange"
            type="range"
            min="2"
            max="180"
            step="1"
            value="30"
          />
        </div>

        <div class="chart-wrapper">
          <canvas id="tvlVolumeChart"></canvas>
        </div>
        <div class="chart-legend">
          <div class="chart-legend-item" id="tvlLegend">
            <span class="legend-dot" style="background: #1d5331;"></span>
            <span>TVL (USD)</span>
          </div>
          <div class="chart-legend-item" id="volumeLegend">
            <span class="legend-dot" style="background: rgba(148, 163, 184, 0.9);"></span>
            <span>Daily Volume (USD)</span>
          </div>
          <div class="chart-legend-item" id="token0HighLegend">
            <span class="legend-dot" style="background: rgba(250, 204, 21, 0.9);"></span>
            <span id="token0HighLabel">High Price</span>
          </div>
          <div class="chart-legend-item" id="token0LowLegend">
            <span class="legend-dot" style="background: rgba(248, 113, 113, 0.9);"></span>
            <span id="token0LowLabel">Low Price</span>
          </div>
          <div class="chart-legend-item" id="token1HighLegend">
            <span class="legend-dot" style="background: rgba(59, 130, 246, 0.9);"></span>
            <span id="token1HighLabel">High Price</span>
          </div>
          <div class="chart-legend-item" id="token1LowLegend">
            <span class="legend-dot" style="background: rgba(139, 92, 246, 0.9);"></span>
            <span id="token1LowLabel">Low Price</span>
          </div>
        </div>
      </div>
      <div id="poolInfo"></div>

      <div class="collapsible-section" style="margin-top: 14px;">
        <div class="collapsible-header" onclick="toggleCollapsible('rawJsonSection')">
          <span class="collapsible-arrow" id="rawJsonArrow">‚ñ∂</span>
          <span class="muted-label" id="rawGeckoLabel" style="margin-left: 6px;">Raw GeckoTerminal Response</span>
          <span class="small" id="rawGeckoDesc" style="margin-left: 8px; opacity: 0.7;">Full JSON payload from GeckoTerminal pool snapshot API.</span>
        </div>
        <div class="collapsible-content" id="rawJsonSection" style="display: none;">
          <pre id="rawJson"></pre>
        </div>
      </div>

      <div class="collapsible-section" style="margin-top: 10px;">
        <div class="collapsible-header" onclick="toggleCollapsible('birdeyeRawJsonSection')">
          <span class="collapsible-arrow" id="birdeyeRawJsonArrow">‚ñ∂</span>
          <span class="muted-label" id="rawBirdeyeLabel" style="margin-left: 6px;">Raw Birdeye OHLCV Response</span>
          <span class="small" id="rawBirdeyeDesc" style="margin-left: 8px; opacity: 0.7;">Full JSON payload from Birdeye OHLCV API (if available).</span>
        </div>
        <div class="collapsible-content" id="birdeyeRawJsonSection" style="display: none;">
          <pre id="birdeyeRawJson"></pre>
        </div>
      </div>
    </div>

    <!-- Fee Prediction -->
    <div class="card" id="feePredictionCard" style="display:none; margin-top: 20px;">
      <div class="card-header">
        <div>
          <div class="card-title" id="feePredictionTitle">Fee Prediction</div>
        </div>
      </div>
      <div class="card-content">
        <div class="stat-grid" style="margin-bottom: 20px;">
          <div class="stat">
            <div class="stat-label" id="currentTvlLabel">Current TVL</div>
            <div class="stat-value" id="currentTvlValue">N/A</div>
          </div>
          <div class="stat">
            <div class="stat-label" id="dailyVolume7dLabel">7-Day Daily Average Volume (USD)</div>
            <div class="stat-value" id="dailyVolume7dValue">N/A</div>
          </div>
          <div class="stat">
            <div class="stat-label" id="dailyVolume7dStdDevLabel">7-Day Volume Std Dev (USD)</div>
            <div class="stat-value" id="dailyVolume7dStdDevValue">N/A</div>
          </div>
        </div>
        
        <div style="margin-bottom: 20px;">
          <label for="feePercentageInput" style="display: block; margin-bottom: 8px; font-weight: 500;">
            <span id="feePercentageLabel">Fee Percentage (%)</span>
          </label>
          <input
            type="number"
            id="feePercentageInput"
            step="0.01"
            min="0"
            max="100"
            value="0.01"
            placeholder="e.g. 0.3 for 0.3%"
            style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;"
          />
          <div id="pancakeswapFeeNote" style="display: none; margin-top: 6px; font-size: 11px; color: var(--text-muted); line-height: 1.4;">
            <span id="pancakeswapFeeNoteText"></span>
            <a href="https://docs.pancakeswap.finance/earn/pancakeswap-pools" target="_blank" id="pancakeswapFeeNoteLink" style="color: rgba(59, 130, 246, 0.9); text-decoration: underline; cursor: pointer; opacity: 0.9; margin-left: 4px;"></a>
          </div>
        </div>
        
        <div class="stat clickable-stat" id="feeDisplayStat" style="border: none; background: transparent; margin-top: 10px;"
             data-display-type="apr">
          <div class="stat-label">
            <span id="feeDisplayLabel">Fee APR</span>
            <span class="swap-icon" id="feeSwapIcon">‚áÑ</span>
          </div>
          <div class="stat-value" id="feeDisplayValue" style="font-size: 24px; font-weight: bold; color: #4CAF50;">-</div>
        </div>
      </div>
    </div>

    <!-- Impermanent Loss Simulator -->
    <div class="card" id="ilSimulatorCard" style="margin-top: 20px;">
      <div class="card-header">
        <div>
          <div class="card-title" id="ilSimulatorTitle">Impermanent Loss Simulator</div>
          <div class="muted-label" id="ilSimulatorSubtitle">Monte Carlo</div>
        </div>
        <span class="badge">Based on GBM model</span>
      </div>

      <p class="small" id="ilSimulatorDesc" style="margin-bottom: 10px;">
        Enter the concentrated liquidity range, current price, daily volatility, and time period. Use geometric Brownian motion to perform Monte Carlo simulation on future prices, estimating expected IL, distribution, and confidence intervals.
      </p>

      <!-- Input Area -->
      <div class="stat-grid" style="margin-bottom: 8px;">
        <div class="stat">
          <div class="stat-label">Price lower bound</div>
          <input
            id="ilLower"
            type="number"
            step="0.0001"
            placeholder="e.g. 100"
            value="0.8"
          />
          <div style="display: flex; gap: 4px; margin-top: 4px; flex-wrap: wrap;">
            <button 
              type="button"
              class="vol-quick-btn"
              onclick="setLowerBound(-0.05)"
              title="Set lower bound to Current price √ó (1 - 0.05%)"
            >
              -0.05%
            </button>
            <button 
              type="button"
              class="vol-quick-btn"
              onclick="setLowerBound(-1)"
              title="Set lower bound to Current price √ó (1 - 1%)"
            >
              -1%
            </button>
            <button 
              type="button"
              class="vol-quick-btn"
              onclick="setLowerBound(-20)"
              title="Set lower bound to Current price √ó (1 - 20%)"
            >
              -20%
            </button>
            <button 
              type="button"
              class="vol-quick-btn"
              onclick="setLowerBound(-99.9)"
              title="Set lower bound to Current price √ó (1 - 99.9%)"
            >
              -99.9%
            </button>
          </div>
        </div>
        <div class="stat">
          <div class="stat-label">Price upper bound</div>
          <input
            id="ilUpper"
            type="number"
            step="0.0001"
            placeholder="e.g. 200"
            value="1.2"
          />
          <div style="display: flex; gap: 4px; margin-top: 4px; flex-wrap: wrap;">
            <button 
              type="button"
              class="vol-quick-btn"
              onclick="setUpperBound(0.05)"
              title="Set upper bound to Current price √ó (1 + 0.05%)"
            >
              +0.05%
            </button>
            <button 
              type="button"
              class="vol-quick-btn"
              onclick="setUpperBound(1)"
              title="Set upper bound to Current price √ó (1 + 1%)"
            >
              +1%
            </button>
            <button 
              type="button"
              class="vol-quick-btn"
              onclick="setUpperBound(20)"
              title="Set upper bound to Current price √ó (1 + 20%)"
            >
              +20%
            </button>
            <button 
              type="button"
              class="vol-quick-btn"
              onclick="setUpperBound(99.9)"
              title="Set upper bound to Current price √ó (1 + 99.9%)"
            >
              +99.9%
            </button>
          </div>
        </div>
        <div class="stat">
          <div class="stat-label">Current price (P‚ÇÄ)</div>
          <input
            id="ilP0"
            type="number"
            step="0.0001"
            placeholder="e.g. 130"
            value="1"
          />
        </div>
      </div>

      <div class="stat-grid" style="margin-bottom: 4px;">
        <div class="stat">
          <div class="stat-label">
            <span>Daily volatility (percent)</span>
          </div>
          <input
            id="ilSigmaDaily"
            type="number"
            step="0.01"
            placeholder="e.g. 7.26 means 7.26%"
            value="7.26"
          />
          <div style="display: flex; gap: 4px; margin-top: 4px; flex-wrap: wrap;">
            <button 
              id="calcHvBtn0" 
              type="button"
              class="vol-quick-btn"
              title="Calculate historical volatility for token0 from loaded price data"
              style="display: none;"
            >
              üìä HV
            </button>
            <button 
              id="calcHvBtn1" 
              type="button"
              class="vol-quick-btn"
              title="Calculate historical volatility for token1 from loaded price data"
              style="display: none;"
            >
              üìä HV
            </button>
            <button 
              id="calcRatioVolBtn" 
              type="button"
              class="vol-quick-btn"
              title="Calculate price ratio volatility from token0 and token1 HV and correlation"
              style="display: none;"
            >
              <span id="ratioVolatilityBtnText">Ratio Volatility</span>
            </button>
          </div>
          <div class="small" id="hvInfo" style="margin-top: 4px; opacity: 0.7; font-size: 10px;"></div>
        </div>
        <div class="stat">
          <div class="stat-label">
            <span id="feeAprInputLabel">Fee APR (%)</span>
          </div>
          <input
            id="ilFeeApr"
            type="number"
            step="0.01"
            placeholder="e.g. 15.5 means 15.5%"
            value=""
          />
        </div>
        <div class="stat">
          <div class="stat-label">
            <span>simulation days</span>
          </div>
          <input
            id="ilDays"
            type="number"
            step="1"
            min="1"
            placeholder="Forecast days, e.g. 30"
            value="30"
          />
          <div style="display: flex; gap: 4px; margin-top: 4px; flex-wrap: wrap;">
            <button 
              class="days-quick-btn"
              data-days="1"
              type="button"
              title="Set to 1 day"
            >
              1d
            </button>
            <button 
              class="days-quick-btn"
              data-days="7"
              type="button"
              title="Set to 7 days"
            >
              7d
            </button>
            <button 
              class="days-quick-btn"
              data-days="30"
              type="button"
              title="Set to 30 days"
            >
              30d
            </button>
            <button 
              class="days-quick-btn"
              data-days="365"
              type="button"
              title="Set to 365 days"
            >
              365d
            </button>
          </div>
        </div>
        <div class="stat">
          <div class="stat-label">Number of simulations</div>
          <input
            id="ilPaths"
            type="number"
            step="1000"
            min="1000"
            placeholder="Number of simulations, default 1000"
            value="1000"
          />
        </div>
      </div>

      <div style="margin-top: 6px; margin-bottom: 4px; display: flex; flex-direction: column; align-items: center; gap: 8px;">
        <button id="runIlBtn" class="run-simulation-btn">
          <span class="play-icon">‚ñ∂</span>
          <span id="runSimulationText">Run Simulation</span>
        </button>
        <span class="small" id="ilStatus"></span>
      </div>
      <div class="error" id="ilError"></div>

      <!-- Output Overview -->
      <div style="margin-top: 12px;">
        <div class="muted-label" id="simulationResultsLabel" style="margin-bottom: 4px;">Simulation results</div>
        <div class="stat-grid">
          <div class="stat">
            <div class="stat-label" id="expectedILLabel">Expected IL</div>
            <div class="stat-value" id="ilExpected">‚Äì</div>
          </div>
          <div class="stat">
            <div class="stat-label" id="dailyILLabel">Daily IL</div>
            <div class="stat-value" id="ilDaily">‚Äì</div>
          </div>
          <div class="stat">
            <div class="stat-label" id="equivalentILAprLabel">Equivalent IL APR</div>
            <div class="stat-value" id="ilApr">‚Äì</div>
          </div>
          <div class="stat">
            <div class="stat-label" id="feeBreakEvenAprLabel">Fee Break-even APR</div>
            <div class="stat-value" id="ilFeeBreakEven">‚Äì</div>
          </div>
          <div class="stat">
            <div class="stat-label" id="correlationLabel">Volume-IL Correlation (cov)</div>
            <div class="stat-value" id="volumeIlCorrelation">‚Äì</div>
          </div>
          <div class="stat">
            <div class="stat-label" id="totalReturnStdLabel">Total Return Std. Dev. (Annualized)</div>
            <div class="stat-value" id="totalReturnStd">‚Äì</div>
          </div>
          <div class="stat">
            <div class="stat-label" id="sharpeRatioLabel">Sharpe Ratio</div>
            <div class="stat-value" id="sharpeRatio">‚Äì</div>
          </div>
          <div class="stat">
            <div class="stat-label" id="worstCaseMddLabel">95% Worst-Case MDD</div>
            <div class="stat-value" id="worstCaseMdd">‚Äì</div>
          </div>
          <div class="stat">
            <div class="stat-label" id="ilIntervalLabel">5% ‚Äì 95% IL interval</div>
            <div class="stat-value" id="ilCI">‚Äì</div>
          </div>
          <div class="stat">
            <div class="stat-label" id="stdDeviationILLabel">IL Std. Dev. (Total)</div>
            <div class="stat-value" id="ilStd">‚Äì</div>
          </div>
        </div>
      </div>

      <!-- Distribution Chart -->
      <div class="chart-container" style="margin-top: 12px;">
        <div class="muted-label" id="ilDistributionLabel">IL distribution (percent)</div>
        <div class="small" id="ilDistributionDesc">
          Based on IL samples obtained from Monte Carlo simulation, bin the results and plot as a frequency histogram.
        </div>
        <div class="chart-wrapper" style="margin-top: 10px;">
          <canvas id="ilDistributionChart"></canvas>
        </div>
        <div class="chart-legend" style="margin-top: 6px;">
          <div class="chart-legend-item">
            <span class="legend-dot" style="background: rgba(148,163,184,0.9);"></span>
            <span id="frequencyLabel">Frequency of simulated IL</span>
          </div>
        </div>
      </div>

      <!-- Monte Carlo Simulation Path Chart -->
      <div class="chart-container" style="margin-top: 18px;">
        <div style="display: flex; justify-content: space-between; align-items: center;">
          <div class="muted-label" id="monteCarloPathLabel">ËíôÁâπÂç°Ê¥õÊ®°ÊãüË∑ØÂæÑ</div>
          <button id="monteCarloAxisToggle" class="clickable-stat" style="background: rgba(30, 41, 59, 0.8); border: 1px solid rgba(148, 163, 184, 0.3); border-radius: 4px; padding: 4px 8px; color: rgba(148, 163, 184, 0.9); font-size: 11px; display: flex; align-items: center; gap: 4px;" title="ÁÇπÂáªYËΩ¥ÊàñÊ≠§ÊåâÈíÆÂàáÊç¢‰ª∑Ê†º/ÁôæÂàÜÊØî">
            <span class="swap-icon">‚áÑ</span>
            <span id="monteCarloAxisToggleText">‰ª∑Ê†º</span>
          </button>
        </div>
        <div class="small" id="monteCarloPathDesc">
          Â±ïÁ§∫ËíôÁâπÂç°Ê¥õÊ®°ÊãüÁöÑ‰ª∑Ê†ºÂèòÂåñËøáÁ®ãÔºåÂåÖÊã¨ÂΩìÂâç‰ª∑Ê†º„ÄÅÊØèÊó•Ê≥¢Âä®ÁéáÂíåÊ®°ÊãüÂ§©Êï∞„ÄÇ
        </div>
        <div class="chart-wrapper" style="margin-top: 10px;">
          <canvas id="monteCarloPathChart"></canvas>
        </div>
        <div class="chart-legend" style="margin-top: 6px;">
          <div class="chart-legend-item">
            <span class="legend-dot" style="background: rgba(73, 229, 94, 0.75);"></span>
            <span id="pricePathLabel">‰ª∑Ê†ºË∑ØÂæÑ</span>
          </div>
          <div class="chart-legend-item">
            <span class="legend-dot" style="background: rgba(168, 85, 247, 0.5);"></span>
            <span id="lpRangeLabel">LP Range</span>
          </div>
        </div>
      </div>
    </div>
  </main>

  <script>
    const API_BASE = "https://api.geckoterminal.com/api/v2";
    const BIRDEYE_BASE = "https://public-api.birdeye.so";
    const SOLANA_RPC = "https://api.mainnet-beta.solana.com";

    // Language system
    const translations = {
      en: {
        // Page header
        title: "Is Your Liquidity Pool Worth Investing In?",
        tagline: "Live Pool Metrics and Impermanent Loss Calculator",
        // Pool ID section
        poolId: "Pool ID",
        geckoTerminalBadge: "Popular Liquidity Pools",
        poolIdLabel: "Paste any Solana pool address to inspect its stats.",
        loadPool: "Load Pool",
        apiKeyConfig: "api_key_config",
        enterBirdeyeKey: "Enter your Birdeye API Key",
        checkKey: "Check Key",
        defaultApiKeyNote: "Default uses built-in API Key. To use your own Key, please click the button above.",
        // Results section
        parsedPoolData: "Pool Data",
        keyMetrics: "Key metrics",
        liveFromGeckoTerminal: "Live from GeckoTerminal",
        lastDaysLiquidity: "Last {days} Days Liquidity & Volume",
        tvlLineNote: "TVL line uses current liquidity as an approximate level, daily volume from OHLCV candles.",
        lookbackWindow: "Lookback window",
        rawGeckoTerminalResponse: "Raw GeckoTerminal Response",
        rawGeckoTerminalDesc: "Full JSON payload from GeckoTerminal pool snapshot API.",
        rawBirdeyeResponse: "Raw Birdeye OHLCV Response",
        rawBirdeyeDesc: "Full JSON payload from Birdeye OHLCV API (if available).",
        // Chart labels
        tvlUsd: "TVL (USD)",
        tvl: "TVL",
        dailyVolumeUsd: "Daily Volume (USD)",
        highPrice: "High Price",
        lowPrice: "Low Price",
        // IL Simulator
        ilSimulator: "Impermanent Loss Simulator",
        ilSimulatorSubtitle: "Monte Carlo",
        ilSimulatorDesc: "Enter the concentrated liquidity range, current price, daily volatility, and time period. Use geometric Brownian motion to perform Monte Carlo simulation on future prices, estimating expected IL, distribution, and confidence intervals.",
        priceLowerBound: "Price lower bound",
        priceLowerBoundPlaceholder: "e.g. 100",
        priceUpperBound: "Price upper bound",
        priceUpperBoundPlaceholder: "e.g. 200",
        currentPrice: "Current price (P‚ÇÄ)",
        currentPricePlaceholder: "e.g. 130",
        dailyVolatility: "Daily volatility (percent)",
        dailyVolatilityPlaceholder: "e.g. 7.26 means 7.26%",
        feeAprInput: "Fee APR (%)",
        feeAprInputPlaceholder: "e.g. 15.5 means 15.5%",
        simulationDays: "simulation days",
        simulationDaysPlaceholder: "Forecast days, e.g. 30",
        numberOfPaths: "Number of simulations",
        numberOfPathsPlaceholder: "Number of simulations, default 1000",
        runSimulation: "Run Simulation",
        runningSimulation: "Running Monte Carlo simulation...",
        simulationResults: "Simulation results",
        expectedIL: "Expected IL",
        dailyIL: "Daily IL",
        equivalentILApr: "Equivalent IL APR",
        feeBreakEvenApr: "Net APR",
        volumeIlCorrelation: "Volume-IL Correlation (cov)",
        totalReturnStdDev: "Total Return Std. Dev. (Annualized)",
        sharpeRatio: "Sharpe Ratio",
        worstCaseMdd: "95% Worst-Case MDD",
        ilInterval: "5% ‚Äì 95% IL interval",
        stdDeviationIL: "IL Std. Dev. (Total)",
        ilDistribution: "IL distribution (percent)",
        ilDistributionDesc: "Based on IL samples obtained from Monte Carlo simulation, bin the results and plot as a frequency histogram.",
        frequencyOfSimulatedIL: "Frequency of simulated IL",
        monteCarloPath: "Future Price Simulation",
        monteCarloPathDesc: "Assuming prices follow a random walk based on daily volatility, the chart shows multiple simulated future price change curves, with each curve representing one possible price trajectory.",
        pricePath: "Price Path",
        lpRange: "LP Range",
        dayLabel: "Day {day}",
        priceLabel: "Price",
        percentageLabel: "Percentage (%)",
        currentPriceLabel: "Current Price",
        dailyVolatilityLabel: "Daily Volatility",
        simulationDaysLabel: "Simulation Days",
        daysAxisLabel: "Days",
        // Stats
        dex: "DEX",
        pair: "Pair",
        poolIdLpId: "Pool ID (LP ID)",
        priceUsd: "{symbol} Price (USD)",
        token0Amount: "{symbol} Amount",
        token1Amount: "{symbol} Amount",
        volume7d: "7-Day Daily Average Volume (USD)",
        marketCap: "Market Cap (USD)",
        correlationCoefficient: "Correlation Coefficient (œÅ)",
        lastUpdated: "Last Updated",
        calculating: "Calculating...",
        // Fee Prediction
        feePrediction: "Fee Prediction",
        currentTvl: "Current TVL",
        dailyVolume7d: "7-Day Daily Average Volume (USD)",
        dailyVolume7dStdDev: "7-Day Volume Std Dev (USD)",
        feePercentage: "Fee Percentage (%)",
        feePercentagePlaceholder: "e.g. 0.3 for 0.3%",
        dailyFeeApr: "Daily Fee APR",
        dailyFee: "Daily Fee (%)",
        pancakeswapFeeNote: "On PancakeSwap platform, liquidity providers can only receive 84% of trading fee income, calculation values have been automatically adjusted.",
        pancakeswapFeeNoteLink: "Click to view details",
        calculateFeeApr: "Calculate Fee APR",
        // Loading messages
        loadingFromGeckoTerminal: "Loading from GeckoTerminal API...",
        loadingOhlcvData: "Loading 180 days of OHLCV data for both tokens...",
        // Simulation status
        simulationDone: "Done. Simulated {paths} paths over {days} days (œÉ‚Ççdaily‚Çé = {sigma}%).",
        // Errors
        pleaseInputPoolId: "Please input a pool id (Solana pool address).",
        invalidPriceInput: "Please enter valid prices, including lower bound, upper bound, and current price.",
        priceMustBePositive: "Price must be greater than 0.",
        lowerBoundMustBeLess: "Lower bound must be less than upper bound.",
        invalidVolatility: "Please enter a valid daily volatility (percentage).",
        daysMustBePositive: "Forecast days must be a positive integer.",
        daysExceedsLimit: "Simulation days cannot exceed 3650.",
        pathsExceedsLimit: "Number of simulations cannot exceed 1000000.",
        // Ratio volatility
        ratioVolatility: "Ratio Volatility",
        // HV buttons
        hvToken0: " HV",
        hvToken1: " HV",
        // HV errors
        insufficientPriceData: "Insufficient price data to calculate volatility for {tokenName} (need at least 10 valid prices).",
        needBothVolatilities: "Insufficient data: Need both token0 and token1 volatility.",
        cannotCalculateCorrelation: "Insufficient data: Cannot calculate correlation coefficient.",
        invalidVolatilityCalculation: "Error: Invalid volatility calculation (negative variance).",
        noPriceDataAvailable: "No price data available. Please load a pool first.",
        calculatingRatioVolatility: "Calculating price ratio volatility...",
      },
      zh: {
        // Page header
        title: "Ëøô‰∏™ÊµÅÂä®ÊÄßÊ±†ÂÄºÂæóÊäïËµÑÂêóÔºü",
        tagline: "ÂÆûÊó∂ÊåáÊ†áÂíåÊó†Â∏∏ÊçüÂ§±ËÆ°ÁÆóÂô®",
        // Pool ID section
        poolId: "ÊµÅÂä®ÊÄßÊ±†ID",
        geckoTerminalBadge: "ÁÉ≠Èó®ÊµÅÂä®ÊÄßÊ±†",
        poolIdLabel: "Á≤òË¥¥‰ªªÊÑè Solana Ê±†Âú∞ÂùÄ‰ª•Êü•ÁúãÂÖ∂ÁªüËÆ°‰ø°ÊÅØ„ÄÇ",
        loadPool: "Âä†ËΩΩÊµÅÂä®ÊÄßÊ±†",
        apiKeyConfig: "api_key_config",
        enterBirdeyeKey: "ËæìÂÖ•ÊÇ®ÁöÑ Birdeye API ÂØÜÈí•",
        checkKey: "Ê£ÄÊü•ÂØÜÈí•",
        defaultApiKeyNote: "ÈªòËÆ§‰ΩøÁî®ÂÜÖÁΩÆ API ÂØÜÈí•„ÄÇË¶Å‰ΩøÁî®ÊÇ®Ëá™Â∑±ÁöÑÂØÜÈí•ÔºåËØ∑ÁÇπÂáª‰∏äÈù¢ÁöÑÊåâÈíÆ„ÄÇ",
        // Results section
        parsedPoolData: "ÊµÅÂä®ÊÄßÊ±†Êï∞ÊçÆ",
        keyMetrics: "ÂÖ≥ÈîÆÊåáÊ†á",
        liveFromGeckoTerminal: "Êù•Ëá™ GeckoTerminal ÁöÑÂÆûÊó∂Êï∞ÊçÆ",
        lastDaysLiquidity: "ÊúÄËøë {days} Â§©ÁöÑÊµÅÂä®ÊÄßÂíå‰∫§ÊòìÈáè",

        lookbackWindow: "ÊãñÂä®ÊªëÂùóÊîπÂèòÊó∂Èó¥Á™óÂè£",
        rawGeckoTerminalResponse: "ÂéüÂßã GeckoTerminal ÂìçÂ∫î",
        rawGeckoTerminalDesc: "Êù•Ëá™ GeckoTerminal Ê±†Âø´ÁÖß API ÁöÑÂÆåÊï¥ JSON „ÄÇ",
        rawBirdeyeResponse: "ÂéüÂßã Birdeye OHLCV ÂìçÂ∫î",
        rawBirdeyeDesc: "Êù•Ëá™ Birdeye OHLCV API ÁöÑÂÆåÊï¥ JSONÔºàÂ¶ÇÊûúÂèØÁî®Ôºâ„ÄÇ",
        // Chart labels
        tvlUsd: "TVL (ÁæéÂÖÉ)",
        tvl: "TVL",
        dailyVolumeUsd: "ÊØèÊó•‰∫§ÊòìÈáè (ÁæéÂÖÉ)",
        highPrice: "ÊúÄÈ´ò‰ª∑",
        lowPrice: "ÊúÄ‰Ωé‰ª∑",
        // IL Simulator
        ilSimulator: "Êó†Â∏∏ÊçüÂ§±Ê®°ÊãüÂô®",
        ilSimulatorSubtitle: "ËíôÁâπÂç°Ê¥õ",
        ilSimulatorDesc: "ËæìÂÖ•ÈõÜ‰∏≠ÊµÅÂä®ÊÄßËåÉÂõ¥„ÄÅÂΩìÂâç‰ª∑Ê†º„ÄÅÊØèÊó•Ê≥¢Âä®ÁéáÂíåÊó∂Èó¥ÊÆµ„ÄÇ‰ΩøÁî®GBMÔºàÂá†‰ΩïÂ∏ÉÊúóËøêÂä®ÔºâÂØπÊú™Êù•‰ª∑Ê†ºËøõË°åËíôÁâπÂç°Ê¥õÊ®°ÊãüÔºå‰º∞ÁÆóÈ¢ÑÊúü IL„ÄÅÂàÜÂ∏ÉÂíåÁΩÆ‰ø°Âå∫Èó¥„ÄÇ",
        priceLowerBound: "LP range ‰ª∑Ê†º‰∏ãÈôê",
        priceLowerBoundPlaceholder: "‰æãÂ¶ÇÔºö100",
        priceUpperBound: "LP range‰ª∑Ê†º‰∏äÈôê",
        priceUpperBoundPlaceholder: "‰æãÂ¶ÇÔºö200",
        currentPrice: "ÂΩìÂâç‰ª∑Ê†º (P‚ÇÄ)",
        currentPricePlaceholder: "‰æãÂ¶ÇÔºö130",
        dailyVolatility: "ÊØèÊó•Ê≥¢Âä®Áéá (ÁôæÂàÜÊØî)",
        dailyVolatilityPlaceholder: "‰æãÂ¶Ç 7.26 Ë°®Á§∫ 7.26%",
        feeAprInput: "ÊâãÁª≠Ë¥πÂπ¥ÂåñÊî∂ÁõäÁéá (%)",
        feeAprInputPlaceholder: "‰æãÂ¶Ç 15.5 Ë°®Á§∫ 15.5%",
        simulationDays: "Ê®°ÊãüÂ§©Êï∞",
        simulationDaysPlaceholder: "È¢ÑÊµãÂ§©Êï∞Ôºå‰æãÂ¶Ç 30",
        numberOfPaths: "Ê®°ÊãüÊ¨°Êï∞",
        numberOfPathsPlaceholder: "Ê®°ÊãüÊ¨°Êï∞ÔºåÈªòËÆ§ 1000",
        runSimulation: "ËøêË°åÊ®°Êãü",
        runningSimulation: "Ê≠£Âú®ËøêË°åËíôÁâπÂç°Ê¥õÊ®°Êãü...",
        simulationResults: "Ê®°ÊãüÁªìÊûú",
        expectedIL: "È¢ÑÊúü IL",
        dailyIL: "Êó•Âùá IL",
        equivalentILApr: "Á≠âÊïà IL Âπ¥Âåñ",
        feeBreakEvenApr: "ÂáÄÂπ¥ÂåñÊî∂ÁõäÁéá",
        volumeIlCorrelation: "‰∫§ÊòìÈáè-IL Áõ∏ÂÖ≥ÊÄß (cov)",
        totalReturnStdDev: "ÊÄªÂõûÊä•ÁéáAPRÊ†áÂáÜÂ∑Æ",
        sharpeRatio: "Â§èÊôÆÊØîÁéá",
        worstCaseMdd: "95% ÊúÄÂùèÊÉÖÂÜµÊúÄÂ§ßÂõûÊí§",
        ilInterval: "5% ‚Äì 95% IL Âå∫Èó¥",
        stdDeviationIL: "IL Ê†áÂáÜÂ∑Æ",
        ilDistribution: "IL ÂàÜÂ∏É (ÁôæÂàÜÊØî)",
        ilDistributionDesc: "Âü∫‰∫é‰ªéËíôÁâπÂç°Ê¥õÊ®°ÊãüËé∑ÂæóÁöÑ IL Ê†∑Êú¨ÔºåÂ∞ÜÁªìÊûúÁªòÂà∂‰∏∫È¢ëÁéáÁõ¥ÊñπÂõæ„ÄÇ",
        frequencyOfSimulatedIL: "Ê®°ÊãüÂæóÂà∞ÁöÑ IL ÂàÜÂ∏ÉÈ¢ëÁéá",
        monteCarloPath: "Êú™Êù•‰ª∑Ê†ºÊ®°Êãü",
        monteCarloPathDesc: "ÂÅáËÆæ‰ª∑Ê†ºÊåâÊØèÊó•Ê≥¢Âä®ÁéáÈöèÊú∫Ê∏∏Ëµ∞ÔºåÂõæ‰∏≠ÊòØÊ®°ÊãüÂ§öÊ¨°Êú™Êù•‰ª∑Ê†ºÂèòÂåñÁöÑÊõ≤Á∫øÔºåÊØèÊù°Êõ≤Á∫ø‰ª£Ë°®‰∏ÄÊ¨°ÂèØËÉΩÁöÑ‰ª∑Ê†ºËµ∞Âäø„ÄÇ",
        pricePath: "‰ª∑Ê†ºË∑ØÂæÑ",
        lpRange: "LP Range",
        dayLabel: "Á¨¨ {day} Â§©",
        priceLabel: "‰ª∑Ê†º",
        percentageLabel: "ÁôæÂàÜÊØî (%)",
        currentPriceLabel: "ÂΩìÂâç‰ª∑Ê†º",
        dailyVolatilityLabel: "ÊØèÊó•Ê≥¢Âä®Áéá",
        simulationDaysLabel: "Ê®°ÊãüÂ§©Êï∞",
        daysAxisLabel: "Â§©Êï∞",
        // Stats
        dex: "Âéª‰∏≠ÂøÉÂåñ‰∫§ÊòìÊâÄ",
        pair: "‰∫§ÊòìÂØπ",
        poolIdLpId: "ÊµÅÂä®ÊÄßÊ±†ID (LP ID)",
        priceUsd: "{symbol} ‰ª∑Ê†º (ÁæéÂÖÉ)",
        token0Amount: "{symbol} Êï∞Èáè",
        token1Amount: "{symbol} Êï∞Èáè",
        volume7d: "7Êó•Êó•Âùá‰∫§ÊòìÈáè (ÁæéÂÖÉ)",
        marketCap: "Â∏ÇÂÄº (ÁæéÂÖÉ)",
        correlationCoefficient: "Áõ∏ÂÖ≥Á≥ªÊï∞ (œÅ)",
        lastUpdated: "ÊúÄÂêé‰∏ÄÊ¨°Êõ¥Êñ∞‰∫éÔºö",
        calculating: "ËÆ°ÁÆó‰∏≠...",
        // Fee Prediction
        feePrediction: "ÊâãÁª≠Ë¥πÈ¢ÑÊµã",
        currentTvl: "ÂΩìÂâç TVL",
        dailyVolume7d: "7Êó•Êó•Âùá‰∫§ÊòìÈáè (ÁæéÂÖÉ)",
        dailyVolume7dStdDev: "7Êó•‰∫§ÊòìÈáèÊ†áÂáÜÂ∑Æ (ÁæéÂÖÉ)",
        feePercentage: "ÊâãÁª≠Ë¥πÁôæÂàÜÊØî (%)",
        feePercentagePlaceholder: "‰æãÂ¶ÇÔºö0.3 Ë°®Á§∫ 0.3%",
        dailyFeeApr: "Êó•ÂùáÊâãÁª≠Ë¥πÂπ¥ÂåñÊî∂ÁõäÁéá",
        dailyFee: "Êó•ÂùáÊâãÁª≠Ë¥π (%)",
        pancakeswapFeeNote: "pancakeswapÂπ≥Âè∞‰∏äÔºåÊµÅÂä®ÊÄßÊèê‰æõËÄÖÂè™ËÉΩËé∑Âæó 84%ÁöÑÊâãÁª≠Ë¥πÊî∂ÂÖ• ÔºåÂ∑≤Ëá™Âä®Ë∞ÉÊï¥ËÆ°ÁÆóÂÄº„ÄÇ",
        pancakeswapFeeNoteLink: "ÁÇπÂáªÊü•ÁúãËØ¶ÊÉÖ",
        calculateFeeApr: "ËÆ°ÁÆóÊâãÁª≠Ë¥πÂπ¥ÂåñÊî∂ÁõäÁéá",
        // Loading messages
        loadingFromGeckoTerminal: "Ê≠£Âú®‰ªé GeckoTerminal API Âä†ËΩΩ...",
        loadingOhlcvData: "Ê≠£Âú®Âä†ËΩΩ‰∏§‰∏™‰ª£Â∏ÅÁöÑ 180 Â§© OHLCV Êï∞ÊçÆ...",
        // Simulation status
        simulationDone: "ÂÆåÊàê„ÄÇÊ®°Êãü‰∫Ü {paths} Ê¨°ÔºåÊØèÊ¨°Ê®°Êãü {days} Â§© (œÉ‚Ççdaily‚Çé = {sigma}%)„ÄÇ",
        // Errors
        pleaseInputPoolId: "ËØ∑ËæìÂÖ•ÊµÅÂä®ÊÄßÊ±†ID (Solana ÊµÅÂä®ÊÄßÊ±†Âú∞ÂùÄ)„ÄÇ",
        invalidPriceInput: "ËØ∑Â°´ÂÜôÊúâÊïàÁöÑ‰ª∑Ê†ºÔºåÂåÖÂê´Âå∫Èó¥‰∏ãÁïå„ÄÅ‰∏äÁïåÂíåÂΩìÂâç‰ª∑Ê†º„ÄÇ",
        priceMustBePositive: "‰ª∑Ê†ºÂøÖÈ°ªÂ§ß‰∫é 0„ÄÇ",
        lowerBoundMustBeLess: "Âå∫Èó¥‰∏ãÁïåÂøÖÈ°ªÂ∞è‰∫é‰∏äÁïå„ÄÇ",
        invalidVolatility: "ËØ∑Â°´ÂÜôÊúâÊïàÁöÑÊó•Ê≥¢Âä®ÁéáÔºàÁôæÂàÜÊØîÔºâ„ÄÇ",
        daysMustBePositive: "È¢ÑÊµãÂ§©Êï∞ÂøÖÈ°ª‰∏∫Ê≠£Êï¥Êï∞„ÄÇ",
        daysExceedsLimit: "Ê®°ÊãüÂ§©Êï∞‰∏çËÉΩË∂ÖËøá 3650„ÄÇ",
        pathsExceedsLimit: "Ê®°ÊãüÊ¨°Êï∞‰∏çËÉΩË∂ÖËøá 1000000„ÄÇ",
        // Ratio volatility
        ratioVolatility: "Âä†ÊùÉÊ≥¢Âä®Áéá",
        // HV buttons
        hvToken0: " ÂéÜÂè≤Ê≥¢Âä®Áéá",
        hvToken1: " ÂéÜÂè≤Ê≥¢Âä®Áéá",
        // HV errors
        insufficientPriceData: "‰ª∑Ê†ºÊï∞ÊçÆ‰∏çË∂≥ÔºåÊó†Ê≥ïËÆ°ÁÆó {tokenName} ÁöÑÊ≥¢Âä®ÁéáÔºàËá≥Â∞ëÈúÄË¶Å 10 ‰∏™ÊúâÊïà‰ª∑Ê†ºÔºâ„ÄÇ",
        needBothVolatilities: "Êï∞ÊçÆ‰∏çË∂≥ÔºöÈúÄË¶Å token0 Âíå token1 ÁöÑÊ≥¢Âä®Áéá„ÄÇ",
        cannotCalculateCorrelation: "Êï∞ÊçÆ‰∏çË∂≥ÔºöÊó†Ê≥ïËÆ°ÁÆóÁõ∏ÂÖ≥Á≥ªÊï∞„ÄÇ",
        invalidVolatilityCalculation: "ÈîôËØØÔºöÊó†ÊïàÁöÑÊ≥¢Âä®ÁéáËÆ°ÁÆóÔºàÊñπÂ∑Æ‰∏∫Ë¥üÔºâ„ÄÇ",
        noPriceDataAvailable: "Ê≤°Êúâ‰ª∑Ê†ºÊï∞ÊçÆÂèØÁî®„ÄÇËØ∑ÂÖàÂä†ËΩΩ‰∏Ä‰∏™Ê±†„ÄÇ",
        calculatingRatioVolatility: "Ê≠£Âú®ËÆ°ÁÆó‰ª∑Ê†ºÊØîÁéáÊ≥¢Âä®Áéá...",
      }
    };

    // Detect user language
    function detectUserLanguage() {
      // Check localStorage first
      const savedLang = localStorage.getItem('appLanguage');
      if (savedLang && (savedLang === 'en' || savedLang === 'zh')) {
        return savedLang;
      }
      // Detect from browser
      const browserLang = navigator.language || navigator.userLanguage;
      if (browserLang.startsWith('zh')) {
        return 'zh';
      }
      return 'en';
    }

    // Current language
    let currentLang = detectUserLanguage();

    // Translation function
    function t(key, params = {}) {
      const translation = translations[currentLang]?.[key] || translations.en[key] || key;
      if (params && Object.keys(params).length > 0) {
        return translation.replace(/\{(\w+)\}/g, (match, paramKey) => {
          return params[paramKey] !== undefined ? params[paramKey] : match;
        });
      }
      return translation;
    }

    // Update all text content
    function updateLanguage() {
      // Save to localStorage
      localStorage.setItem('appLanguage', currentLang);
      
      // Update HTML lang attribute
      const htmlLang = document.getElementById('htmlLang');
      if (htmlLang) {
        htmlLang.setAttribute('lang', currentLang === 'zh' ? 'zh-CN' : 'en');
      } else {
        document.documentElement.setAttribute('lang', currentLang === 'zh' ? 'zh-CN' : 'en');
      }
      
      // Update language switcher
      const langSwitcherText = document.getElementById('langSwitcherText');
      if (langSwitcherText) {
        langSwitcherText.textContent = currentLang === 'zh' ? 'EN/‰∏≠Êñá' : '‰∏≠Êñá/EN';
      }

      // Update page title
      const pageTitle = document.getElementById('pageTitle');
      if (pageTitle) pageTitle.textContent = t('title');
      const pageTagline = document.getElementById('pageTagline');
      if (pageTagline) pageTagline.textContent = t('tagline');
      
      // Update Pool ID section
      const poolIdTitle = document.getElementById('poolIdTitle');
      if (poolIdTitle) poolIdTitle.textContent = t('poolId');
      const geckoBadge = document.getElementById('geckoBadge');
      if (geckoBadge) geckoBadge.textContent = t('geckoTerminalBadge');
      const poolIdLabel = document.getElementById('poolIdLabel');
      if (poolIdLabel) poolIdLabel.textContent = t('poolIdLabel');
      const loadBtnText = document.getElementById('loadBtnText');
      if (loadBtnText) loadBtnText.textContent = t('loadPool');
      const toggleKeyText = document.getElementById('toggleCustomKeyText');
      if (toggleKeyText) toggleKeyText.textContent = t('apiKeyConfig');
      const birdeyeKeyInput = document.getElementById('birdeyeApiKey');
      if (birdeyeKeyInput) birdeyeKeyInput.placeholder = t('enterBirdeyeKey');
      const checkKeyBtnText = document.getElementById('checkKeyBtnText');
      if (checkKeyBtnText) checkKeyBtnText.textContent = t('checkKey');
      const defaultKeyNote = document.getElementById('defaultKeyNote');
      if (defaultKeyNote) defaultKeyNote.textContent = t('defaultApiKeyNote');

      // Update results section
      const resultsTitle = document.getElementById('resultsTitle');
      if (resultsTitle) resultsTitle.textContent = t('parsedPoolData');
      const keyMetricsLabel = document.getElementById('keyMetricsLabel');
      if (keyMetricsLabel) keyMetricsLabel.textContent = t('keyMetrics');
      const liveFromLabel = document.getElementById('liveFromLabel');
      if (liveFromLabel) liveFromLabel.textContent = t('liveFromGeckoTerminal');
      
      // Update chart section
      const lastDaysLabel = document.getElementById('lastDaysLabel');
      const daysLabelSuffix = document.getElementById('daysLabelSuffix');
      if (lastDaysLabel && daysLabelSuffix) {
        const daysText = t('lastDaysLiquidity', { days: document.getElementById('daysLabel')?.textContent || '30' });
        // Split the text appropriately
        if (currentLang === 'zh') {
          lastDaysLabel.textContent = 'ÊúÄËøë ';
          daysLabelSuffix.textContent = ' Â§©ÁöÑÊµÅÂä®ÊÄßÂíå‰∫§ÊòìÈáè';
        } else {
          lastDaysLabel.textContent = 'Last ';
          daysLabelSuffix.textContent = ' Days Liquidity & Volume';
        }
      }
      const tvlLineNote = document.getElementById('tvlLineNote');
      if (tvlLineNote) tvlLineNote.textContent = t('tvlLineNote');
      const lookbackWindowLabel = document.getElementById('lookbackWindowLabel');
      if (lookbackWindowLabel) lookbackWindowLabel.textContent = t('lookbackWindow');
      
      // Update raw JSON sections
      const rawGeckoLabel = document.getElementById('rawGeckoLabel');
      if (rawGeckoLabel) rawGeckoLabel.textContent = t('rawGeckoTerminalResponse');
      const rawGeckoDesc = document.getElementById('rawGeckoDesc');
      if (rawGeckoDesc) rawGeckoDesc.textContent = t('rawGeckoTerminalDesc');
      const rawBirdeyeLabel = document.getElementById('rawBirdeyeLabel');
      if (rawBirdeyeLabel) rawBirdeyeLabel.textContent = t('rawBirdeyeResponse');
      const rawBirdeyeDesc = document.getElementById('rawBirdeyeDesc');
      if (rawBirdeyeDesc) rawBirdeyeDesc.textContent = t('rawBirdeyeDesc');

      // Update IL Simulator
      // Update Fee Prediction section
      const feePredictionTitle = document.getElementById('feePredictionTitle');
      if (feePredictionTitle) feePredictionTitle.textContent = t('feePrediction');
      const currentTvlLabel = document.getElementById('currentTvlLabel');
      if (currentTvlLabel) currentTvlLabel.textContent = t('currentTvl');
      const dailyVolume7dLabel = document.getElementById('dailyVolume7dLabel');
      if (dailyVolume7dLabel) dailyVolume7dLabel.textContent = t('dailyVolume7d');
      const dailyVolume7dStdDevLabel = document.getElementById('dailyVolume7dStdDevLabel');
      if (dailyVolume7dStdDevLabel) dailyVolume7dStdDevLabel.textContent = t('dailyVolume7dStdDev');
      const feePercentageLabel = document.getElementById('feePercentageLabel');
      if (feePercentageLabel) feePercentageLabel.textContent = t('feePercentage');
      const feePercentageInput = document.getElementById('feePercentageInput');
      if (feePercentageInput) feePercentageInput.placeholder = t('feePercentagePlaceholder');
      const pancakeswapFeeNoteText = document.getElementById('pancakeswapFeeNoteText');
      const pancakeswapFeeNoteLink = document.getElementById('pancakeswapFeeNoteLink');
      if (pancakeswapFeeNoteText) pancakeswapFeeNoteText.textContent = t('pancakeswapFeeNote');
      if (pancakeswapFeeNoteLink) pancakeswapFeeNoteLink.textContent = t('pancakeswapFeeNoteLink');
      const feeDisplayLabel = document.getElementById('feeDisplayLabel');
      if (feeDisplayLabel) {
        const displayType = document.getElementById('feeDisplayStat')?.getAttribute("data-display-type");
        if (displayType === "apr") {
          feeDisplayLabel.textContent = t('dailyFeeApr');
        } else {
          feeDisplayLabel.textContent = t('dailyFee');
        }
      }
      
      const ilSimulatorTitle = document.getElementById('ilSimulatorTitle');
      if (ilSimulatorTitle) ilSimulatorTitle.textContent = t('ilSimulator');
      const ilSimulatorSubtitle = document.getElementById('ilSimulatorSubtitle');
      if (ilSimulatorSubtitle) ilSimulatorSubtitle.textContent = t('ilSimulatorSubtitle');
      const ilSimulatorDesc = document.getElementById('ilSimulatorDesc');
      if (ilSimulatorDesc) ilSimulatorDesc.textContent = t('ilSimulatorDesc');
      const runSimulationText = document.getElementById('runSimulationText');
      if (runSimulationText) runSimulationText.textContent = t('runSimulation');
      const simulationResultsLabel = document.getElementById('simulationResultsLabel');
      if (simulationResultsLabel) simulationResultsLabel.textContent = t('simulationResults');
      const expectedILLabel = document.getElementById('expectedILLabel');
      if (expectedILLabel) expectedILLabel.textContent = t('expectedIL');
      const dailyILLabel = document.getElementById('dailyILLabel');
      if (dailyILLabel) dailyILLabel.textContent = t('dailyIL');
      const equivalentILAprLabel = document.getElementById('equivalentILAprLabel');
      if (equivalentILAprLabel) equivalentILAprLabel.textContent = t('equivalentILApr');
      const feeBreakEvenAprLabel = document.getElementById('feeBreakEvenAprLabel');
      if (feeBreakEvenAprLabel) feeBreakEvenAprLabel.textContent = t('feeBreakEvenApr');
      const correlationLabel = document.getElementById('correlationLabel');
      if (correlationLabel) correlationLabel.textContent = t('volumeIlCorrelation');
      const totalReturnStdLabel = document.getElementById('totalReturnStdLabel');
      if (totalReturnStdLabel) totalReturnStdLabel.textContent = t('totalReturnStdDev');
      const sharpeRatioLabel = document.getElementById('sharpeRatioLabel');
      if (sharpeRatioLabel) sharpeRatioLabel.textContent = t('sharpeRatio');
      const worstCaseMddLabel = document.getElementById('worstCaseMddLabel');
      if (worstCaseMddLabel) worstCaseMddLabel.textContent = t('worstCaseMdd');
      const ilIntervalLabel = document.getElementById('ilIntervalLabel');
      if (ilIntervalLabel) ilIntervalLabel.textContent = t('ilInterval');
      const stdDeviationILLabel = document.getElementById('stdDeviationILLabel');
      if (stdDeviationILLabel) stdDeviationILLabel.textContent = t('stdDeviationIL');
      const ilDistributionLabel = document.getElementById('ilDistributionLabel');
      if (ilDistributionLabel) ilDistributionLabel.textContent = t('ilDistribution');
      const ilDistributionDesc = document.getElementById('ilDistributionDesc');
      if (ilDistributionDesc) ilDistributionDesc.textContent = t('ilDistributionDesc');
      const frequencyLabel = document.getElementById('frequencyLabel');
      if (frequencyLabel) frequencyLabel.textContent = t('frequencyOfSimulatedIL');
      const monteCarloPathLabel = document.getElementById('monteCarloPathLabel');
      if (monteCarloPathLabel) monteCarloPathLabel.textContent = t('monteCarloPath');
      const monteCarloPathDesc = document.getElementById('monteCarloPathDesc');
      if (monteCarloPathDesc) monteCarloPathDesc.textContent = t('monteCarloPathDesc');
      const pricePathLabel = document.getElementById('pricePathLabel');
      if (pricePathLabel) pricePathLabel.textContent = t('pricePath');
      const lpRangeLabel = document.getElementById('lpRangeLabel');
      if (lpRangeLabel) lpRangeLabel.textContent = t('lpRange');
      
      // Update ratio volatility button
      const ratioVolatilityBtnText = document.getElementById('ratioVolatilityBtnText');
      if (ratioVolatilityBtnText) ratioVolatilityBtnText.textContent = t('ratioVolatility');

      // Update stat labels
      updateStatLabels();
      
      // Update chart labels
      updateChartLabels();
      
      // Update input placeholders
      const ilLower = document.getElementById('ilLower');
      if (ilLower) ilLower.placeholder = t('priceLowerBoundPlaceholder');
      const ilUpper = document.getElementById('ilUpper');
      if (ilUpper) ilUpper.placeholder = t('priceUpperBoundPlaceholder');
      const ilP0 = document.getElementById('ilP0');
      if (ilP0) ilP0.placeholder = t('currentPricePlaceholder');
      const ilSigmaDaily = document.getElementById('ilSigmaDaily');
      if (ilSigmaDaily) ilSigmaDaily.placeholder = t('dailyVolatilityPlaceholder');
      const feeAprInputLabel = document.getElementById('feeAprInputLabel');
      if (feeAprInputLabel) feeAprInputLabel.textContent = t('feeAprInput');
      const ilFeeApr = document.getElementById('ilFeeApr');
      if (ilFeeApr) ilFeeApr.placeholder = t('feeAprInputPlaceholder');
      const ilDays = document.getElementById('ilDays');
      if (ilDays) ilDays.placeholder = t('simulationDaysPlaceholder');
      const ilPaths = document.getElementById('ilPaths');
      if (ilPaths) ilPaths.placeholder = t('numberOfPathsPlaceholder');
    }

    // Update stat labels dynamically
    function updateStatLabels() {
      const statLabels = document.querySelectorAll('.stat-label');
      statLabels.forEach(label => {
        const text = label.textContent.trim();
        if (text === 'Price lower bound' || text === '‰ª∑Ê†º‰∏ãÈôê' || text.includes('LP range ‰ª∑Ê†º‰∏ãÈôê') || text.includes('‰ª∑Ê†º‰∏ãÈôê')) {
          label.textContent = t('priceLowerBound');
        } else if (text === 'Price upper bound' || text === '‰ª∑Ê†º‰∏äÈôê' || text.includes('LP range‰ª∑Ê†º‰∏äÈôê') || text.includes('‰ª∑Ê†º‰∏äÈôê')) {
          label.textContent = t('priceUpperBound');
        } else if (text.includes('Current price') || text.includes('ÂΩìÂâç‰ª∑Ê†º')) {
          label.textContent = t('currentPrice');
        } else if (text.includes('Daily volatility') || text.includes('ÊØèÊó•Ê≥¢Âä®Áéá')) {
          label.innerHTML = `<span>${t('dailyVolatility')}</span>`;
        } else if (text.includes('simulation days') || text.includes('Ê®°ÊãüÂ§©Êï∞')) {
          label.innerHTML = `<span>${t('simulationDays')}</span>`;
        } else if (text === 'Number of paths' || text === 'Number of simulations' || text === 'Ë∑ØÂæÑÊï∞Èáè' || text === 'Ê®°ÊãüÊ¨°Êï∞') {
          label.textContent = t('numberOfPaths');
        } else if (text === 'Expected IL' || text === 'È¢ÑÊúü IL') {
          label.textContent = t('expectedIL');
        } else if (text === 'Daily IL' || text === 'Êó•Âùá IL') {
          label.textContent = t('dailyIL');
        } else if (text === 'Equivalent IL APR' || text.includes('Á≠âÊïà IL Âπ¥ÂåñÊî∂ÁõäÁéá')) {
          label.textContent = t('equivalentILApr');
        } else if (text === 'Fee Break-even APR' || text === 'Net APR' || text.includes('ÊâãÁª≠Ë¥πÁõà‰∫èÂπ≥Ë°°') || text === 'Áõà‰∫èÂπ≥Ë°°Á∫ø') {
          label.textContent = t('feeBreakEvenApr');
        } else if (text.includes('5% ‚Äì 95%') || text.includes('5% ‚Äì 95%')) {
          label.textContent = t('ilInterval');
        } else if (text.includes('7-Day Volume Std Dev') || text.includes('7Êó•‰∫§ÊòìÈáèÊ†áÂáÜÂ∑Æ') || (text.includes('Volume Std Dev') && !text.includes('IL'))) {
          label.textContent = t('dailyVolume7dStdDev');
        } else if (text.includes('Total Return Std. Dev.') || text.includes('ÊÄªÂõûÊä•ÁéáAPRÊ†áÂáÜÂ∑Æ')) {
          label.textContent = t('totalReturnStdDev');
        } else if (text.includes('Std. deviation') || text.includes('Ê†áÂáÜÂ∑Æ')) {
          label.textContent = t('stdDeviationIL');
        } else if (text === 'DEX' || text === 'Âéª‰∏≠ÂøÉÂåñ‰∫§ÊòìÊâÄ') {
          label.textContent = t('dex');
        } else if (text === 'Pair' || text === '‰∫§ÊòìÂØπ') {
          label.textContent = t('pair');
        } else if (text.includes('Pool ID (LP ID)') || text.includes('Ê±†ID (LP ID)')) {
          label.textContent = t('poolIdLpId');
        } else if (text.includes('Volume 7d') || text.includes('7-Day Daily Average') || text.includes('7Â§©‰∫§ÊòìÈáè') || text.includes('7Êó•Êó•Âùá')) {
          label.textContent = t('volume7d');
        } else if (text.includes('Market Cap') || text.includes('Â∏ÇÂÄº')) {
          label.textContent = t('marketCap');
        } else if (text.includes('Correlation Coefficient') || text.includes('Áõ∏ÂÖ≥Á≥ªÊï∞')) {
          label.textContent = t('correlationCoefficient');
        } else if (text === 'Last Updated' || text === 'ÊúÄÂêéÊõ¥Êñ∞' || text === 'ÊúÄÂêé‰∏ÄÊ¨°Êõ¥Êñ∞‰∫éÔºö' || text.startsWith('ÊúÄÂêé‰∏ÄÊ¨°Êõ¥Êñ∞‰∫é')) {
          label.textContent = t('lastUpdated');
        } else if ((text.includes('Êï∞Èáè') && !text.includes('Ë∑ØÂæÑÊï∞Èáè') && !text.includes('Ê®°ÊãüÊ¨°Êï∞')) || (text.includes('Amount') && !text.includes('Number of') && !text.includes('Daily Average'))) {
          // Handle token amount labels - try to extract symbol
          // Match patterns like "SOL Êï∞Èáè", "USDC Êï∞Èáè", "SOL Amount", "USDC Amount"
          const symbolMatch = text.match(/(\w+)\s+(Êï∞Èáè|Amount)/);
          if (symbolMatch && symbolMatch[1]) {
            // Both token0Amount and token1Amount have the same format, so we can use either
            label.textContent = t('token0Amount', { symbol: symbolMatch[1] });
          }
        } else if (text.includes('‰ª∑Ê†º (ÁæéÂÖÉ)') || (text.includes('Price (USD)') && text.includes('‰ª∑Ê†º'))) {
          // Handle price labels that might have Chinese text
          // Try to extract symbol from text like "SOL ‰ª∑Ê†º (ÁæéÂÖÉ)" or "{symbol} ‰ª∑Ê†º (ÁæéÂÖÉ)"
          const symbolMatch = text.match(/(\w+)\s*‰ª∑Ê†º/);
          if (symbolMatch && symbolMatch[1]) {
            label.textContent = t('priceUsd', { symbol: symbolMatch[1] });
          } else {
            // Fallback: replace Chinese with English
            label.textContent = text.replace(/\s*‰ª∑Ê†º\s*\(ÁæéÂÖÉ\)/g, ' Price (USD)').replace(/‰ª∑Ê†º/g, 'Price');
          }
        }
      });
    }

    // Update chart labels
    function updateChartLabels() {
      const tvlLegend = document.getElementById('tvlLegend');
      if (tvlLegend) {
        const span = tvlLegend.querySelector('span:last-child');
        if (span && (span.textContent.includes('TVL') || span.textContent.includes('TVL'))) {
          span.textContent = t('tvlUsd');
        }
      }
      const volumeLegend = document.getElementById('volumeLegend');
      if (volumeLegend) {
        const span = volumeLegend.querySelector('span:last-child');
        if (span && (span.textContent.includes('Daily Volume') || span.textContent.includes('ÊØèÊó•‰∫§ÊòìÈáè'))) {
          span.textContent = t('dailyVolumeUsd');
        }
      }
      const highLabels = document.querySelectorAll('#token0HighLabel, #token1HighLabel');
      highLabels.forEach(el => {
        if (el && (el.textContent.includes('High Price') || el.textContent.includes('ÊúÄÈ´ò‰ª∑'))) {
          el.textContent = t('highPrice');
        }
      });
      const lowLabels = document.querySelectorAll('#token0LowLabel, #token1LowLabel');
      lowLabels.forEach(el => {
        if (el && (el.textContent.includes('Low Price') || el.textContent.includes('ÊúÄ‰Ωé‰ª∑'))) {
          el.textContent = t('lowPrice');
        }
      });
      
      // Update Monte Carlo Simulation Path chart axis labels
      if (monteCarloPathChartInstance) {
        monteCarloPathChartInstance.options.scales.x.title.text = t('daysAxisLabel');
        monteCarloPathChartInstance.options.scales.y.title.text = monteCarloAxisMode === 'percentage' ? t('percentageLabel') : t('priceLabel');
        monteCarloPathChartInstance.update('none');
      }
      
      // Update Monte Carlo axis toggle button text
      const toggleText = document.getElementById('monteCarloAxisToggleText');
      if (toggleText) {
        toggleText.textContent = monteCarloAxisMode === 'price' ? t('priceLabel') : t('percentageLabel');
      }
    }

    // Language switcher button event
    const langSwitcher = document.getElementById('langSwitcher');
    if (langSwitcher) {
      langSwitcher.addEventListener('click', () => {
        currentLang = currentLang === 'en' ? 'zh' : 'en';
        updateLanguage();
      });
    }

    // Initialize language on page load
    window.addEventListener('DOMContentLoaded', () => {
      // ÂàùÂßãÂåñÊâãÁª≠Ë¥π APR ËÆ°ÁÆóÂäüËÉΩ
      setupFeeAprCalculation();
      updateLanguage();
    });

    function toggleCollapsible(sectionId) {
      const section = document.getElementById(sectionId);
      const arrow = document.getElementById(sectionId.replace('Section', 'Arrow'));
      if (section && arrow) {
        const isExpanded = section.style.display !== 'none';
        section.style.display = isExpanded ? 'none' : 'block';
        arrow.textContent = isExpanded ? '‚ñ∂' : '‚ñº';
      }
    }

    // Format number to 12 significant digits
    function toSignificantDigits(num, digits = 12) {
      // Ensure input is a number type
      if (typeof num !== 'number') {
        num = Number(num);
      }
      
      if (!Number.isFinite(num)) {
        return String(num);
      }
      
      if (num === 0) {
        return "0";
      }
      
      // Use toPrecision to ensure specified number of significant digits
      const formatted = num.toPrecision(digits);
      
      // If result contains scientific notation (e or E), return directly
      if (formatted.includes('e') || formatted.includes('E')) {
        return formatted;
      }
      
      // Remove trailing unnecessary zeros
      // Example: 139.387752996000 -> 139.387752996
      // Note: parseFloat may lose some precision, so we need to handle carefully
      const parsed = parseFloat(formatted);
      const parsedStr = parsed.toString();
      
      // If parsed string length is reasonable, use it (more concise)
      // Otherwise use the original toPrecision result
      if (parsedStr.length <= formatted.length + 2) {
        return parsedStr;
      }
      
      return formatted;
    }

    // ========== Default API Key Configuration ==========
    // To set a default API Key, follow these steps:
    // 1. Run in browser console: obfuscateKey('your actual API Key')
    // 2. Replace the DEFAULT_BIRDEYE_API_KEY_OBFUSCATED value below with the returned obfuscated string
    // 3. Save the file
    // 
    // Example:
    // const DEFAULT_BIRDEYE_API_KEY_OBFUSCATED = 'QXJhY2h5X0FQSV9LZXlfMTIzNDU2Nzg5MA==';
    const DEFAULT_BIRDEYE_API_KEY_OBFUSCATED = 'YOUR_OBFUSCATED_KEY_HERE'; // Please replace with obfuscated API Key

    // Simple obfuscation function (only to prevent casual users from seeing it, cannot prevent professional users)
    // Warning: Pure frontend encryption cannot truly protect API Key, this is only obfuscation
    function obfuscateKey(key) {
      if (!key) return null;
      // Use simple character offset + Base64 encoding
      const offset = 13; // ROT13-like
      let obfuscated = '';
      for (let i = 0; i < key.length; i++) {
        const charCode = key.charCodeAt(i);
        obfuscated += String.fromCharCode(charCode + offset);
      }
      return btoa(obfuscated); // Base64 encoding
    }

    function deobfuscateKey(obfuscated) {
      if (!obfuscated) return null;
      try {
        const decoded = atob(obfuscated); // Base64 decoding
        const offset = 13;
        let key = '';
        for (let i = 0; i < decoded.length; i++) {
          const charCode = decoded.charCodeAt(i);
          key += String.fromCharCode(charCode - offset);
        }
        return key;
      } catch (e) {
        console.error('Failed to deobfuscate key:', e);
        return null;
      }
    }

    // Get default API Key (if set)
    function getDefaultBirdeyeApiKey() {
      // Check if default Key is set (not a placeholder)
      if (!DEFAULT_BIRDEYE_API_KEY_OBFUSCATED || DEFAULT_BIRDEYE_API_KEY_OBFUSCATED === 'YOUR_OBFUSCATED_KEY_HERE') {
        return null;
      }
      
      try {
        const deobfuscated = deobfuscateKey(DEFAULT_BIRDEYE_API_KEY_OBFUSCATED);
        if (deobfuscated && deobfuscated.trim()) {
          return deobfuscated.trim();
        }
      } catch (e) {
        console.error("Failed to deobfuscate default API key:", e);
      }
      
      return null;
    }

    // Read obfuscated key from localStorage (if exists)
    function getStoredBirdeyeApiKey() {
      try {
        const stored = localStorage.getItem('birdeye_api_key_obf');
        if (stored) {
          return deobfuscateKey(stored);
        }
      } catch (e) {
        console.error('Failed to read stored key:', e);
      }
      return null;
    }

    // Save obfuscated key to localStorage
    function storeBirdeyeApiKey(key) {
      try {
        if (key && key.trim()) {
          const obfuscated = obfuscateKey(key.trim());
          localStorage.setItem('birdeye_api_key_obf', obfuscated);
        } else {
          localStorage.removeItem('birdeye_api_key_obf');
        }
      } catch (e) {
        console.error('Failed to store key:', e);
      }
    }

    function getBirdeyeApiKey() {
      // Priority 1: Get from input field (user newly entered)
      const el = document.getElementById("birdeyeApiKey");
      if (el && el.value && el.value.trim()) {
        const inputKey = el.value.trim();
        // Automatically save to localStorage
        storeBirdeyeApiKey(inputKey);
        return inputKey;
      }
      
      // Priority 2: Read from localStorage (user previously saved)
      const storedKey = getStoredBirdeyeApiKey();
      if (storedKey) {
        return storedKey;
      }
      
      // ‰ºòÂÖàÁ∫ß 3: ‰ΩøÁî®ÈªòËÆ§ÁöÑ API KeyÔºàÊ∑∑Ê∑ÜÂêéÁöÑÔºâ- ÂΩìËæìÂÖ•Ê°Ü‰∏∫Á©∫Êó∂Ëá™Âä®‰ΩøÁî®
      const defaultKey = getDefaultBirdeyeApiKey();
      if (defaultKey) {
        console.log("‰ΩøÁî®ÈªòËÆ§ÁöÑ Birdeye API KeyÔºàËæìÂÖ•Ê°Ü‰∏∫Á©∫Ôºâ");
        return defaultKey;
      }
      
      // If all methods fail, return null
      console.warn("Birdeye API Key not found: input field is empty, localStorage is empty, and no default Key is set");
      return null;
    }

    let currentDays = 30; // Currently selected days (controlled by slider), default 30 days
    let tvlVolumeChartInstance = null;
    let storedOhlcvData = []; // Store complete 180 days of data [ts, open0, high0, low0, close0, volume, tvl, trades, open1, high1, low1, close1]
    let currentBaseSymbol = "N/A";
    let isPancakeSwap = false; // Ê†áËÆ∞ÂΩìÂâçÊ±†ÊòØÂê¶‰∏∫PancakeSwap
    let currentQuoteSymbol = "N/A";

    async function fetchOhlcv(poolId, days, token = "base") {
      const limit = days ?? currentDays;
      const url = `${API_BASE}/networks/solana/pools/${poolId}/ohlcv/day?aggregate=1&limit=${limit}&currency=usd&token=${token}`;
      const resp = await fetch(url);
      if (!resp.ok) {
        throw new Error(`OHLCV HTTP error ${resp.status} (${resp.statusText})`);
      }
      const json = await resp.json();
      const list = json?.data?.attributes?.ohlcv_list || [];
      return list;
    }

    async function fetchBirdeyeOhlcv(poolId, days) {
      const apiKey = getBirdeyeApiKey();
      if (!apiKey) {
        throw new Error("Birdeye API Key is required. Please enter your API key in the input field above.");
      }

      const nowSec = Math.floor(Date.now() / 1000);
      const lookbackDays = days ?? currentDays;
      // Add 1 day buffer
      const fromSec = nowSec - (lookbackDays + 1) * 24 * 60 * 60;

      const url = `${BIRDEYE_BASE}/defi/ohlcv/pair?address=${poolId}&type=1D&time_from=${fromSec}&time_to=${nowSec}`;
      const headers = {
        "accept": "application/json",
        "x-chain": "solana",
        "X-API-KEY": apiKey
      };

      const resp = await fetch(url, { headers });
      if (!resp.ok) {
        throw new Error(`Birdeye OHLCV HTTP error ${resp.status} (${resp.statusText})`);
      }
      const json = await resp.json();

      // Display Birdeye raw response (if corresponding container exists)
      const birdeyeRawEl = document.getElementById("birdeyeRawJson");
      if (birdeyeRawEl) {
        birdeyeRawEl.textContent = JSON.stringify(json, null, 2);
      }

      const data = json && json.data ? json.data : null;

      const rawItems =
        (data && (data.items || data.ohlcv_list || data.ohlcv || data.candles)) ||
        (Array.isArray(data) ? data : []) ||
        [];

      const normalized = rawItems
        .map((item) => {
          if (Array.isArray(item)) {
            const ts = Number(item[0] ?? 0);
            const open = Number(item[1] ?? 0);
            const high = Number(item[2] ?? open);
            const low = Number(item[3] ?? open);
            const close = Number(item[4] ?? open);
            const volume = Number(item[5] ?? 0);
            // Try to read TVL from column 7/8 (if available)
            const tvlCandidate = Number(item[6] ?? item[7] ?? 0);
            const tvl = Number.isFinite(tvlCandidate) && tvlCandidate > 0 ? tvlCandidate : null;
            // Try to read trade count from subsequent columns (if available)
            const tradesCandidate = Number(item[8] ?? item[9] ?? 0);
            const trades =
              Number.isFinite(tradesCandidate) && tradesCandidate >= 0 ? tradesCandidate : 0;
            return [ts, open, high, low, close, volume, tvl, trades];
          } else if (item && typeof item === "object") {
            const ts = Number(item.unixTime ?? item.time ?? item.t ?? 0);
            const open = Number(item.open ?? item.o ?? 0);
            const high = Number(item.high ?? item.h ?? open);
            const low = Number(item.low ?? item.l ?? open);
            const close = Number(item.close ?? item.c ?? open);
            const volume = Number(item.volume ?? item.v ?? 0);
            // Try common TVL field names
            const tvlCandidate = Number(
              item.tvl ?? item.tvlUsd ?? item.tvl_usd ??
              item.liquidity ?? item.liquidityUsd ?? item.liquidity_usd ?? 0
            );
            const tvl = Number.isFinite(tvlCandidate) && tvlCandidate > 0 ? tvlCandidate : null;
            // Try common trade count field names
            const tradesCandidate = Number(
              item.n ?? item.txCount ?? item.trades ?? item.tradeCount ?? 0
            );
            const trades =
              Number.isFinite(tradesCandidate) && tradesCandidate >= 0 ? tradesCandidate : 0;
            return [ts, open, high, low, close, volume, tvl, trades];
          }
          return null;
        })
        .filter((row) => Array.isArray(row) && row[0]);

      // Pad one entry per day according to slider days (use placeholder for days without data)
      const daysCount = lookbackDays;
      const endDay = Math.floor(nowSec / 86400) * 86400; // Today 00:00
      const startDay = endDay - (daysCount - 1) * 86400;

      // First normalize keys by "day"
      const byDay = new Map();
      normalized.forEach((row) => {
        const ts = row[0];
        const dayTs = Math.floor(ts / 86400) * 86400;
        // Latest entry overwrites old (if multiple entries on same day)
        byDay.set(dayTs, row);
      });

      const padded = [];
      for (let t = startDay; t <= endDay; t += 86400) {
        if (byDay.has(t)) {
          padded.push(byDay.get(t));
        } else {
          // Days without data, use placeholder: price null, volume 0, TVL null, trade count 0
          padded.push([t, null, null, null, null, 0, null, 0]);
        }
      }

      return padded;
    }

    async function checkBirdeyeKey() {
      const statusEl = document.getElementById("birdeyeStatus");
      if (!statusEl) return;

      const key = getBirdeyeApiKey();
      if (!key) {
        statusEl.textContent = "Birdeye API Key is empty.";
        statusEl.style.color = "var(--danger)";
        return;
      }

      // Check if using default key (by checking if input field is empty)
      const keyInput = document.getElementById("birdeyeApiKey");
      const isUsingDefaultKey = !keyInput || !keyInput.value || !keyInput.value.trim();
      
      statusEl.textContent = isUsingDefaultKey 
        ? "Checking default Birdeye API Key..." 
        : "Checking Birdeye API Key...";
      statusEl.style.color = "var(--text-muted)";

      // Use current poolId (or default) to test if data can be fetched normally
      const poolInput = document.getElementById("poolId");
      const fallbackPoolId = "DJNtGuBGEQiUCWE8F981M2C3ZghZt2XLD8f2sQdZ6rsZ";
      const testPoolId =
        (poolInput && (poolInput.value || "").trim()) || fallbackPoolId;

      try {
        const list = await fetchBirdeyeOhlcv(testPoolId, 1);
        if (Array.isArray(list) && list.length > 0) {
          const keyInput = document.getElementById("birdeyeApiKey");
          const isUsingDefaultKey = !keyInput || !keyInput.value || !keyInput.value.trim();
          statusEl.textContent = isUsingDefaultKey 
            ? "Default Birdeye API Key is available." 
            : "Birdeye API Key is available.";
          statusEl.style.color = "var(--accent)";
        } else {
          statusEl.textContent =
            "Birdeye API Key request succeeded but returned no data, may be a permission or test pool issue.";
          statusEl.style.color = "var(--text-muted)";
        }
      } catch (e) {
        console.error("Birdeye key check failed", e);
        const msg = e && e.message ? e.message : String(e);
        const keyInput = document.getElementById("birdeyeApiKey");
        const isUsingDefaultKey = !keyInput || !keyInput.value || !keyInput.value.trim();
        statusEl.textContent = isUsingDefaultKey
          ? `Default Birdeye API Key is unavailable: ${msg}. Please use your own API Key.`
          : `Birdeye API Key is unavailable: ${msg}`;
        statusEl.style.color = "var(--danger)";
      }
    }

    function buildTvlVolumeChart(
      ctx,
      labels,
      tvlData,
      volData,
      hasTvl,
      _openData = [],      // No longer using open/close, only keeping high/low
      highData0 = [],
      lowData0 = [],
      _closeData = [],
      hasPrice0 = false,
      highData1 = [],
      lowData1 = [],
      hasPrice1 = false,
      hiddenStates = {}    // Save dataset hidden state
    ) {
      if (tvlVolumeChartInstance) {
        tvlVolumeChartInstance.destroy();
      }

      const datasets = [];

      if (hasTvl) {
        datasets.push({
          type: "line",
          label: "TVL (USD)",
          data: tvlData,
          borderColor: "#22c55e",
          backgroundColor: "rgba(34, 197, 94, 0.15)",
          borderWidth: 2,
          tension: 0.3,
          yAxisID: "y",
          pointRadius: 2.5,
          pointHoverRadius: 4
        });
      }

      if (hasPrice0) {
        datasets.push(
          {
            type: "line",
            label: `${currentBaseSymbol} High`,
            data: highData0,
            borderColor: "rgba(250, 204, 21, 0.9)",
            backgroundColor: "rgba(250, 204, 21, 0.12)",
            borderWidth: 1.5,
            tension: 0.25,
            yAxisID: "y",
            pointRadius: 0,
            pointHoverRadius: 2.5
          },
          {
            type: "line",
            label: `${currentBaseSymbol} Low`,
            data: lowData0,
            borderColor: "rgba(248, 113, 113, 0.9)",
            backgroundColor: "rgba(248, 113, 113, 0.12)",
            borderWidth: 1.5,
            tension: 0.25,
            yAxisID: "y",
            pointRadius: 0,
            pointHoverRadius: 2.5
          }
        );
      }

      if (hasPrice1) {
        datasets.push(
          {
            type: "line",
            label: `${currentQuoteSymbol} High`,
            data: highData1,
            borderColor: "rgba(59, 130, 246, 0.9)",  // blue
            backgroundColor: "rgba(59, 130, 246, 0.12)",
            borderWidth: 1.5,
            tension: 0.25,
            yAxisID: "y",
            pointRadius: 0,
            pointHoverRadius: 2.5
          },
          {
            type: "line",
            label: `${currentQuoteSymbol} Low`,
            data: lowData1,
            borderColor: "rgba(139, 92, 246, 0.9)",  // purple
            backgroundColor: "rgba(139, 92, 246, 0.12)",
            borderWidth: 1.5,
            tension: 0.25,
            yAxisID: "y",
            pointRadius: 0,
            pointHoverRadius: 2.5
          }
        );
      }

      datasets.push({
        type: "bar",
        label: "Volume (USD)",
        data: volData,
        backgroundColor: "rgba(148, 163, 184, 0.65)",
        borderColor: "rgba(148, 163, 184, 0.9)",
        borderWidth: 1,
        yAxisID: "y1",
        maxBarThickness: 18
      });

      tvlVolumeChartInstance = new Chart(ctx, {
        type: "bar",
        data: {
          labels,
          datasets
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              mode: "index",
              intersect: false,
              backgroundColor: "rgba(15, 23, 42, 0.95)",
              borderColor: "rgba(148, 163, 184, 0.5)",
              borderWidth: 1,
              padding: 10,
              titleFont: {
                size: 12
              },
              bodyFont: {
                size: 11
              },
              callbacks: {
                label: function (ctx) {
                  const label = ctx.dataset.label || "";
                  const value = ctx.parsed.y;
                  if (value == null) return "";
                  const formatted =
                    Math.abs(value) >= 1e9
                      ? (value / 1e9).toFixed(2) + "B"
                      : Math.abs(value) >= 1e6
                      ? (value / 1e6).toFixed(2) + "M"
                      : Math.abs(value) >= 1e3
                      ? (value / 1e3).toFixed(2) + "K"
                      : value.toFixed(2);
                  return `${label}: ${formatted} USD`;
                }
              }
            }
          },
          interaction: {
            mode: "index",
            intersect: false
          },
          scales: {
            x: {
              ticks: {
                color: "rgba(148, 163, 184, 0.9)",
                font: {
                  size: 11
                }
              },
              grid: {
                display: false
              }
            },
            y: {
              position: "left",
              ticks: {
                color: "rgba(34, 197, 94, 0.9)",
                font: {
                  size: 10
                },
                callback: function (value) {
                  if (Math.abs(value) >= 1e9) return (value / 1e9).toFixed(1) + "B";
                  if (Math.abs(value) >= 1e6) return (value / 1e6).toFixed(1) + "M";
                  if (Math.abs(value) >= 1e3) return (value / 1e3).toFixed(0) + "K";
                  return value;
                }
              },
              grid: {
                color: "rgba(30, 64, 175, 0.25)"
              }
            },
            y1: {
              position: "right",
              ticks: {
                color: "rgba(148, 163, 184, 0.9)",
                font: {
                  size: 10
                },
                callback: function (value) {
                  if (Math.abs(value) >= 1e9) return (value / 1e9).toFixed(1) + "B";
                  if (Math.abs(value) >= 1e6) return (value / 1e6).toFixed(1) + "M";
                  if (Math.abs(value) >= 1e3) return (value / 1e3).toFixed(0) + "K";
                  return value;
                }
              },
              grid: {
                display: false
              }
            }
          }
        }
      });

      // Restore dataset hidden state
      if (tvlVolumeChartInstance && tvlVolumeChartInstance.data && tvlVolumeChartInstance.data.datasets) {
        tvlVolumeChartInstance.data.datasets.forEach((dataset) => {
          if (dataset.label && hiddenStates.hasOwnProperty(dataset.label)) {
            dataset.hidden = hiddenStates[dataset.label];
          }
        });
        // Â¶ÇÊûúÊúâ‰ªª‰ΩïÊï∞ÊçÆÈõÜË¢´ÈöêËóèÔºåÊõ¥Êñ∞ÂõæË°®
        const hasHidden = tvlVolumeChartInstance.data.datasets.some(d => d.hidden);
        if (hasHidden) {
          tvlVolumeChartInstance.update('none'); // 'none' Ê®°ÂºèÈÅøÂÖçÂä®Áîª
        }
      }

      // Control whether TVL is displayed in legend
      const tvlLegendEl = document.getElementById("tvlLegend");
      if (tvlLegendEl) {
        tvlLegendEl.style.display = hasTvl ? "inline-flex" : "none";
        if (hasTvl) {
          // Find TVL dataset index
          const tvlDatasetIndex = datasets.findIndex(d => d.label === "TVL (USD)");
          if (tvlDatasetIndex !== -1) {
            tvlLegendEl.setAttribute("data-dataset-index", tvlDatasetIndex);
            tvlLegendEl.style.cursor = "pointer";
            tvlLegendEl.classList.remove("legend-hidden");
          }
        }
      }

      // Update token0 price legend
      const token0HighLegendEl = document.getElementById("token0HighLegend");
      const token0LowLegendEl = document.getElementById("token0LowLegend");
      const token0HighLabelEl = document.getElementById("token0HighLabel");
      const token0LowLabelEl = document.getElementById("token0LowLabel");
      if (token0HighLegendEl) {
        token0HighLegendEl.style.display = hasPrice0 ? "inline-flex" : "none";
        if (hasPrice0) {
          const highDatasetIndex = datasets.findIndex(d => d.label === `${currentBaseSymbol} High`);
          if (highDatasetIndex !== -1) {
            token0HighLegendEl.setAttribute("data-dataset-index", highDatasetIndex);
            token0HighLegendEl.style.cursor = "pointer";
            token0HighLegendEl.classList.remove("legend-hidden");
          }
        }
      }
      if (token0LowLegendEl) {
        token0LowLegendEl.style.display = hasPrice0 ? "inline-flex" : "none";
        if (hasPrice0) {
          const lowDatasetIndex = datasets.findIndex(d => d.label === `${currentBaseSymbol} Low`);
          if (lowDatasetIndex !== -1) {
            token0LowLegendEl.setAttribute("data-dataset-index", lowDatasetIndex);
            token0LowLegendEl.style.cursor = "pointer";
            token0LowLegendEl.classList.remove("legend-hidden");
          }
        }
      }
      if (token0HighLabelEl && hasPrice0) {
        token0HighLabelEl.textContent = `${currentBaseSymbol} High`;
      }
      if (token0LowLabelEl && hasPrice0) {
        token0LowLabelEl.textContent = `${currentBaseSymbol} Low`;
      }

      // Update token1 price legend
      const token1HighLegendEl = document.getElementById("token1HighLegend");
      const token1LowLegendEl = document.getElementById("token1LowLegend");
      const token1HighLabelEl = document.getElementById("token1HighLabel");
      const token1LowLabelEl = document.getElementById("token1LowLabel");
      if (token1HighLegendEl) {
        token1HighLegendEl.style.display = hasPrice1 ? "inline-flex" : "none";
        if (hasPrice1) {
          const highDatasetIndex = datasets.findIndex(d => d.label === `${currentQuoteSymbol} High`);
          if (highDatasetIndex !== -1) {
            token1HighLegendEl.setAttribute("data-dataset-index", highDatasetIndex);
            token1HighLegendEl.style.cursor = "pointer";
            token1HighLegendEl.classList.remove("legend-hidden");
          }
        }
      }
      if (token1LowLegendEl) {
        token1LowLegendEl.style.display = hasPrice1 ? "inline-flex" : "none";
        if (hasPrice1) {
          const lowDatasetIndex = datasets.findIndex(d => d.label === `${currentQuoteSymbol} Low`);
          if (lowDatasetIndex !== -1) {
            token1LowLegendEl.setAttribute("data-dataset-index", lowDatasetIndex);
            token1LowLegendEl.style.cursor = "pointer";
            token1LowLegendEl.classList.remove("legend-hidden");
          }
        }
      }
      if (token1HighLabelEl && hasPrice1) {
        token1HighLabelEl.textContent = `${currentQuoteSymbol} High`;
      }
      if (token1LowLabelEl && hasPrice1) {
        token1LowLabelEl.textContent = `${currentQuoteSymbol} Low`;
      }

      // Add click functionality to Volume legend
      const volumeLegendEl = document.getElementById("volumeLegend");
      if (volumeLegendEl) {
        const volumeDatasetIndex = datasets.findIndex(d => d.label === "Volume (USD)");
        if (volumeDatasetIndex !== -1) {
          volumeLegendEl.setAttribute("data-dataset-index", volumeDatasetIndex);
          volumeLegendEl.style.cursor = "pointer";
          volumeLegendEl.classList.remove("legend-hidden");
        }
      }

      // Restore legend visual style (based on dataset hidden state)
      if (tvlVolumeChartInstance && tvlVolumeChartInstance.data && tvlVolumeChartInstance.data.datasets) {
        tvlVolumeChartInstance.data.datasets.forEach((dataset, index) => {
          const legendItem = document.querySelector(`.chart-legend-item[data-dataset-index="${index}"]`);
          if (legendItem) {
            if (dataset.hidden) {
              legendItem.classList.add('legend-hidden');
            } else {
              legendItem.classList.remove('legend-hidden');
            }
          }
        });
      }

      // Setup legend click events
      setupLegendClickHandlers();
    }

    function setupLegendClickHandlers() {
      // Remove all old event listeners
      const legendItems = document.querySelectorAll('.chart-legend-item[data-dataset-index]');
      legendItems.forEach(item => {
        // Use cloneNode to remove old event listeners
        const newItem = item.cloneNode(true);
        if (item.parentNode) {
          item.parentNode.replaceChild(newItem, item);
        }
        
        // Add new click event listener
        newItem.addEventListener('click', function(e) {
          e.stopPropagation();
          const datasetIndex = parseInt(this.getAttribute('data-dataset-index'));
          if (tvlVolumeChartInstance && !isNaN(datasetIndex) && datasetIndex >= 0 && datasetIndex < tvlVolumeChartInstance.data.datasets.length) {
            const dataset = tvlVolumeChartInstance.data.datasets[datasetIndex];
            const isHidden = dataset.hidden || false;
            
            // Toggle hidden state
            dataset.hidden = !isHidden;
            tvlVolumeChartInstance.update();
            
            // Update legend visual style
            if (dataset.hidden) {
              this.classList.add('legend-hidden');
            } else {
              this.classList.remove('legend-hidden');
            }
          }
        });
      });
    }

    function updateChartFromStoredData(days) {
      if (!storedOhlcvData || storedOhlcvData.length === 0) {
        // If no stored data, clear chart
        const ctx = document.getElementById("tvlVolumeChart").getContext("2d");
        buildTvlVolumeChart(ctx, [], [], [], false, [], [], [], [], false, [], [], false, {});
        return;
      }

      // Get last N days of data from stored data
      const displayDays = days || currentDays;
      const startIndex = Math.max(0, storedOhlcvData.length - displayDays);
      const displayData = storedOhlcvData.slice(startIndex);

      const labels = [];
      const tvlData = [];
      const volData = [];
      const highData0 = [];  // token0 high
      const lowData0 = [];   // token0 low
      const highData1 = [];  // token1 high
      const lowData1 = [];   // token1 low
      let hasTvl = false;
      let hasPrice0 = false;
      let hasPrice1 = false;

      displayData.forEach(entry => {
        // Êï∞ÊçÆÊ†ºÂºè: [ts, open0, high0, low0, close0, volume, tvl, trades, open1, high1, low1, close1]
        const ts = entry[0];       // timestamp in seconds
        const _open0 = entry[1];  // token0 open
        const high0 = entry[2];   // token0 high
        const low0 = entry[3];    // token0 low
        const _close0 = entry[4]; // token0 close
        const volume = entry[5];   // volume in USD (with currency=usd)
        const tvl = entry[6];      // TVL (if available)
        const trades = entry[7];   // Daily trade count (if available)
        const _open1 = entry[8];  // token1 open
        const high1 = entry[9];   // token1 high
        const low1 = entry[10];   // token1 low
        const _close1 = entry[11]; // token1 close
        
        const date = new Date(ts * 1000);
        const label = date.toLocaleDateString("en-US", {
          month: "short",
          day: "numeric"
        });

        labels.push(label);

        // token0 high/low price
        if (high0 != null && !isNaN(Number(high0))) {
          highData0.push(Number(high0));
          hasPrice0 = true;
        } else {
          highData0.push(null);
        }

        if (low0 != null && !isNaN(Number(low0))) {
          lowData0.push(Number(low0));
          hasPrice0 = true;
        } else {
          lowData0.push(null);
        }

        // token1 high/low price
        if (high1 != null && !isNaN(Number(high1))) {
          highData1.push(Number(high1));
          hasPrice1 = true;
        } else {
          highData1.push(null);
        }

        if (low1 != null && !isNaN(Number(low1))) {
          lowData1.push(Number(low1));
          hasPrice1 = true;
        } else {
          lowData1.push(null);
        }

        // TVL
        if (tvl != null && !isNaN(Number(tvl)) && Number(tvl) > 0) {
          tvlData.push(Number(tvl));
          hasTvl = true;
        } else {
          tvlData.push(null);
        }

        volData.push(volume);
      });

      // Save current dataset hidden state (if chart exists)
      const hiddenStates = {};
      if (tvlVolumeChartInstance && tvlVolumeChartInstance.data && tvlVolumeChartInstance.data.datasets) {
        tvlVolumeChartInstance.data.datasets.forEach((dataset, index) => {
          if (dataset.label) {
            hiddenStates[dataset.label] = dataset.hidden || false;
          }
        });
      }

      const ctx = document.getElementById("tvlVolumeChart").getContext("2d");
      buildTvlVolumeChart(
        ctx,
        labels,
        tvlData,
        volData,
        hasTvl,
        [],        // openData no longer used
        highData0,
        lowData0,
        [],        // closeData no longer used
        hasPrice0,
        highData1,
        lowData1,
        hasPrice1,
        hiddenStates  // Pass hidden state
      );
    }

    async function loadPool(poolId, daysOverride) {
      const errorEl = document.getElementById("error");
      const loadingEl = document.getElementById("loading");
      const resultsEl = document.getElementById("results");
      const infoEl = document.getElementById("poolInfo");
      const rawEl = document.getElementById("rawJson");
      const birdeyeRawEl = document.getElementById("birdeyeRawJson");

      errorEl.textContent = "";
      loadingEl.textContent = t('loadingFromGeckoTerminal');
      resultsEl.style.display = "none";
      infoEl.innerHTML = "";
      rawEl.textContent = "";
      if (birdeyeRawEl) birdeyeRawEl.textContent = "";
      
      // ÈáçÁΩÆPancakeSwapÊ†áËÆ∞
      isPancakeSwap = false;
      // ÈöêËóèPancakeSwapÊâãÁª≠Ë¥πÊèêÁ§∫
      const pancakeswapFeeNote = document.getElementById("pancakeswapFeeNote");
      if (pancakeswapFeeNote) {
        pancakeswapFeeNote.style.display = "none";
      }

      try {
        if (!poolId || poolId.trim() === "") {
          throw new Error(t('pleaseInputPoolId'));
        }

        const cleanId = poolId.trim();

        // 1, current pool snapshot
        const url = `${API_BASE}/networks/solana/pools/${cleanId}`;
        const resp = await fetch(url);
        if (!resp.ok) {
          throw new Error(`HTTP error ${resp.status} (${resp.statusText})`);
        }
        const json = await resp.json();

        rawEl.textContent = JSON.stringify(json, null, 2);

        const data = json.data;
        if (!data || !data.attributes) {
          throw new Error("Unexpected API format, no data.attributes field.");
        }

        const attr = data.attributes;

        // Get token name, try multiple possible fields
        let baseSymbol = attr.base_token_symbol || 
                        attr.base_token?.symbol ||
                        attr.base?.symbol ||
                        attr.token0?.symbol ||
                        (data.relationships?.base_token?.data?.attributes?.symbol) ||
                        (data.relationships?.base_token?.data?.symbol) ||
                        "N/A";
        
        let quoteSymbol = attr.quote_token_symbol || 
                         attr.quote_token?.symbol ||
                         attr.quote?.symbol ||
                         attr.token1?.symbol ||
                         (data.relationships?.quote_token?.data?.attributes?.symbol) ||
                         (data.relationships?.quote_token?.data?.symbol) ||
                         "N/A";
        
        // If still N/A, try to find from included array (GeckoTerminal API usually includes this)
        if ((baseSymbol === "N/A" || quoteSymbol === "N/A") && json.included && Array.isArray(json.included)) {
          const tokens = json.included.filter(item => item.type === 'token' && item.attributes?.symbol);
          
          // Try to find corresponding token through relationships
          if (data.relationships) {
            const baseTokenId = data.relationships?.base_token?.data?.id || 
                               data.relationships?.base_token?.data?.data?.id;
            const quoteTokenId = data.relationships?.quote_token?.data?.id || 
                                data.relationships?.quote_token?.data?.data?.id;
            
            if (baseTokenId && baseSymbol === "N/A") {
              const baseToken = tokens.find(t => t.id === baseTokenId);
              if (baseToken?.attributes?.symbol) {
                baseSymbol = baseToken.attributes.symbol;
              }
            }
            
            if (quoteTokenId && quoteSymbol === "N/A") {
              const quoteToken = tokens.find(t => t.id === quoteTokenId);
              if (quoteToken?.attributes?.symbol) {
                quoteSymbol = quoteToken.attributes.symbol;
              }
            }
          }
          
          // Â¶ÇÊûúËøòÊòØÊâæ‰∏çÂà∞ÔºåÂ∞ùËØïÊåâÈ°∫Â∫èÂèñÂâç‰∏§‰∏™ token
          if (tokens.length >= 2) {
            if (baseSymbol === "N/A" && tokens[0]?.attributes?.symbol) {
              baseSymbol = tokens[0].attributes.symbol;
            }
            if (quoteSymbol === "N/A" && tokens[1]?.attributes?.symbol) {
              quoteSymbol = tokens[1].attributes.symbol;
            }
          } else if (tokens.length === 1 && baseSymbol === "N/A") {
            baseSymbol = tokens[0].attributes.symbol;
          }
        }
        
        // ÊúÄÂêéÁöÑÂ§áÁî®ÊñπÊ°àÔºöÂ∞ùËØï‰ªé name Â≠óÊÆµËß£ÊûêÔºàÂ¶ÇÊûúÊúâÊ†ºÂºèÂ¶Ç "SOL/USDC"Ôºâ
        if ((baseSymbol === "N/A" || quoteSymbol === "N/A") && attr.name) {
          const nameParts = attr.name.split('/');
          if (nameParts.length >= 2) {
            if (baseSymbol === "N/A") baseSymbol = nameParts[0].trim();
            if (quoteSymbol === "N/A") quoteSymbol = nameParts[1].trim();
          }
        }
        
        // Ë∞ÉËØïÔºöÂ¶ÇÊûúËøòÊòØ N/AÔºåËæìÂá∫Ë≠¶Âëä
        if (baseSymbol === "N/A" || quoteSymbol === "N/A") {
          console.warn("Could not find token symbols. Available attributes:", Object.keys(attr));
          console.warn("Relationships:", data.relationships);
          console.warn("Included items:", json.included?.map(i => ({ type: i.type, id: i.id, symbol: i.attributes?.symbol })));
        }
        
        // Ëé∑Âèñ token0 (base token) ÁöÑ USD ‰ª∑Ê†º
        let token0PriceUsd = attr.base_token_price_usd || 
                            attr.base_token?.price_usd ||
                            attr.token0?.price_usd ||
                            attr.price_in_usd ||
                            null;
        
        // Ëé∑Âèñ token1 (quote token) ÁöÑ USD ‰ª∑Ê†º
        let token1PriceUsd = attr.quote_token_price_usd || 
                            attr.quote_token?.price_usd ||
                            attr.token1?.price_usd ||
                            null;
        
        // Ëé∑Âèñ market_cap_usdÔºàÈÄöÂ∏∏Êù•Ëá™ base tokenÔºâ
        let marketCapUsd = attr.base_token_market_cap_usd || 
                          attr.base_token?.market_cap_usd ||
                          attr.market_cap_usd ||
                          null;
        
        // Â¶ÇÊûúËøòÊòØÊâæ‰∏çÂà∞ÔºåÂ∞ùËØï‰ªé included Êï∞ÁªÑ‰∏≠Êü•Êâæ
        if ((!token0PriceUsd || !token1PriceUsd || !marketCapUsd) && json.included && Array.isArray(json.included)) {
          const tokens = json.included.filter(item => item.type === 'token' && item.attributes);
          
          if (data.relationships) {
            const baseTokenId = data.relationships?.base_token?.data?.id || 
                               data.relationships?.base_token?.data?.data?.id;
            const quoteTokenId = data.relationships?.quote_token?.data?.id || 
                                data.relationships?.quote_token?.data?.data?.id;
            
            if (baseTokenId) {
              const baseToken = tokens.find(t => t.id === baseTokenId);
              if (baseToken?.attributes) {
                if (!token0PriceUsd && baseToken.attributes.price_usd) {
                  token0PriceUsd = baseToken.attributes.price_usd;
                }
                if (!marketCapUsd && baseToken.attributes.market_cap_usd) {
                  marketCapUsd = baseToken.attributes.market_cap_usd;
                }
              }
            }
            
            if (quoteTokenId && !token1PriceUsd) {
              const quoteToken = tokens.find(t => t.id === quoteTokenId);
              if (quoteToken?.attributes?.price_usd) {
                token1PriceUsd = quoteToken.attributes.price_usd;
              }
            }
          }
          
          // Â¶ÇÊûúËøòÊòØÊâæ‰∏çÂà∞ÔºåÂ∞ùËØïÊåâÈ°∫Â∫èÂèñÂâç‰∏§‰∏™ token
          if (tokens.length >= 2) {
            if (!token0PriceUsd && tokens[0]?.attributes?.price_usd) {
              token0PriceUsd = tokens[0].attributes.price_usd;
            }
            if (!token1PriceUsd && tokens[1]?.attributes?.price_usd) {
              token1PriceUsd = tokens[1].attributes.price_usd;
            }
            if (!marketCapUsd && tokens[0]?.attributes?.market_cap_usd) {
              marketCapUsd = tokens[0].attributes.market_cap_usd;
            }
          } else if (tokens.length === 1 && !marketCapUsd && tokens[0]?.attributes?.market_cap_usd) {
            marketCapUsd = tokens[0].attributes.market_cap_usd;
          }
        }
        
        // Ê†ºÂºèÂåñ token0 ‰ª∑Ê†º‰∏∫12‰ΩçÊúâÊïàÊï∞Â≠ó
        let token0PriceDisplay = "N/A";
        if (token0PriceUsd !== undefined && token0PriceUsd !== null && token0PriceUsd !== "N/A") {
          const priceNum = typeof token0PriceUsd === "number" ? token0PriceUsd : Number(token0PriceUsd);
          if (Number.isFinite(priceNum) && priceNum > 0) {
            token0PriceDisplay = toSignificantDigits(priceNum, 12);
          } else {
            token0PriceDisplay = String(token0PriceUsd);
          }
        }
        
        // Ê†ºÂºèÂåñ token1 ‰ª∑Ê†º‰∏∫12‰ΩçÊúâÊïàÊï∞Â≠ó
        let token1PriceDisplay = "N/A";
        if (token1PriceUsd !== undefined && token1PriceUsd !== null && token1PriceUsd !== "N/A") {
          const priceNum = typeof token1PriceUsd === "number" ? token1PriceUsd : Number(token1PriceUsd);
          if (Number.isFinite(priceNum) && priceNum > 0) {
            token1PriceDisplay = toSignificantDigits(priceNum, 12);
          } else {
            token1PriceDisplay = String(token1PriceUsd);
          }
        }
        
        // Ê†ºÂºèÂåñ market_cap_usd
        let marketCapUsdDisplay = "N/A";
        if (marketCapUsd !== undefined && marketCapUsd !== null && marketCapUsd !== "N/A") {
          const marketCapNum = typeof marketCapUsd === "number" ? marketCapUsd : Number(marketCapUsd);
          if (Number.isFinite(marketCapNum) && marketCapNum > 0) {
            // Ê†ºÂºèÂåñÂ∏ÇÂÄºÔºå‰ΩøÁî® B/M/K Âçï‰Ωç
            if (Math.abs(marketCapNum) >= 1e9) {
              marketCapUsdDisplay = (marketCapNum / 1e9).toFixed(2) + "B";
            } else if (Math.abs(marketCapNum) >= 1e6) {
              marketCapUsdDisplay = (marketCapNum / 1e6).toFixed(2) + "M";
            } else if (Math.abs(marketCapNum) >= 1e3) {
              marketCapUsdDisplay = (marketCapNum / 1e3).toFixed(2) + "K";
            } else {
              marketCapUsdDisplay = marketCapNum.toFixed(2);
            }
          } else {
            marketCapUsdDisplay = String(marketCapUsd);
          }
        }
        
        // ËÆ°ÁÆó token1/token0 ‰ª∑Ê†ºÊØîÁéáÔºàÈÄöËøáÂÇ®Â§áÈáèÊàñ USD ‰ª∑Ê†ºÔºâ
        let token1PerToken0 = null;
        let token0PerToken1 = null;
        
        // ÊñπÊ≥ï1: ‰ªéÂÇ®Â§áÈáèËÆ°ÁÆó
        let baseReserve = attr.base_token_reserve || attr.reserve_base || 
                         (attr.base_token && attr.base_token.reserve);
        let quoteReserve = attr.quote_token_reserve || attr.reserve_quote || 
                          (attr.quote_token && attr.quote_token.reserve);
        
        // Â¶ÇÊûúÁõ¥Êé•‰ªé attributes Ëé∑Âèñ‰∏çÂà∞ÔºåÂ∞ùËØï‰ªé included Êï∞ÁªÑ‰∏≠Êü•Êâæ
        if ((!baseReserve || !quoteReserve) && json.included && Array.isArray(json.included)) {
          const tokens = json.included.filter(item => item.type === 'token' && item.attributes);
          
          if (data.relationships) {
            const baseTokenId = data.relationships?.base_token?.data?.id || 
                               data.relationships?.base_token?.data?.data?.id;
            const quoteTokenId = data.relationships?.quote_token?.data?.id || 
                                data.relationships?.quote_token?.data?.data?.id;
            
            if (baseTokenId && !baseReserve) {
              const baseToken = tokens.find(t => t.id === baseTokenId);
              if (baseToken?.attributes) {
                baseReserve = baseToken.attributes.reserve || 
                             baseToken.attributes.base_token_reserve ||
                             baseToken.attributes.amount;
              }
            }
            
            if (quoteTokenId && !quoteReserve) {
              const quoteToken = tokens.find(t => t.id === quoteTokenId);
              if (quoteToken?.attributes) {
                quoteReserve = quoteToken.attributes.reserve || 
                              quoteToken.attributes.quote_token_reserve ||
                              quoteToken.attributes.amount;
              }
            }
          }
        }
        
        let baseAmount = null;
        let quoteAmount = null;
        
        if (baseReserve && quoteReserve && Number(baseReserve) > 0) {
          const baseDecimals = attr.base_token_decimals || 
                              (attr.base_token && attr.base_token.decimals) || 9;
          const quoteDecimals = attr.quote_token_decimals || 
                               (attr.quote_token && attr.quote_token.decimals) || 6;
          
          baseAmount = Number(baseReserve) / Math.pow(10, baseDecimals);
          quoteAmount = Number(quoteReserve) / Math.pow(10, quoteDecimals);
          
          if (baseAmount > 0) {
            // token1/token0 = quoteAmount / baseAmount
            token1PerToken0 = quoteAmount / baseAmount;
            // token0/token1 = baseAmount / quoteAmount
            token0PerToken1 = baseAmount / quoteAmount;
          }
        }
        
        // ÊñπÊ≥ï2: Â¶ÇÊûúÂÇ®Â§áÈáèËÆ°ÁÆóÂ§±Ë¥•Ôºå‰ΩøÁî® USD ‰ª∑Ê†ºËÆ°ÁÆó
        if ((!token1PerToken0 || !Number.isFinite(token1PerToken0)) && 
            token0PriceUsd && token1PriceUsd && 
            Number.isFinite(Number(token0PriceUsd)) && Number.isFinite(Number(token1PriceUsd)) &&
            Number(token0PriceUsd) > 0) {
          const token0Usd = Number(token0PriceUsd);
          const token1Usd = Number(token1PriceUsd);
          // token1/token0 = (token1_usd / token0_usd)
          token1PerToken0 = token1Usd / token0Usd;
          token0PerToken1 = token0Usd / token1Usd;
        }
        
        // Ê†ºÂºèÂåñ‰ª∑Ê†ºÊØîÁéá
        let token1PerToken0Display = "N/A";
        let token0PerToken1Display = "N/A";
        
        if (token1PerToken0 && Number.isFinite(token1PerToken0) && token1PerToken0 > 0) {
          token1PerToken0Display = toSignificantDigits(token1PerToken0, 12);
        }
        
        if (token0PerToken1 && Number.isFinite(token0PerToken1) && token0PerToken1 > 0) {
          token0PerToken1Display = toSignificantDigits(token0PerToken1, 12);
        }
        
        // Ëé∑Âèñ TVL Áî®‰∫é‰º∞ÁÆóÔºàÂ¶ÇÊûúÂÇ®Â§áÈáè‰∏çÂèØÁî®Ôºâ
        const liquidityUsd = attr.reserve_in_usd || attr.liquidity_in_usd || null;
        
        // Â¶ÇÊûú GeckoTerminal API Ê≤°ÊúâÊèê‰æõÂÇ®Â§áÈáèÊï∞ÊçÆÔºå‰ΩøÁî® TVL Âíå‰ª∑Ê†ºÊù•‰º∞ÁÆó
        // ÂØπ‰∫é AMM Ê±†ÔºåÂú®Âπ≥Ë°°Áä∂ÊÄÅ‰∏ãÔºötoken0_value ‚âà token1_value ‚âà TVL / 2
        if ((!baseAmount || !quoteAmount) && liquidityUsd && liquidityUsd !== "N/A" && 
            token0PriceUsd && token1PriceUsd &&
            Number.isFinite(Number(liquidityUsd)) && Number(liquidityUsd) > 0 &&
            Number.isFinite(Number(token0PriceUsd)) && Number(token0PriceUsd) > 0 &&
            Number.isFinite(Number(token1PriceUsd)) && Number(token1PriceUsd) > 0) {
          
          const tvl = Number(liquidityUsd);
          const token0Price = Number(token0PriceUsd);
          const token1Price = Number(token1PriceUsd);
          
          // ‰ΩøÁî®‰ª∑Ê†ºÊØîÁéáÊù•Êõ¥ÂáÜÁ°ÆÂú∞ËÆ°ÁÆó
          // TVL = token0_amount * token0_price + token1_amount * token1_price
          // Âú®Âπ≥Ë°°Áä∂ÊÄÅ‰∏ãÔºötoken0_amount * token0_price = token1_amount * token1_price
          // ÊâÄ‰ª•Ôºötoken0_amount * token0_price = TVL / 2
          
          if (!baseAmount) {
            baseAmount = (tvl / 2) / token0Price;
          }
          
          if (!quoteAmount) {
            quoteAmount = (tvl / 2) / token1Price;
          }
          
          console.log("Estimated token amounts from TVL:", {
            tvl: tvl,
            token0Price: token0Price,
            token1Price: token1Price,
            estimatedBaseAmount: baseAmount,
            estimatedQuoteAmount: quoteAmount
          });
        }
        
        // Ê†ºÂºèÂåñ token0 Âíå token1 Êï∞ÈáèÁî®‰∫éÊòæÁ§∫
        let token0AmountDisplay = "N/A";
        let token1AmountDisplay = "N/A";
        
        if (baseAmount != null && Number.isFinite(baseAmount) && baseAmount > 0) {
          token0AmountDisplay = toSignificantDigits(baseAmount, 12);
        }
        
        if (quoteAmount != null && Number.isFinite(quoteAmount) && quoteAmount > 0) {
          token1AmountDisplay = toSignificantDigits(quoteAmount, 12);
        }
        
        // Ë∞ÉËØïÔºöÂ¶ÇÊûúÊï∞ÈáèÊòØ N/AÔºåËæìÂá∫ÂèØÁî®ÁöÑÂ±ûÊÄß‰ª•‰æøË∞ÉËØï
        if (token0AmountDisplay === "N/A" || token1AmountDisplay === "N/A") {
          console.log("Token amounts not available. Available fields:", {
            baseReserve: baseReserve,
            quoteReserve: quoteReserve,
            base_token_reserve: attr.base_token_reserve,
            quote_token_reserve: attr.quote_token_reserve,
            reserve_base: attr.reserve_base,
            reserve_quote: attr.reserve_quote,
            reserve_in_usd: attr.reserve_in_usd,
            liquidityUsd: liquidityUsd,
            token0PriceUsd: token0PriceUsd,
            token1PriceUsd: token1PriceUsd
          });
        }
        
        // ËÆ°ÁÆóTVL: token0Êï∞Èáè * token0‰ª∑Ê†º + token1Êï∞Èáè * token1‰ª∑Ê†º
        let calculatedTvl = null;
        let calculatedTvlDisplay = "N/A";
        
        if (baseAmount != null && quoteAmount != null && 
            token0PriceUsd && token1PriceUsd &&
            Number.isFinite(Number(token0PriceUsd)) && Number.isFinite(Number(token1PriceUsd)) &&
            Number.isFinite(baseAmount) && Number.isFinite(quoteAmount)) {
          const token0Value = baseAmount * Number(token0PriceUsd);
          const token1Value = quoteAmount * Number(token1PriceUsd);
          calculatedTvl = token0Value + token1Value;
          
          if (calculatedTvl > 0 && Number.isFinite(calculatedTvl)) {
            if (calculatedTvl >= 1000000) {
              calculatedTvlDisplay = `$${(calculatedTvl / 1000000).toFixed(2)}M`;
            } else if (calculatedTvl >= 1000) {
              calculatedTvlDisplay = `$${(calculatedTvl / 1000).toFixed(2)}K`;
            } else {
              calculatedTvlDisplay = `$${calculatedTvl.toFixed(2)}`;
            }
          }
        }
        
        // ÊèêÂèñDEX‰ø°ÊÅØÔºåÊåâ‰ºòÂÖàÁ∫ßÂ∞ùËØïÂ§ö‰∏™ÂèØËÉΩÁöÑË∑ØÂæÑ
        let dexName = "N/A";
        
        // ÊñπÊ≥ï1: ‰ªé json.dex.data.id Ëé∑ÂèñÔºàÁõ¥Êé•Ë∑ØÂæÑÔºâ
        if (json.dex?.data?.id) {
          dexName = json.dex.data.id;
        }
        // ÊñπÊ≥ï2: ‰ªé relationships.dex Ëé∑Âèñ
        else if (data.relationships?.dex?.data?.id) {
          dexName = data.relationships.dex.data.id;
        }
        // ÊñπÊ≥ï3: ‰ªé included Êï∞ÁªÑ‰∏≠Êü•Êâæ type ‰∏∫ 'dex' ÁöÑÈ°π
        else if (json.included && Array.isArray(json.included)) {
          const dexItem = json.included.find(item => item.type === 'dex');
          if (dexItem?.id) {
            dexName = dexItem.id;
          } else if (dexItem?.attributes?.name) {
            dexName = dexItem.attributes.name;
          }
        }
        // ÊñπÊ≥ï4: ‰ªé attributes.dex_name Ëé∑Âèñ
        else if (attr.dex_name) {
          dexName = attr.dex_name;
        }
        // ÊñπÊ≥ï5: ‰ªé attributes.dex Ëé∑Âèñ
        else if (attr.dex) {
          dexName = typeof attr.dex === 'string' ? attr.dex : (attr.dex.name || attr.dex.id || "N/A");
        }
        
        // Ê†ºÂºèÂåñDEXÂêçÁß∞ÔºàÂ∞ÜËøûÂ≠óÁ¨¶ËΩ¨Êç¢‰∏∫Á©∫Ê†ºÂπ∂È¶ñÂ≠óÊØçÂ§ßÂÜôÔºâ
        if (dexName !== "N/A" && dexName) {
          dexName = dexName
            .split('-')
            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
            .join(' ');
        }
        
        // ÊòæÁ§∫ÊúÄËøë‰∏ÄÊ¨°ÊãâÂèñÊó∂Èó¥ÁöÑÊó∂Èó¥Êà≥
        const lastUpdated = new Date().toISOString();

        // Ê£ÄÊü•DEXÂêçÁß∞ÊòØÂê¶ÂåÖÂê´pancakeswapÔºà‰∏çÂå∫ÂàÜÂ§ßÂ∞èÂÜôÔºâ
        isPancakeSwap = dexName && dexName.toLowerCase().includes('pancakeswap');
        const dexStatClass = isPancakeSwap ? 'stat clickable-stat dex-clickable' : 'stat';
        const dexStatAttrs = isPancakeSwap ? `id="dexClickableStat" data-pool-id="${cleanId}"` : '';
        
        infoEl.innerHTML = `
          <div class="stat-grid">
            <div class="${dexStatClass}" ${dexStatAttrs}>
              <div class="stat-label">${t('dex')}</div>
              <div class="stat-value">${dexName}</div>
            </div>
            <div class="stat">
              <div class="stat-label">${t('pair')}</div>
              <div class="stat-value">${baseSymbol} / ${quoteSymbol}</div>
            </div>
            <div class="stat">
              <div class="stat-label">${t('poolIdLpId')}</div>
              <div class="stat-value">${cleanId}</div>
            </div>
            <div class="stat">
              <div class="stat-label">${t('priceUsd', { symbol: baseSymbol })}</div>
              <div class="stat-value">
                ${token0PriceDisplay} USD
              </div>
            </div>
            <div class="stat">
              <div class="stat-label">${t('priceUsd', { symbol: quoteSymbol })}</div>
              <div class="stat-value">
                ${token1PriceDisplay} USD
              </div>
            </div>
            <div class="stat">
              <div class="stat-label">${t('token0Amount', { symbol: baseSymbol })}</div>
              <div class="stat-value">${token0AmountDisplay}</div>
            </div>
            <div class="stat">
              <div class="stat-label">${t('token1Amount', { symbol: quoteSymbol })}</div>
              <div class="stat-value">${token1AmountDisplay}</div>
            </div>
            <div class="stat clickable-stat" id="priceRatioStat" 
                 data-ratio-type="token1-token0"
                 data-base-symbol="${baseSymbol}"
                 data-quote-symbol="${quoteSymbol}"
                 data-token1-per-token0="${token1PerToken0Display}"
                 data-token0-per-token1="${token0PerToken1Display}">
              <div class="stat-label">
                <span id="priceRatioLabel">${quoteSymbol} / ${baseSymbol}</span>
                <span class="swap-icon" id="swapIcon">‚áÑ</span>
              </div>
              <div class="stat-value" id="priceRatioValue">
                1 ${quoteSymbol} = ${token1PerToken0Display} ${baseSymbol}
              </div>
            </div>
            <div class="stat">
              <div class="stat-label">${t('volume7d')}</div>
              <div class="stat-value" id="volume7dValue">${t('calculating')}</div>
            </div>
            <div class="stat">
              <div class="stat-label">${baseSymbol !== "N/A" ? `${baseSymbol} ${t('marketCap')}` : t('marketCap')}</div>
              <div class="stat-value" id="marketCapUsdValue">${marketCapUsdDisplay}</div>
            </div>
            <div class="stat">
              <div class="stat-label">${t('correlationCoefficient')}</div>
              <div class="stat-value" id="correlationValue">${t('calculating')}</div>
            </div>
            <div class="stat">
              <div class="stat-label">${t('lastUpdated')}</div>
              <div class="stat-value">${lastUpdated}</div>
            </div>
          </div>
        `;

        // ‰ΩøÁî®‰º†ÂÖ•ÁöÑÂ§©Êï∞ÔºàÂ¶ÇÊûúÊúâÔºâÔºåÂê¶ÂàôÁî®ÂΩìÂâçÂÖ®Â±ÄÁöÑÂ§©Êï∞
        const days = daysOverride ?? currentDays;
        currentDays = days;

        // Êõ¥Êñ∞Ê†áÈ¢òÈáåÁöÑÂ§©Êï∞ÂíåÊªëÊùÜÁöÑ‰ΩçÁΩÆ
        const daysLabelEl = document.getElementById("daysLabel");
        const daysRangeEl = document.getElementById("daysRange");
        if (daysLabelEl) daysLabelEl.textContent = days;
        if (daysRangeEl && String(daysRangeEl.value) !== String(days)) {
          daysRangeEl.value = days;
        }

        // ‰øùÂ≠ò token Á¨¶Âè∑‰æõÂõæ‰æã‰ΩøÁî®
        currentBaseSymbol = baseSymbol;
        currentQuoteSymbol = quoteSymbol;

        // 2, fetch ohlcv - ÊÄªÊòØËé∑Âèñ180Â§©ÁöÑÊï∞ÊçÆÂπ∂Â≠òÂÇ®
        loadingEl.textContent = t('loadingOhlcvData');
        let ohlcvList0 = [];
        let ohlcvList1 = [];
        
        // Â∞ùËØï‰ªé Birdeye Ëé∑ÂèñÔºàÂ¶ÇÊûúÂèØÁî®Ôºâ
        try {
          const birdeyeData = await fetchBirdeyeOhlcv(cleanId, 180);
          // Birdeye ËøîÂõûÁöÑÊòØ base token ÁöÑ‰ª∑Ê†ºÔºåÊàë‰ª¨ÈúÄË¶ÅÂêåÊó∂Ëé∑Âèñ quote token
          ohlcvList0 = birdeyeData;
          // Â∞ùËØï‰ªé GeckoTerminal Ëé∑Âèñ quote token ÁöÑ‰ª∑Ê†º
          try {
            ohlcvList1 = await fetchOhlcv(cleanId, 180, "quote");
          } catch (e1) {
            console.warn("Failed to load quote token OHLCV from GeckoTerminal", e1);
          }
        } catch (e) {
          console.error("Failed to load OHLCV from Birdeye, falling back to GeckoTerminal", e);
          try {
            // ‰ªé GeckoTerminal ÂêåÊó∂Ëé∑Âèñ base Âíå quote token ÁöÑÊï∞ÊçÆ
            const [baseData, quoteData] = await Promise.all([
              fetchOhlcv(cleanId, 180, "base"),
              fetchOhlcv(cleanId, 180, "quote")
            ]);
            ohlcvList0 = baseData;
            ohlcvList1 = quoteData;
          } catch (inner) {
            console.error("Failed to load OHLCV from GeckoTerminal as well", inner);
          }
        }

        // ÂêàÂπ∂ token0 Âíå token1 ÁöÑÊï∞ÊçÆ
        // Êï∞ÊçÆÊ†ºÂºè: [ts, open0, high0, low0, close0, volume, tvl, trades, open1, high1, low1, close1]
        const mergedData = [];
        const dataMap0 = new Map();
        const dataMap1 = new Map();
        
        // Âª∫Á´ã token0 Êï∞ÊçÆÁöÑÊó∂Èó¥Êà≥Êò†Â∞Ñ
        ohlcvList0.forEach(item => {
          if (Array.isArray(item) && item.length >= 5) {
            const ts = item[0];
            const dayTs = Math.floor(ts / 86400) * 86400;
            dataMap0.set(dayTs, item);
          }
        });
        
        // Âª∫Á´ã token1 Êï∞ÊçÆÁöÑÊó∂Èó¥Êà≥Êò†Â∞Ñ
        ohlcvList1.forEach(item => {
          if (Array.isArray(item) && item.length >= 5) {
            const ts = item[0];
            const dayTs = Math.floor(ts / 86400) * 86400;
            dataMap1.set(dayTs, item);
          }
        });
        
        // ÂêàÂπ∂ÊâÄÊúâÊó∂Èó¥Êà≥
        const allTimestamps = new Set([...dataMap0.keys(), ...dataMap1.keys()]);
        const sortedTimestamps = Array.from(allTimestamps).sort((a, b) => a - b);
        
        sortedTimestamps.forEach(dayTs => {
          const item0 = dataMap0.get(dayTs);
          const item1 = dataMap1.get(dayTs);
          
          // token0 Êï∞ÊçÆ: [ts, open, high, low, close, volume, tvl?, trades?]
          const ts = item0 ? item0[0] : (item1 ? item1[0] : dayTs);
          const open0 = item0 ? (item0[1] ?? null) : null;
          const high0 = item0 ? (item0[2] ?? null) : null;
          const low0 = item0 ? (item0[3] ?? null) : null;
          const close0 = item0 ? (item0[4] ?? null) : null;
          const volume = item0 ? (item0[5] ?? 0) : (item1 ? (item1[5] ?? 0) : 0);
          const tvl = item0 ? (item0[6] ?? null) : null;
          const trades = item0 ? (item0[7] ?? 0) : 0;
          
          // token1 Êï∞ÊçÆ
          const open1 = item1 ? (item1[1] ?? null) : null;
          const high1 = item1 ? (item1[2] ?? null) : null;
          const low1 = item1 ? (item1[3] ?? null) : null;
          const close1 = item1 ? (item1[4] ?? null) : null;
          
          mergedData.push([ts, open0, high0, low0, close0, volume, tvl, trades, open1, high1, low1, close1]);
        });

        // Â≠òÂÇ®ÂÆåÊï¥ÁöÑ180Â§©Êï∞ÊçÆ
        storedOhlcvData = mergedData.length > 0 
          ? [...mergedData].sort((a, b) => a[0] - b[0]) 
          : [];

        // Êõ¥Êñ∞ Current price (P‚ÇÄ) ÂíåÁõ∏ÂÖ≥‰ª∑Ê†ºËåÉÂõ¥
        const ilP0El = document.getElementById("ilP0");
        const ilLowerEl = document.getElementById("ilLower");
        const ilUpperEl = document.getElementById("ilUpper");
        
        let currentPrice = 1; // ÈªòËÆ§ÂÄº‰∏∫ 1
        
        // Â¶ÇÊûúÊúâÊï∞ÊçÆÔºåÂ∞ùËØï‰ªé token0 ÁöÑÊúÄÊñ∞‰ª∑Ê†ºËé∑Âèñ
        if (storedOhlcvData.length > 0) {
          const lastEntry = storedOhlcvData[storedOhlcvData.length - 1];
          const token0LatestPrice = lastEntry[4]; // close0 Âú®Á¥¢Âºï4
          if (token0LatestPrice !== null && token0LatestPrice !== undefined && !isNaN(Number(token0LatestPrice)) && Number(token0LatestPrice) > 0) {
            currentPrice = Number(token0LatestPrice);
          }
        }
        
        // Êõ¥Êñ∞ Current price (P‚ÇÄ)
        if (ilP0El) {
          ilP0El.value = currentPrice;
        }
        
        // Ê†πÊçÆ Current price ËÆ°ÁÆóÂπ∂Êõ¥Êñ∞ Price lower bound Âíå Price upper bound
        if (ilLowerEl) {
          ilLowerEl.value = (currentPrice * 0.8).toFixed(4);
        }
        if (ilUpperEl) {
          ilUpperEl.value = (currentPrice * 1.2).toFixed(4);
        }

        // ËÆ°ÁÆó7Êó•Êó•ÂùáÊàê‰∫§Èáè
        let volume7d = "N/A";
        let volume7dRaw = null; // ‰øùÂ≠òÂéüÂßãÊï∞ÂÄºÁî®‰∫é APR ËÆ°ÁÆó
        let volume7dStdDev = "N/A"; // 7Êó•‰∫§ÊòìÈáèÊ†áÂáÜÂ∑Æ
        let volume7dStdDevRaw = null; // ‰øùÂ≠òÊ†áÂáÜÂ∑ÆÂéüÂßãÊï∞ÂÄºÁî®‰∫éÈ£éÈô©ÊåáÊ†áËÆ°ÁÆó
        if (storedOhlcvData.length > 0) {
          // ÂèñÊúÄÂêé7Â§©ÁöÑÊï∞ÊçÆ
          const last7Days = storedOhlcvData.slice(-7);
          // ÊèêÂèñÊØèÊó•Êàê‰∫§ÈáèÔºàvolumeÂú®Á¥¢Âºï5Ôºâ
          const dailyVolumes = last7Days.map(entry => {
            const vol = entry[5] || 0; // volumeÂú®Á¥¢Âºï5
            return Number.isFinite(vol) ? Number(vol) : 0;
          });
          
          // ËÆ°ÁÆóÊÄªÊàê‰∫§Èáè
          const totalVolume = dailyVolumes.reduce((sum, vol) => sum + vol, 0);
          
          // ËÆ°ÁÆó7Êó•Êó•ÂùáÔºàÊÄªÊàê‰∫§ÈáèÈô§‰ª•7Ôºâ
          const dailyAverage = totalVolume / 7;
          volume7dRaw = dailyAverage; // ‰øùÂ≠òÂéüÂßãÊï∞ÂÄº
          
          if (dailyAverage > 0) {
            // Ê†ºÂºèÂåñÊòæÁ§∫
            if (Math.abs(dailyAverage) >= 1e9) {
              volume7d = (dailyAverage / 1e9).toFixed(2) + "B";
            } else if (Math.abs(dailyAverage) >= 1e6) {
              volume7d = (dailyAverage / 1e6).toFixed(2) + "M";
            } else if (Math.abs(dailyAverage) >= 1e3) {
              volume7d = (dailyAverage / 1e3).toFixed(2) + "K";
            } else {
              volume7d = dailyAverage.toFixed(2);
            }
            
            // ËÆ°ÁÆóÊ†áÂáÜÂ∑Æ
            const variance = dailyVolumes.reduce((sum, vol) => {
              const diff = vol - dailyAverage;
              return sum + (diff * diff);
            }, 0) / 7;
            const stdDev = Math.sqrt(variance);
            
            // ‰øùÂ≠òÂéüÂßãÊ†áÂáÜÂ∑ÆÂÄºÔºàÁî®‰∫éÈ£éÈô©ÊåáÊ†áËÆ°ÁÆóÔºâ
            volume7dStdDevRaw = stdDev;
            
            // Ê†ºÂºèÂåñÊ†áÂáÜÂ∑ÆÊòæÁ§∫
            if (stdDev > 0) {
              if (Math.abs(stdDev) >= 1e9) {
                volume7dStdDev = (stdDev / 1e9).toFixed(2) + "B";
              } else if (Math.abs(stdDev) >= 1e6) {
                volume7dStdDev = (stdDev / 1e6).toFixed(2) + "M";
              } else if (Math.abs(stdDev) >= 1e3) {
                volume7dStdDev = (stdDev / 1e3).toFixed(2) + "K";
              } else {
                volume7dStdDev = stdDev.toFixed(2);
              }
            } else {
              volume7dStdDev = "0";
              volume7dStdDevRaw = 0;
            }
          } else {
            volume7d = "0";
            volume7dStdDev = "0";
          }
        }
        
        // Êõ¥Êñ∞7Êó•Êó•ÂùáÊàê‰∫§ÈáèÊòæÁ§∫
        const volume7dEl = document.getElementById("volume7dValue");
        if (volume7dEl) {
          volume7dEl.textContent = volume7d;
        }
        
        // Êõ¥Êñ∞ÊâãÁª≠Ë¥πÈ¢ÑÊµãÂå∫Âüü
        const feePredictionCard = document.getElementById("feePredictionCard");
        if (feePredictionCard) {
          feePredictionCard.style.display = "block";
          
          // Êõ¥Êñ∞ TVL ÊòæÁ§∫
          const currentTvlValueEl = document.getElementById("currentTvlValue");
          if (currentTvlValueEl) {
            // ‰ºòÂÖà‰ΩøÁî®ËÆ°ÁÆóÂá∫ÁöÑ TVLÔºåÂê¶Âàô‰ΩøÁî® API ËøîÂõûÁöÑ TVL
            const tvlToShow = calculatedTvlDisplay !== "N/A" ? calculatedTvlDisplay : 
                             (liquidityUsd && liquidityUsd !== "N/A" ? 
                              (Number(liquidityUsd) >= 1000000 ? `$${(Number(liquidityUsd) / 1000000).toFixed(2)}M` :
                               Number(liquidityUsd) >= 1000 ? `$${(Number(liquidityUsd) / 1000).toFixed(2)}K` :
                               `$${Number(liquidityUsd).toFixed(2)}`) : "N/A");
            currentTvlValueEl.textContent = tvlToShow;
          }
          
          // Êõ¥Êñ∞ 7Êó•Êó•Âùá‰∫§ÊòìÈáèÊòæÁ§∫
          const dailyVolume7dValueEl = document.getElementById("dailyVolume7dValue");
          if (dailyVolume7dValueEl) {
            dailyVolume7dValueEl.textContent = volume7d !== "N/A" ? `$${volume7d}` : "N/A";
          }
          
          // Êõ¥Êñ∞ 7Êó•‰∫§ÊòìÈáèÊ†áÂáÜÂ∑ÆÊòæÁ§∫
          const dailyVolume7dStdDevValueEl = document.getElementById("dailyVolume7dStdDevValue");
          if (dailyVolume7dStdDevValueEl) {
            dailyVolume7dStdDevValueEl.textContent = volume7dStdDev !== "N/A" ? `$${volume7dStdDev}` : "N/A";
            // ‰øùÂ≠òÂéüÂßãÊï∞ÂÄºÂà∞ data Â±ûÊÄßÔºåÁî®‰∫éÈ£éÈô©ÊåáÊ†áËÆ°ÁÆó
            if (volume7dStdDevRaw !== null && Number.isFinite(volume7dStdDevRaw)) {
              dailyVolume7dStdDevValueEl.setAttribute("data-raw-value", volume7dStdDevRaw.toString());
            } else {
              dailyVolume7dStdDevValueEl.removeAttribute("data-raw-value");
            }
          }
          
          // ‰øùÂ≠òÂéüÂßãÊï∞ÂÄºÂà∞ data Â±ûÊÄßÔºåÁî®‰∫é APR ËÆ°ÁÆó
          if (currentTvlValueEl) {
            const tvlRaw = calculatedTvl || (liquidityUsd && liquidityUsd !== "N/A" ? Number(liquidityUsd) : null);
            currentTvlValueEl.setAttribute("data-raw-value", tvlRaw || "");
          }
          if (dailyVolume7dValueEl) {
            dailyVolume7dValueEl.setAttribute("data-raw-value", volume7dRaw || "");
          }
        }

        // ËÆ°ÁÆóÁõ∏ÂÖ≥Á≥ªÊï∞
        let correlationDisplay = "N/A";
        const correlationResult = calculatePriceCorrelation(30);
        if (correlationResult && !isNaN(correlationResult.correlation)) {
          correlationDisplay = correlationResult.correlation.toFixed(4);
        }
        
        // Êõ¥Êñ∞Áõ∏ÂÖ≥Á≥ªÊï∞ÊòæÁ§∫
        const correlationEl = document.getElementById("correlationValue");
        if (correlationEl) {
          correlationEl.textContent = correlationDisplay;
        }

        // ‰ΩøÁî®Â≠òÂÇ®ÁöÑÊï∞ÊçÆÊõ¥Êñ∞ÂõæË°®ÔºàÊòæÁ§∫ÂΩìÂâçÈÄâÊã©ÁöÑÂ§©Êï∞Ôºâ
        updateChartFromStoredData(days);

        resultsEl.style.display = "block";
        
        // ËÆæÁΩÆ‰ª∑Ê†ºÊØîÁéáÂàáÊç¢ÂäüËÉΩ
        setupPriceRatioToggle();
        
        // ËÆæÁΩÆDEXÁÇπÂáªÂäüËÉΩÔºàÂ¶ÇÊûúÊòØPancakeSwapÔºâ
        setupDexClickHandler();
        
        // ÊòæÁ§∫/ÈöêËóèPancakeSwapÊâãÁª≠Ë¥πÊèêÁ§∫
        const pancakeswapFeeNote = document.getElementById("pancakeswapFeeNote");
        const pancakeswapFeeNoteText = document.getElementById("pancakeswapFeeNoteText");
        const pancakeswapFeeNoteLink = document.getElementById("pancakeswapFeeNoteLink");
        if (pancakeswapFeeNote) {
          pancakeswapFeeNote.style.display = isPancakeSwap ? "block" : "none";
          if (isPancakeSwap && pancakeswapFeeNoteText && pancakeswapFeeNoteLink) {
            pancakeswapFeeNoteText.textContent = t('pancakeswapFeeNote');
            pancakeswapFeeNoteLink.textContent = t('pancakeswapFeeNoteLink');
          }
        }
        
        // ËÆæÁΩÆÊâãÁª≠Ë¥π APR ËÆ°ÁÆóÂäüËÉΩ
        setupFeeAprCalculation();
        
        // Êï∞ÊçÆÂä†ËΩΩÂÆåÊàêÂêéÔºåËá™Âä®Ëß¶Âèë‰∏ÄÊ¨°ÊâãÁª≠Ë¥πËÆ°ÁÆó
        setTimeout(() => {
          const feePercentageInput = document.getElementById("feePercentageInput");
          if (feePercentageInput) {
            // Ëß¶Âèë input ‰∫ã‰ª∂‰ª•Ëá™Âä®ËÆ°ÁÆó
            feePercentageInput.dispatchEvent(new Event('input'));
          }
        }, 200);
        
        // Êõ¥Êñ∞HVÊåâÈíÆÁöÑÊòæÁ§∫Áä∂ÊÄÅ
        updateHvButtonsVisibility();
      } catch (e) {
        console.error(e);
        errorEl.textContent = e.message || String(e);
        // ÂèëÁîüÈîôËØØÊó∂ÈöêËóèHVÊåâÈíÆ
        updateHvButtonsVisibility();
      } finally {
        loadingEl.textContent = "";
      }
    }

    function setupFeeAprCalculation() {
      const feePercentageInput = document.getElementById("feePercentageInput");
      const feeDisplayStat = document.getElementById("feeDisplayStat");
      const feeDisplayLabel = document.getElementById("feeDisplayLabel");
      const feeDisplayValue = document.getElementById("feeDisplayValue");
      
      if (!feePercentageInput || !feeDisplayStat || !feeDisplayLabel || !feeDisplayValue) return;
      
      // Â≠òÂÇ®ËÆ°ÁÆóÂá∫ÁöÑÂÄº
      let calculatedApr = null;
      let calculatedDailyFee = null;
      
      // Êõ¥Êñ∞ÊòæÁ§∫ÁöÑÂáΩÊï∞
      function updateDisplay() {
        const displayType = feeDisplayStat.getAttribute("data-display-type");
        
        if (displayType === "apr") {
          feeDisplayLabel.textContent = t('dailyFeeApr');
          if (calculatedApr !== null && Number.isFinite(calculatedApr) && calculatedApr > 0) {
            feeDisplayValue.textContent = `${calculatedApr.toFixed(2)}%`;
            feeDisplayValue.style.color = "#4CAF50";
          } else {
            feeDisplayValue.textContent = "-";
            feeDisplayValue.style.color = "#999";
          }
        } else {
          feeDisplayLabel.textContent = t('dailyFee');
          if (calculatedDailyFee !== null && Number.isFinite(calculatedDailyFee) && calculatedDailyFee > 0) {
            feeDisplayValue.textContent = `${calculatedDailyFee.toFixed(2)}%`;
            feeDisplayValue.style.color = "#4CAF50";
          } else {
            feeDisplayValue.textContent = "-";
            feeDisplayValue.style.color = "#999";
          }
        }
      }
      
      // ËÆ°ÁÆó APR ÁöÑÂáΩÊï∞
      function calculateApr() {
        const feePercentage = parseFloat(feePercentageInput.value);
        
        if (isNaN(feePercentage) || feePercentage < 0 || feePercentage > 100) {
          calculatedApr = null;
          calculatedDailyFee = null;
          updateDisplay();
          return;
        }
        
        // Ëé∑Âèñ TVL Âíå 7Êó•Êó•Âùá‰∫§ÊòìÈáèÁöÑÂéüÂßãÊï∞ÂÄº
        const currentTvlValueEl = document.getElementById("currentTvlValue");
        const dailyVolume7dValueEl = document.getElementById("dailyVolume7dValue");
        
        const tvlRaw = currentTvlValueEl ? parseFloat(currentTvlValueEl.getAttribute("data-raw-value")) : null;
        const volume7dRaw = dailyVolume7dValueEl ? parseFloat(dailyVolume7dValueEl.getAttribute("data-raw-value")) : null;
        
        if (!tvlRaw || !volume7dRaw || tvlRaw <= 0 || volume7dRaw <= 0) {
          calculatedApr = null;
          calculatedDailyFee = null;
          updateDisplay();
          return;
        }
        
        // ËÆ°ÁÆóÊó•ÂùáÊâãÁª≠Ë¥πÊî∂Áõä
        // ÊâãÁª≠Ë¥πÁôæÂàÜÊØîËΩ¨Êç¢‰∏∫Â∞èÊï∞Ôºà‰æãÂ¶Ç 0.3% = 0.003Ôºâ
        const feeRate = feePercentage / 100;
        let dailyFeeAmount = volume7dRaw * feeRate;
        
        // Â¶ÇÊûúÊòØPancakeSwapÔºåÊµÅÂä®ÊÄßÊèê‰æõËÄÖÂè™ËÉΩËé∑Âæó84%ÁöÑÊâãÁª≠Ë¥πÊî∂ÂÖ•
        if (isPancakeSwap) {
          dailyFeeAmount = dailyFeeAmount * 0.84;
        }
        
        // ËÆ°ÁÆó APR: (Êó•ÂùáÊî∂Áõä / TVL) * 365 * 100
        calculatedApr = (dailyFeeAmount / tvlRaw) * 365 * 100;
        
        // ËÆ°ÁÆóÊó•ÂùáÊâãÁª≠Ë¥πÁôæÂàÜÊØî: (Êó•ÂùáÊî∂Áõä / TVL) * 100
        calculatedDailyFee = (dailyFeeAmount / tvlRaw) * 100;
        
        // ‰øùÂ≠òÂà∞ data Â±ûÊÄß
        feeDisplayStat.setAttribute("data-apr", calculatedApr || "");
        feeDisplayStat.setAttribute("data-daily-fee", calculatedDailyFee || "");
        
        // Êõ¥Êñ∞ IL Ê®°ÊãüÂô®‰∏≠ÁöÑ Fee APR ËæìÂÖ•Ê°ÜÈªòËÆ§ÂÄº
        const ilFeeAprInput = document.getElementById("ilFeeApr");
        if (ilFeeAprInput && calculatedApr !== null && Number.isFinite(calculatedApr) && calculatedApr > 0) {
          ilFeeAprInput.value = calculatedApr.toFixed(2);
        }
        
        updateDisplay();
        
        // Êõ¥Êñ∞ Net APRÔºàÂ¶ÇÊûú IL Ê®°ÊãüÂ∑≤ÁªèËøêË°åËøáÔºâ
        const dailyIlEl = document.getElementById("ilDaily");
        const daysEl = document.getElementById("ilDays");
        if (dailyIlEl && dailyIlEl.textContent !== "‚Äì" && daysEl) {
          // ‰ªéÊòæÁ§∫ÊñáÊú¨‰∏≠ÊèêÂèñÊó•Âùá IL
          const dailyIlText = dailyIlEl.textContent.trim();
          if (dailyIlText && dailyIlText !== "‚Äì") {
            const dailyIlMatch = dailyIlText.match(/([-\d.]+)\s*%/);
            if (dailyIlMatch) {
              const dailyIl = parseFloat(dailyIlMatch[1]) / 100;
              const days = Number(daysEl.value);
              if (days > 0 && Number.isFinite(days)) {
                updateNetApr(dailyIl, days);
              } else {
                // Âç≥‰ΩøÊ≤°ÊúâILÊï∞ÊçÆÔºå‰πüÂ∞ùËØïËÆ°ÁÆóÈ£éÈô©ÊåáÊ†áÔºàÂè™ËÆ°ÁÆóÊâãÁª≠Ë¥πÈÉ®ÂàÜÔºâ
                calculateAndDisplayRiskMetrics(null, null, null);
              }
            }
          } else {
            // Âç≥‰ΩøÊ≤°ÊúâILÊï∞ÊçÆÔºå‰πüÂ∞ùËØïËÆ°ÁÆóÈ£éÈô©ÊåáÊ†áÔºàÂè™ËÆ°ÁÆóÊâãÁª≠Ë¥πÈÉ®ÂàÜÔºâ
            calculateAndDisplayRiskMetrics(null, null, null);
          }
        } else {
          // Âç≥‰ΩøÊ≤°ÊúâILÊï∞ÊçÆÔºå‰πüÂ∞ùËØïËÆ°ÁÆóÈ£éÈô©ÊåáÊ†áÔºàÂè™ËÆ°ÁÆóÊâãÁª≠Ë¥πÈÉ®ÂàÜÔºâ
          calculateAndDisplayRiskMetrics(null, null, null);
        }
      }
      
      // ÂàáÊç¢ÊòæÁ§∫Á±ªÂûã
      feeDisplayStat.onclick = function() {
        const currentType = this.getAttribute("data-display-type");
        const newType = currentType === "apr" ? "dailyFee" : "apr";
        this.setAttribute("data-display-type", newType);
        updateDisplay();
      };
      
      // ËæìÂÖ•Ê°ÜÂèòÂåñÊó∂Ëá™Âä®ËÆ°ÁÆó
      feePercentageInput.addEventListener("input", calculateApr);
      
      // È°µÈù¢Âä†ËΩΩÊó∂Ëá™Âä®ËÆ°ÁÆó‰∏ÄÊ¨°Ôºà‰ΩøÁî®ÈªòËÆ§ÂÄº 0.01Ôºâ
      setTimeout(() => {
        calculateApr();
      }, 100);
    }

    function setupPriceRatioToggle() {
      const priceRatioStat = document.getElementById("priceRatioStat");
      if (!priceRatioStat) return;
      
      // ‰ΩøÁî® once: false Á°Æ‰øùÂèØ‰ª•Â§öÊ¨°ÁÇπÂáª
      priceRatioStat.onclick = function() {
        const currentType = this.getAttribute("data-ratio-type");
        const baseSymbol = this.getAttribute("data-base-symbol");
        const quoteSymbol = this.getAttribute("data-quote-symbol");
        const token1PerToken0 = this.getAttribute("data-token1-per-token0");
        const token0PerToken1 = this.getAttribute("data-token0-per-token1");
        
        const labelEl = document.getElementById("priceRatioLabel");
        const valueEl = document.getElementById("priceRatioValue");
        
        if (currentType === "token1-token0") {
          // ÂàáÊç¢Âà∞ token0/token1
          this.setAttribute("data-ratio-type", "token0-token1");
          if (labelEl) labelEl.textContent = `${baseSymbol} / ${quoteSymbol}`;
          if (valueEl) valueEl.textContent = `1 ${baseSymbol} = ${token0PerToken1} ${quoteSymbol}`;
        } else {
          // ÂàáÊç¢Âà∞ token1/token0
          this.setAttribute("data-ratio-type", "token1-token0");
          if (labelEl) labelEl.textContent = `${quoteSymbol} / ${baseSymbol}`;
          if (valueEl) valueEl.textContent = `1 ${quoteSymbol} = ${token1PerToken0} ${baseSymbol}`;
        }
      };
    }

    function setupDexClickHandler() {
      const dexClickableEl = document.getElementById("dexClickableStat");
      if (!dexClickableEl) return;
      
      const poolId = dexClickableEl.getAttribute("data-pool-id");
      if (!poolId) return;
      
      dexClickableEl.onclick = function() {
        const pancakeswapUrl = `https://pancakeswap.finance/liquidity/pool/solana/${poolId}`;
        window.open(pancakeswapUrl, '_blank');
      };
    }

    document.getElementById("loadBtn").addEventListener("click", () => {
      const poolId = document.getElementById("poolId").value;
      loadPool(poolId, currentDays);
    });

    document.getElementById("poolId").addEventListener("keyup", (e) => {
      if (e.key === "Enter") {
        loadPool(e.target.value, currentDays);
      }
    });

    const checkBirdeyeKeyBtn = document.getElementById("checkBirdeyeKeyBtn");
    if (checkBirdeyeKeyBtn) {
      checkBirdeyeKeyBtn.addEventListener("click", () => {
        checkBirdeyeKey();
      });
    }

    // ÊäòÂè†/Â±ïÂºÄËá™ÂÆö‰πâ API Key ËæìÂÖ•Âå∫Âüü
    const toggleCustomKeyBtn = document.getElementById("toggleCustomKeyBtn");
    const customKeySection = document.getElementById("customKeySection");
    const toggleCustomKeyText = document.getElementById("toggleCustomKeyText");
    const toggleCustomKeyArrow = document.getElementById("toggleCustomKeyArrow");
    
    if (toggleCustomKeyBtn && customKeySection) {
      toggleCustomKeyBtn.addEventListener("click", () => {
        const isExpanded = customKeySection.style.display !== "none";
        if (isExpanded) {
          // ÊäòÂè†
          customKeySection.style.display = "none";
          toggleCustomKeyText.textContent = "api_key_config";
          toggleCustomKeyArrow.textContent = "‚ñº";
        } else {
          // Â±ïÂºÄ
          customKeySection.style.display = "block";
          toggleCustomKeyText.textContent = "api_key_config";
          toggleCustomKeyArrow.textContent = "‚ñ≤";
        }
      });
    }

    // ÊòæÁ§∫/ÈöêËóè API Key ÊåâÈíÆ
    const toggleKeyVisibilityBtn = document.getElementById("toggleKeyVisibilityBtn");
    if (toggleKeyVisibilityBtn) {
      toggleKeyVisibilityBtn.addEventListener("click", () => {
        const keyInput = document.getElementById("birdeyeApiKey");
        if (keyInput) {
          if (keyInput.type === "password") {
            keyInput.type = "text";
            toggleKeyVisibilityBtn.textContent = "üôà";
          } else {
            keyInput.type = "password";
            toggleKeyVisibilityBtn.textContent = "üëÅÔ∏è";
          }
        }
      });
    }

    // È°µÈù¢Âä†ËΩΩÊó∂Â∞ùËØïÊÅ¢Â§çÂ≠òÂÇ®ÁöÑ keyÔºà‰ΩÜ‰∏çÊòæÁ§∫Âú®ËæìÂÖ•Ê°Ü‰∏≠Ôºå‰øùÊåÅÈöêÁßÅÔºâ
    function restoreStoredKey() {
      const storedKey = getStoredBirdeyeApiKey();
      if (storedKey) {
        const keyInput = document.getElementById("birdeyeApiKey");
        if (keyInput && !keyInput.value) {
          // ÈùôÈªòÊÅ¢Â§çÔºå‰∏çÊòæÁ§∫Âú®ËæìÂÖ•Ê°Ü‰∏≠
          // Â¶ÇÊûúÈúÄË¶ÅËá™Âä®Â°´ÂÖÖÔºåÂèñÊ∂à‰∏ãÈù¢ÁöÑÊ≥®ÈáäÔºö
          // keyInput.value = storedKey;
          console.log("Â∑≤‰ªéÊú¨Âú∞Â≠òÂÇ®ÊÅ¢Â§ç API KeyÔºàÂ∑≤Ê∑∑Ê∑ÜÔºâ");
        }
      }
    }

    // ÊªëÊùÜÔºöÂÆûÊó∂Êõ¥Êñ∞Â§©Êï∞ÔºåÂè™Êõ¥Êñ∞ÂõæË°®ÊòæÁ§∫Ôºå‰∏çÈáçÊñ∞Âä†ËΩΩÊï∞ÊçÆ
    const daysRangeEl = document.getElementById("daysRange");
    if (daysRangeEl) {
      const updateChartFromSlider = () => {
        const newDays = Number(daysRangeEl.value);
        currentDays = newDays;

        const daysLabelEl = document.getElementById("daysLabel");
        if (daysLabelEl) {
          daysLabelEl.textContent = newDays;
        }

        // Âè™Êõ¥Êñ∞ÂõæË°®Ôºå‰∏çÈáçÊñ∞Âä†ËΩΩÊï∞ÊçÆ
        const resultsEl = document.getElementById("results");
        if (resultsEl && resultsEl.style.display !== "none") {
          updateChartFromStoredData(newDays);
        }
      };

      daysRangeEl.addEventListener("input", updateChartFromSlider);
      daysRangeEl.addEventListener("change", updateChartFromSlider);
    }

    // Popular pools data
    const popularPools = [
      { name: "cbBTC/USDC", id: "7ENJsaWAy4PRs24NYd1WqUdY3DWi43rHvyZXhCjEiNWE" },
      { name: "SOL/USDT", id: "22HUWiJaTNph96KQTKZVy2wg8KzfCems5nyW7E5H5J6w" },
      { name: "SOL/USDC", id: "DJNtGuBGEQiUCWE8F981M2C3ZghZt2XLD8f2sQdZ6rsZ" },
      { name: "USDC/USDT", id: "46Z4iBRb8Kwj2qBoDyLAWt99vKXsUS1vE7vFU2vy5x2V" },
      { name: "SOL/HYPE", id: "4nDy9TQUTfqbmexZi25ujv11KMkDfFMmGeKPRw8HryWY" },
      { name: "SOL/WBTC", id: "GLfJcQZgtLV2QyEBxmNNZ75uJFG1VRiLiki8PfcTZQjW" },
      { name: "USD1/USDC", id: "CWNajRMzUb7ywfuVu9N7b9myhm6GPGFVNaMNAPkNpSjn" },
      { name: "CAKE/USDC", id: "J734vwZxCrrFLhGxwkZdFo3537snbYtLbkvtM15HkETr" },
    ];

    // Initialize popular pools scroll bar
    function initPopularPools() {
      const scrollContainer = document.getElementById("popularPoolsScroll");
      if (!scrollContainer) return;

      // Create pool items (duplicate for seamless loop)
      const createPoolItems = () => {
        return popularPools.map(pool => {
          const item = document.createElement("div");
          item.className = "popular-pool-item";
          item.textContent = pool.name;
          item.dataset.poolId = pool.id;
          item.addEventListener("click", () => {
            const poolIdInput = document.getElementById("poolId");
            if (poolIdInput) {
              poolIdInput.value = pool.id;
              // Automatically trigger Load Pool button
              const loadBtn = document.getElementById("loadBtn");
              if (loadBtn) {
                loadBtn.click();
              } else {
                // Fallback: directly call loadPool if button not found
                loadPool(pool.id, currentDays);
              }
            }
          });
          return item;
        });
      };

      // Duplicate items for seamless scrolling
      const items = createPoolItems();
      const duplicatedItems = createPoolItems();
      
      items.forEach(item => scrollContainer.appendChild(item));
      duplicatedItems.forEach(item => scrollContainer.appendChild(item));
    }

    window.addEventListener("load", () => {
      // Initialize popular pools
      initPopularPools();
      
      // Â∞ùËØïÊÅ¢Â§çÂ≠òÂÇ®ÁöÑ API Key
      restoreStoredKey();
      
      const poolId = document.getElementById("poolId").value;
      loadPool(poolId, currentDays);
      // Â¶ÇÊûúÁî®Êà∑Â∑≤ËæìÂÖ• Birdeye API KeyÔºåÂàôÊ£ÄÊü•ÂÖ∂ÊòØÂê¶ÂèØÁî®
      checkBirdeyeKey();
    });

    // ========= Historical Volatility Calculation =========

    /**
     * ËÆ°ÁÆóÂéÜÂè≤Ê≥¢Âä®ÁéáÔºàÊó•Á∫ßÂà´Ôºâ
     * @param {Array} prices - ‰ª∑Ê†ºÊï∞ÁªÑÔºàÊî∂Áõò‰ª∑Ôºâ
     * @param {number} minDays - ÊúÄÂ∞ëÈúÄË¶ÅÁöÑÊï∞ÊçÆÂ§©Êï∞ÔºåÈªòËÆ§30
     * @returns {number|null} - Êó•Ê≥¢Âä®ÁéáÔºàÁôæÂàÜÊØîÔºâÔºåÂ¶ÇÊûúÊï∞ÊçÆ‰∏çË∂≥ËøîÂõûnull
     */
    function calculateHistoricalVolatility(prices, minDays = 30) {
      // ËøáÊª§ÊéâÊó†Êïà‰ª∑Ê†ºÔºànull, undefined, 0, NaNÔºâ
      const validPrices = prices.filter(p => 
        p !== null && 
        p !== undefined && 
        !isNaN(Number(p)) && 
        Number(p) > 0
      );

      if (validPrices.length < minDays) {
        return null; // Êï∞ÊçÆ‰∏çË∂≥
      }

      if (validPrices.length < 2) {
        return null; // Ëá≥Â∞ëÈúÄË¶Å2‰∏™‰ª∑Ê†ºÁÇπ
      }

      // ËÆ°ÁÆóÂØπÊï∞Êî∂ÁõäÁéá
      const returns = [];
      for (let i = 1; i < validPrices.length; i++) {
        const prevPrice = Number(validPrices[i - 1]);
        const currPrice = Number(validPrices[i]);
        
        if (prevPrice > 0 && currPrice > 0) {
          const logReturn = Math.log(currPrice / prevPrice);
          returns.push(logReturn);
        }
      }

      if (returns.length === 0) {
        return null;
      }

      // ËÆ°ÁÆóÂùáÂÄº
      const mean = returns.reduce((a, b) => a + b, 0) / returns.length;

      // ËÆ°ÁÆóÊñπÂ∑ÆÔºàÊ†∑Êú¨ÊñπÂ∑ÆÔºå‰ΩøÁî® n-1Ôºâ
      const variance = returns.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / (returns.length - 1);

      // Êó•Ê≥¢Âä®ÁéáÔºàÊ†áÂáÜÂ∑ÆÔºâ
      const dailyVolatility = Math.sqrt(variance);

      // ËΩ¨Êç¢‰∏∫ÁôæÂàÜÊØî
      return dailyVolatility * 100;
    }

    /**
     * ‰ªéÂ≠òÂÇ®ÁöÑOHLCVÊï∞ÊçÆ‰∏≠ÊèêÂèñ‰ª∑Ê†ºÂπ∂ËÆ°ÁÆóÂéÜÂè≤Ê≥¢Âä®Áéá
     * @param {string} token - 'token0' Êàñ 'token1' Êàñ 'average'
     * @param {number} lookbackDays - ÂõûÁúãÂ§©Êï∞ÔºåÈªòËÆ§30
     * @returns {Object|null} - {volatility: number, token: string, days: number, prices: number} Êàñ null
     */
    function calculateHvFromStoredData(token = 'token0', lookbackDays = 30) {
      if (!storedOhlcvData || storedOhlcvData.length === 0) {
        return null;
      }

      // ÊèêÂèñÊúÄËøëNÂ§©ÁöÑÊï∞ÊçÆ
      const recentData = storedOhlcvData.slice(-lookbackDays);
      
      let prices = [];
      
      if (token === 'token0') {
        // token0 ÁöÑÊî∂Áõò‰ª∑Âú®Á¥¢Âºï4
        prices = recentData.map(entry => entry[4]); // close0
      } else if (token === 'token1') {
        // token1 ÁöÑÊî∂Áõò‰ª∑Âú®Á¥¢Âºï11
        prices = recentData.map(entry => entry[11]); // close1
      } else if (token === 'average') {
        // ËÆ°ÁÆó‰∏§ËÄÖÁöÑÂπ≥ÂùáÂÄº
        prices = recentData.map(entry => {
          const close0 = entry[4];
          const close1 = entry[11];
          if (close0 !== null && close1 !== null && 
              !isNaN(Number(close0)) && !isNaN(Number(close1)) &&
              Number(close0) > 0 && Number(close1) > 0) {
            return (Number(close0) + Number(close1)) / 2;
          }
          return null;
        });
      } else {
        return null;
      }

      // ËÆ°ÁÆóÊ≥¢Âä®ÁéáÔºåÊúÄÂ∞ëÈúÄË¶Å10‰∏™ÊúâÊïà‰ª∑Ê†ºÁÇπ
      const minPrices = Math.min(10, Math.floor(lookbackDays * 0.5));
      const volatility = calculateHistoricalVolatility(prices, minPrices);
      
      if (volatility === null) {
        return null;
      }

      const validPricesCount = prices.filter(p => p !== null && !isNaN(Number(p)) && Number(p) > 0).length;

      return {
        volatility: volatility,
        token: token,
        days: recentData.length,
        prices: validPricesCount
      };
    }

    /**
     * Êõ¥Êñ∞HVÊåâÈíÆÁöÑÊòæÁ§∫Áä∂ÊÄÅ
     * Ê†πÊçÆkÁ∫øÊï∞ÊçÆÁöÑÂèØÁî®ÊÄßÂä®ÊÄÅÊòæÁ§∫/ÈöêËóèÊåâÈíÆ
     */
    function updateHvButtonsVisibility() {
      const calcHvBtn0 = document.getElementById("calcHvBtn0");
      const calcHvBtn1 = document.getElementById("calcHvBtn1");
      const calcRatioVolBtn = document.getElementById("calcRatioVolBtn");
      
      if (!calcHvBtn0 || !calcHvBtn1) {
        return;
      }

      // Ê£ÄÊü•ÊòØÂê¶ÊúâKÁ∫øÊï∞ÊçÆ
      if (!storedOhlcvData || storedOhlcvData.length === 0) {
        calcHvBtn0.style.display = "none";
        calcHvBtn1.style.display = "none";
        if (calcRatioVolBtn) calcRatioVolBtn.style.display = "none";
        return;
      }

      // Ê£ÄÊü•token0ÊòØÂê¶ÊúâË∂≥Â§üÁöÑÊï∞ÊçÆ
      const hvResult0 = calculateHvFromStoredData('token0', 30);
      if (hvResult0) {
        const token0Name = currentBaseSymbol || 'Token0';
        calcHvBtn0.textContent = `${token0Name} HV`;
        calcHvBtn0.style.display = "inline-block";
      } else {
        calcHvBtn0.style.display = "none";
      }

      // Ê£ÄÊü•token1ÊòØÂê¶ÊúâË∂≥Â§üÁöÑÊï∞ÊçÆ
      const hvResult1 = calculateHvFromStoredData('token1', 30);
      if (hvResult1) {
        const token1Name = currentQuoteSymbol || 'Token1';
        calcHvBtn1.textContent = `${token1Name} HV`;
        calcHvBtn1.style.display = "inline-block";
      } else {
        calcHvBtn1.style.display = "none";
      }

      // Ê£ÄÊü•ÊòØÂê¶ÂèØ‰ª•ËÆ°ÁÆó‰ª∑Ê†ºÊØîÁéáÊ≥¢Âä®ÁéáÔºàÈúÄË¶Åtoken0„ÄÅtoken1ÁöÑHVÂíåÁõ∏ÂÖ≥Á≥ªÊï∞Ôºâ
      if (calcRatioVolBtn) {
        const correlationResult = calculatePriceCorrelation(30);
        if (hvResult0 && hvResult1 && correlationResult && !isNaN(correlationResult.correlation)) {
          calcRatioVolBtn.style.display = "inline-block";
        } else {
          calcRatioVolBtn.style.display = "none";
        }
      }
    }

    /**
     * ËÆ°ÁÆóÂπ∂Â°´ÂÖ•ÊåáÂÆötokenÁöÑÂéÜÂè≤Ê≥¢Âä®Áéá
     * @param {string} token - 'token0' Êàñ 'token1'
     */
    function calculateAndFillHv(token) {
      const hvInfoEl = document.getElementById("hvInfo");
      const sigmaDailyEl = document.getElementById("ilSigmaDaily");
      const calcHvBtn0 = document.getElementById("calcHvBtn0");
      const calcHvBtn1 = document.getElementById("calcHvBtn1");
      const calcHvBtn = token === 'token0' ? calcHvBtn0 : calcHvBtn1;
      
      if (!hvInfoEl || !sigmaDailyEl) {
        return;
      }

      // Ê£ÄÊü•ÊòØÂê¶ÊúâKÁ∫øÊï∞ÊçÆ
      if (!storedOhlcvData || storedOhlcvData.length === 0) {
        hvInfoEl.textContent = t('noPriceDataAvailable');
        hvInfoEl.style.color = "var(--danger)";
        return;
      }

      // ÊòæÁ§∫ËÆ°ÁÆó‰∏≠Áä∂ÊÄÅ
      if (calcHvBtn) {
        const originalText = calcHvBtn.textContent;
        calcHvBtn.textContent = "‚è≥";
        calcHvBtn.disabled = true;
      }
      hvInfoEl.textContent = t('calculating');
      hvInfoEl.style.color = "var(--text-muted)";

      // ‰ΩøÁî®setTimeoutËÆ©UIÊúâÊó∂Èó¥Êõ¥Êñ∞
      setTimeout(() => {
        const hvResult = calculateHvFromStoredData(token, 30);
        const tokenName = token === 'token0' 
          ? (currentBaseSymbol || 'Token0')
          : (currentQuoteSymbol || 'Token1');

        // ÊÅ¢Â§çÊåâÈíÆÁä∂ÊÄÅ
        if (calcHvBtn) {
          calcHvBtn.textContent = `${tokenName} HV`;
          calcHvBtn.disabled = false;
        }

        if (!hvResult) {
          hvInfoEl.textContent = t('insufficientPriceData', { tokenName: tokenName });
          hvInfoEl.style.color = "var(--danger)";
          return;
        }

        // Â°´ÂÖ•Ê≥¢Âä®Áéá
        sigmaDailyEl.value = hvResult.volatility.toFixed(2);
        
        // ÊòæÁ§∫‰ø°ÊÅØ
        hvInfoEl.textContent = `HV: ${hvResult.volatility.toFixed(2)}% (${tokenName}, ${hvResult.days}d, ${hvResult.prices} prices)`;
        hvInfoEl.style.color = "var(--accent)";
        
        // Ëß¶Âèëinput‰∫ã‰ª∂ÔºåÁ°Æ‰øùUIÊõ¥Êñ∞
        sigmaDailyEl.dispatchEvent(new Event('input', { bubbles: true }));
      }, 10);
    }

    /**
     * ËÆ°ÁÆó‰ª∑Ê†ºÊØîÁéáÁöÑÊó•Ê≥¢Âä®ÁéáÂπ∂Â°´ÂÖ•ËæìÂÖ•Ê°Ü
     * ÂÖ¨Âºè: œÉ_ratio = ‚àö(œÉ‚ÇÄ¬≤ + œÉ‚ÇÅ¬≤ - 2œÅ √ó œÉ‚ÇÄ √ó œÉ‚ÇÅ)
     */
    function calculateAndFillRatioVolatility() {
      const hvInfoEl = document.getElementById("hvInfo");
      const sigmaDailyEl = document.getElementById("ilSigmaDaily");
      const calcRatioVolBtn = document.getElementById("calcRatioVolBtn");
      
      if (!hvInfoEl || !sigmaDailyEl) {
        return;
      }

      // Ê£ÄÊü•ÊòØÂê¶ÊúâKÁ∫øÊï∞ÊçÆ
      if (!storedOhlcvData || storedOhlcvData.length === 0) {
        hvInfoEl.textContent = t('noPriceDataAvailable');
        hvInfoEl.style.color = "var(--danger)";
        return;
      }

      // ÊòæÁ§∫ËÆ°ÁÆó‰∏≠Áä∂ÊÄÅ
      if (calcRatioVolBtn) {
        calcRatioVolBtn.textContent = "‚è≥";
        calcRatioVolBtn.disabled = true;
      }
      hvInfoEl.textContent = t('calculatingRatioVolatility');
      hvInfoEl.style.color = "var(--text-muted)";

      // ‰ΩøÁî®setTimeoutËÆ©UIÊúâÊó∂Èó¥Êõ¥Êñ∞
      setTimeout(() => {
        // Ëé∑Âèñtoken0Âíåtoken1ÁöÑÊ≥¢Âä®Áéá
        const hvResult0 = calculateHvFromStoredData('token0', 30);
        const hvResult1 = calculateHvFromStoredData('token1', 30);
        const correlationResult = calculatePriceCorrelation(30);

        // ÊÅ¢Â§çÊåâÈíÆÁä∂ÊÄÅ
        if (calcRatioVolBtn) {
          const ratioVolText = document.getElementById('ratioVolatilityBtnText');
          if (ratioVolText) {
            ratioVolText.textContent = t('ratioVolatility');
          } else {
            calcRatioVolBtn.textContent = t('ratioVolatility');
          }
          calcRatioVolBtn.disabled = false;
        }

        // Ê£ÄÊü•Êï∞ÊçÆÊòØÂê¶Ë∂≥Â§ü
        if (!hvResult0 || !hvResult1) {
          hvInfoEl.textContent = t('needBothVolatilities');
          hvInfoEl.style.color = "var(--danger)";
          return;
        }

        if (!correlationResult || isNaN(correlationResult.correlation)) {
          hvInfoEl.textContent = t('cannotCalculateCorrelation');
          hvInfoEl.style.color = "var(--danger)";
          return;
        }

        // ËΩ¨Êç¢‰∏∫Â∞èÊï∞ÂΩ¢ÂºèÔºà‰ªéÁôæÂàÜÊØîÔºâ
        const sigma0 = hvResult0.volatility / 100;
        const sigma1 = hvResult1.volatility / 100;
        const rho = correlationResult.correlation;

        // ËÆ°ÁÆó‰ª∑Ê†ºÊØîÁéáÊ≥¢Âä®Áéá: œÉ_ratio = ‚àö(œÉ‚ÇÄ¬≤ + œÉ‚ÇÅ¬≤ - 2œÅ √ó œÉ‚ÇÄ √ó œÉ‚ÇÅ)
        const sigmaRatioSquared = sigma0 * sigma0 + sigma1 * sigma1 - 2 * rho * sigma0 * sigma1;
        
        if (sigmaRatioSquared < 0) {
          hvInfoEl.textContent = t('invalidVolatilityCalculation');
          hvInfoEl.style.color = "var(--danger)";
          return;
        }

        const sigmaRatio = Math.sqrt(sigmaRatioSquared);
        const sigmaRatioPercent = sigmaRatio * 100;

        // Â°´ÂÖ•Ê≥¢Âä®Áéá
        sigmaDailyEl.value = sigmaRatioPercent.toFixed(2);
        
        // ÊòæÁ§∫‰ø°ÊÅØ
        const token0Name = currentBaseSymbol || 'Token0';
        const token1Name = currentQuoteSymbol || 'Token1';
        hvInfoEl.textContent = `Ratio Vol: ${sigmaRatioPercent.toFixed(2)}% (œÉ‚ÇÄ=${hvResult0.volatility.toFixed(2)}%, œÉ‚ÇÅ=${hvResult1.volatility.toFixed(2)}%, œÅ=${rho.toFixed(3)})`;
        hvInfoEl.style.color = "var(--accent)";
        
        // Ëß¶Âèëinput‰∫ã‰ª∂ÔºåÁ°Æ‰øùUIÊõ¥Êñ∞
        sigmaDailyEl.dispatchEvent(new Event('input', { bubbles: true }));
      }, 10);
    }

    // ========= Correlation Coefficient Calculation =========

    /**
     * ËÆ°ÁÆó‰∏§‰∏™‰ª£Â∏Å‰ª∑Ê†ºÁöÑÂØπÊï∞Êî∂ÁõäÁéáÁöÑÁõ∏ÂÖ≥Á≥ªÊï∞
     * @param {number} lookbackDays - ÂõûÁúãÂ§©Êï∞ÔºåÈªòËÆ§30
     * @returns {Object|null} - {correlation: number, days: number, validPairs: number} Êàñ null
     */
    function calculatePriceCorrelation(lookbackDays = 30) {
      if (!storedOhlcvData || storedOhlcvData.length === 0) {
        return null;
      }

      // ÊèêÂèñÊúÄËøëNÂ§©ÁöÑÊï∞ÊçÆ
      const recentData = storedOhlcvData.slice(-lookbackDays);
      
      // ÊèêÂèñtoken0Âíåtoken1ÁöÑÊî∂Áõò‰ª∑
      const prices0 = [];
      const prices1 = [];
      
      for (const entry of recentData) {
        const close0 = entry[4];  // token0Êî∂Áõò‰ª∑
        const close1 = entry[11]; // token1Êî∂Áõò‰ª∑
        
        if (close0 !== null && close1 !== null && 
            !isNaN(Number(close0)) && !isNaN(Number(close1)) &&
            Number(close0) > 0 && Number(close1) > 0) {
          prices0.push(Number(close0));
          prices1.push(Number(close1));
        }
      }

      if (prices0.length < 2 || prices1.length < 2) {
        return null; // Ëá≥Â∞ëÈúÄË¶Å2‰∏™‰ª∑Ê†ºÁÇπÊù•ËÆ°ÁÆóÊî∂ÁõäÁéá
      }

      // ËÆ°ÁÆóÂØπÊï∞Êî∂ÁõäÁéá
      const returns0 = [];
      const returns1 = [];
      
      for (let i = 1; i < prices0.length; i++) {
        const prev0 = prices0[i - 1];
        const curr0 = prices0[i];
        const prev1 = prices1[i - 1];
        const curr1 = prices1[i];
        
        if (prev0 > 0 && curr0 > 0 && prev1 > 0 && curr1 > 0) {
          returns0.push(Math.log(curr0 / prev0));
          returns1.push(Math.log(curr1 / prev1));
        }
      }

      if (returns0.length < 2) {
        return null; // Ëá≥Â∞ëÈúÄË¶Å2‰∏™Êî∂ÁõäÁéáÁÇπ
      }

      // ËÆ°ÁÆóÂùáÂÄº
      const mean0 = returns0.reduce((a, b) => a + b, 0) / returns0.length;
      const mean1 = returns1.reduce((a, b) => a + b, 0) / returns1.length;

      // ËÆ°ÁÆóÂçèÊñπÂ∑ÆÂíåÊñπÂ∑Æ
      let covariance = 0;
      let variance0 = 0;
      let variance1 = 0;

      for (let i = 0; i < returns0.length; i++) {
        const diff0 = returns0[i] - mean0;
        const diff1 = returns1[i] - mean1;
        covariance += diff0 * diff1;
        variance0 += diff0 * diff0;
        variance1 += diff1 * diff1;
      }

      // ‰ΩøÁî®Ê†∑Êú¨ÊñπÂ∑ÆÔºàn-1Ôºâ
      const n = returns0.length;
      covariance = covariance / (n - 1);
      variance0 = variance0 / (n - 1);
      variance1 = variance1 / (n - 1);

      const std0 = Math.sqrt(variance0);
      const std1 = Math.sqrt(variance1);

      // ËÆ°ÁÆóÁõ∏ÂÖ≥Á≥ªÊï∞
      if (std0 === 0 || std1 === 0) {
        return null; // Ê†áÂáÜÂ∑Æ‰∏∫0ÔºåÊó†Ê≥ïËÆ°ÁÆóÁõ∏ÂÖ≥Á≥ªÊï∞
      }

      const correlation = covariance / (std0 * std1);

      return {
        correlation: correlation,
        days: recentData.length,
        validPairs: returns0.length
      };
    }

    // ========= Impermanent Loss Monte Carlo Simulator =========

    let ilChartInstance = null;
    let monteCarloPathChartInstance = null;
    let monteCarloAxisMode = 'price'; // 'price' or 'percentage'
    let monteCarloCurrentPrice = null; // Store current price for percentage calculation

    function randnBoxMuller() {
      let u = 0;
      let v = 0;
      while (u === 0) u = Math.random();
      while (v === 0) v = Math.random();
      return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
    }

    function uniswapV3XYForPrice(P, Pl, Pu, L) {
      const sqrtP = Math.sqrt(P);
      const sqrtPl = Math.sqrt(Pl);
      const sqrtPu = Math.sqrt(Pu);

      if (P <= Pl) {
        const x = L * (1 / sqrtPl - 1 / sqrtPu);
        return { x, y: 0 };
      } else if (P >= Pu) {
        const y = L * (sqrtPu - sqrtPl);
        return { x: 0, y };
      } else {
        const x = L * (1 / sqrtP - 1 / sqrtPu);
        const y = L * (sqrtP - sqrtPl);
        return { x, y };
      }
    }

    function buildIlDistributionChart(labels, counts) {
      const ctx = document.getElementById("ilDistributionChart").getContext("2d");
      if (ilChartInstance) {
        ilChartInstance.destroy();
      }

      ilChartInstance = new Chart(ctx, {
        type: "bar",
        data: {
          labels,
          datasets: [
            {
              label: "Frequency",
              data: counts,
              backgroundColor: "rgba(148, 163, 184, 0.65)",
              borderColor: "rgba(148, 163, 184, 0.95)",
              borderWidth: 1,
              maxBarThickness: 18
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              backgroundColor: "rgba(15, 23, 42, 0.96)",
              borderColor: "rgba(148, 163, 184, 0.6)",
              borderWidth: 1,
              padding: 8,
              callbacks: {
                label: (ctx) => {
                  const label = ctx.label || "";
                  const c = ctx.parsed.y;
                  return `${label}: ${c}`;
                }
              }
            }
          },
          scales: {
            x: {
              ticks: {
                color: "rgba(148, 163, 184, 0.9)",
                font: { size: 10 },
                maxRotation: 0,
                minRotation: 0
              },
              grid: { display: false }
            },
            y: {
              ticks: {
                color: "rgba(148, 163, 184, 0.9)",
                font: { size: 10 },
                precision: 0
              },
              grid: {
                color: "rgba(30, 64, 175, 0.25)"
              }
            }
          }
        }
      });
    }

    function buildMonteCarloPathChart(dayLabels, pathPricesArray, currentPrice, sigmaDailyPct, days, Pl, Pu) {
      const ctx = document.getElementById("monteCarloPathChart");
      if (!ctx) return;
      
      const chartCtx = ctx.getContext("2d");
      if (monteCarloPathChartInstance) {
        monteCarloPathChartInstance.destroy();
      }

      // Store current price for percentage calculation
      monteCarloCurrentPrice = currentPrice;

      // Helper function to transform data based on mode
      const transformData = (price) => {
        if (monteCarloAxisMode === 'percentage') {
          return ((price / currentPrice - 1) * 100);
        }
        return price;
      };

      // ÂàõÂª∫Â§ö‰∏™Êï∞ÊçÆÈõÜÔºåÊØè‰∏™Ë∑ØÂæÑ‰∏ÄÊù°ÊäòÁ∫ø
      const datasets = pathPricesArray.map((prices, index) => ({
        label: `${t('pricePath')} ${index + 1}`,
        data: prices.map(transformData),
        borderColor: "rgba(73, 229, 94, 0.75)",
        backgroundColor: "rgba(73, 229, 94, 0.1)",
        borderWidth: 1.5,
        pointRadius: 0,
        pointHoverRadius: 0,
        tension: 0.1,
        fill: false
      }));

      // Ê∑ªÂä†LP range‰ª∑Ê†º‰∏ãÈôêÂíå‰∏äÈôêÁöÑÊ®™Á∫ø
      if (Pl && Pu && Number.isFinite(Pl) && Number.isFinite(Pu)) {
        // LP range ‰ª∑Ê†º‰∏ãÈôêÊ®™Á∫ø
        datasets.push({
          label: t('lpRange'),
          data: new Array(dayLabels.length).fill(transformData(Pl)),
          borderColor: "rgba(168, 85, 247, 0.5)", // ‰∫ÆÁ¥´Ëâ≤Ôºå50%ÈÄèÊòéÂ∫¶
          backgroundColor: "transparent",
          borderWidth: 2,
          pointRadius: 0,
          pointHoverRadius: 0,
          tension: 0,
          fill: false
        });

        // LP range ‰ª∑Ê†º‰∏äÈôêÊ®™Á∫ø
        datasets.push({
          label: t('lpRange'),
          data: new Array(dayLabels.length).fill(transformData(Pu)),
          borderColor: "rgba(168, 85, 247, 0.5)", // ‰∫ÆÁ¥´Ëâ≤Ôºå50%ÈÄèÊòéÂ∫¶
          backgroundColor: "transparent",
          borderWidth: 2,
          pointRadius: 0,
          pointHoverRadius: 0,
          tension: 0,
          fill: false
        });
      }

      monteCarloPathChartInstance = new Chart(chartCtx, {
        type: "line",
        data: {
          labels: dayLabels,
          datasets: datasets
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            intersect: false,
            mode: 'index'
          },
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              enabled: false
            }
          },
          scales: {
            x: {
              title: {
                display: true,
                text: t('daysAxisLabel'),
                color: "rgba(148, 163, 184, 0.9)",
                font: { size: 11 }
              },
              ticks: {
                color: "rgba(148, 163, 184, 0.9)",
                font: { size: 10 }
              },
              grid: {
                color: "rgba(148, 163, 184, 0.1)"
              }
            },
            y: {
              title: {
                display: true,
                text: monteCarloAxisMode === 'percentage' ? t('percentageLabel') : t('priceLabel'),
                color: "rgba(148, 163, 184, 0.9)",
                font: { size: 11 }
              },
              ticks: {
                color: "rgba(148, 163, 184, 0.9)",
                font: { size: 10 },
                callback: function(value) {
                  if (monteCarloAxisMode === 'percentage') {
                    return value.toFixed(2) + '%';
                  }
                  return value.toFixed(2);
                }
              },
              grid: {
                color: "rgba(148, 163, 184, 0.15)"
              }
            }
          },
          onClick: function(event, elements) {
            // Check if click is on Y-axis area (left 60px of chart)
            const chartArea = this.chartArea;
            if (chartArea && event.x < chartArea.left + 60) {
              toggleMonteCarloAxisMode();
            }
          }
        }
      });
    }

    function toggleMonteCarloAxisMode() {
      monteCarloAxisMode = monteCarloAxisMode === 'price' ? 'percentage' : 'price';
      
      // Update toggle button text
      const toggleText = document.getElementById('monteCarloAxisToggleText');
      if (toggleText) {
        toggleText.textContent = monteCarloAxisMode === 'price' ? t('priceLabel') : t('percentageLabel');
      }
      
      // Rebuild chart if it exists
      if (monteCarloPathChartInstance && monteCarloCurrentPrice) {
        // Rebuild chart with stored data
        if (window.monteCarloPathData) {
          const { dayLabels, pathPricesArray, currentPrice, sigmaDailyPct, days, Pl, Pu } = window.monteCarloPathData;
          buildMonteCarloPathChart(dayLabels, pathPricesArray, currentPrice, sigmaDailyPct, days, Pl, Pu);
        }
      }
    }

    // ËÆæÁΩÆ Price lower bound ÁöÑÂáΩÊï∞
    function setLowerBound(percentage) {
      const p0El = document.getElementById("ilP0");
      const lowerEl = document.getElementById("ilLower");
      
      if (!p0El || !lowerEl) return;
      
      const currentPrice = parseFloat(p0El.value);
      if (isNaN(currentPrice) || currentPrice <= 0) {
        return; // Current price ‰∏∫Á©∫ÊàñÊó†ÊïàÔºå‰∏çÊâßË°åÊìç‰Ωú
      }
      
      // ËÆ°ÁÆó lower bound: currentPrice * (1 + percentage/100)
      // percentage ÊòØË¥üÊï∞Ôºå‰æãÂ¶Ç -0.05 Ë°®Á§∫ -0.05%
      const lowerBound = currentPrice * (1 + percentage / 100);
      lowerEl.value = lowerBound.toFixed(4);
    }

    // ËÆæÁΩÆ Price upper bound ÁöÑÂáΩÊï∞
    function setUpperBound(percentage) {
      const p0El = document.getElementById("ilP0");
      const upperEl = document.getElementById("ilUpper");
      
      if (!p0El || !upperEl) return;
      
      const currentPrice = parseFloat(p0El.value);
      if (isNaN(currentPrice) || currentPrice <= 0) {
        return; // Current price ‰∏∫Á©∫ÊàñÊó†ÊïàÔºå‰∏çÊâßË°åÊìç‰Ωú
      }
      
      // ËÆ°ÁÆó upper bound: currentPrice * (1 + percentage/100)
      // percentage ÊòØÊ≠£Êï∞Ôºå‰æãÂ¶Ç 0.05 Ë°®Á§∫ +0.05%
      const upperBound = currentPrice * (1 + percentage / 100);
      upperEl.value = upperBound.toFixed(4);
    }

    // Êõ¥Êñ∞ Net APR ÊòæÁ§∫ÁöÑÂáΩÊï∞
    // dailyIl: Êó•ÂùáILÔºàÂ∞èÊï∞ÂΩ¢ÂºèÔºå‰æãÂ¶Ç -0.00083 Ë°®Á§∫ -0.083%Ôºâ
    // days: Ê®°ÊãüÂ§©Êï∞
    function updateNetApr(dailyIl, days) {
      const feeBreakEvenEl = document.getElementById("ilFeeBreakEven");
      if (!feeBreakEvenEl) return;
      
      const statContainer = feeBreakEvenEl.closest('.stat');
      const toPercent = (x) => (x * 100).toFixed(3) + " %";
      
      // Ëé∑ÂèñÂπ¥ÂåñÊâãÁª≠Ë¥π APR
      // ‰ºòÂÖà‰ΩøÁî® ilFeeApr ËæìÂÖ•Ê°ÜÁöÑÂÄºÔºåÂ¶ÇÊûúÊ≤°ÊúâÂàô‰ªé feeDisplayStat Ëé∑Âèñ
      let annualFeeApr = null;
      const ilFeeAprInput = document.getElementById("ilFeeApr");
      if (ilFeeAprInput && ilFeeAprInput.value !== "" && !isNaN(parseFloat(ilFeeAprInput.value))) {
        annualFeeApr = parseFloat(ilFeeAprInput.value) / 100; // ËΩ¨Êç¢‰∏∫Â∞èÊï∞ÂΩ¢ÂºèÔºà‰æãÂ¶Ç 0.15 Ë°®Á§∫ 15%Ôºâ
      } else {
        const feeDisplayStat = document.getElementById("feeDisplayStat");
        if (feeDisplayStat) {
          const aprValue = feeDisplayStat.getAttribute("data-apr");
          if (aprValue && aprValue !== "") {
            annualFeeApr = parseFloat(aprValue) / 100; // ËΩ¨Êç¢‰∏∫Â∞èÊï∞ÂΩ¢ÂºèÔºà‰æãÂ¶Ç 0.15 Ë°®Á§∫ 15%Ôºâ
          }
        }
      }
      
      // ËÆ°ÁÆó Net APR = ((1+Êó•ÂùáÊâãÁª≠Ë¥πÊî∂ÂÖ•apr)*(1+Êó•Âùáil))^365 - 1
      let netApr = null;
      if (annualFeeApr !== null && Number.isFinite(annualFeeApr) && 
          dailyIl !== null && Number.isFinite(dailyIl) && 
          days !== null && Number.isFinite(days) && days > 0) {
        // Â∞ÜÂπ¥ÂåñÊâãÁª≠Ë¥πAPRËΩ¨Êç¢‰∏∫Êó•ÂùáÊâãÁª≠Ë¥πÊî∂ÂÖ•apr
        const dailyFeeApr = annualFeeApr / 365;
        
        // ËÆ°ÁÆóÔºö((1+Êó•ÂùáÊâãÁª≠Ë¥πÊî∂ÂÖ•apr)*(1+Êó•Âùáil))^365 - 1
        const dailyMultiplier = (1 + dailyFeeApr) * (1 + dailyIl);
        netApr = Math.pow(dailyMultiplier, 365) - 1;
      }
      
      if (netApr !== null && Number.isFinite(netApr)) {
        feeBreakEvenEl.textContent = toPercent(netApr);
        
        // Ê†πÊçÆÊ≠£Ë¥üÂÄºÂ∫îÁî®ÂÖâÊôïÊïàÊûú
        if (statContainer) {
          // ÁßªÈô§‰πãÂâçÁöÑÂÖâÊôïÁ±ª
          statContainer.classList.remove('glow-green', 'glow-red');
          
          if (netApr > 0) {
            statContainer.classList.add('glow-green');
          } else if (netApr < 0) {
            statContainer.classList.add('glow-red');
          }
        }
      } else {
        feeBreakEvenEl.textContent = "‚Äì";
        // ÁßªÈô§ÂÖâÊôïÊïàÊûú
        if (statContainer) {
          statContainer.classList.remove('glow-green', 'glow-red');
        }
      }
      
      // ËÆ°ÁÆóÂπ∂ÊòæÁ§∫Áõ∏ÂÖ≥ÊÄß„ÄÅÊÄªÂõûÊä•ÁéáÊ†áÂáÜÂ∑ÆÂíåÂ§èÊôÆÊØîÁéá
      calculateAndDisplayRiskMetrics(netApr, dailyIl, days);
    }

    /**
     * ËÆ°ÁÆóvolumeÂèòÂåñÁéáÂíå‰ª∑Ê†ºÂèòÂåñÁéáÔºàÂØºËá¥ILÔºâÁöÑÁõ∏ÂÖ≥ÊÄß
     * ‰ΩøÁî®ÂéÜÂè≤Êï∞ÊçÆËÆ°ÁÆó‰ª∑Ê†ºÂèòÂåñÁéáÔºàÂØπÊï∞Êî∂ÁõäÁéáÔºâÂíåvolumeÂèòÂåñÁéáÁöÑÁõ∏ÂÖ≥ÊÄß
     * @returns {number|null} - Áõ∏ÂÖ≥Á≥ªÊï∞ÔºåÂ¶ÇÊûúÊï∞ÊçÆ‰∏çË∂≥ËøîÂõûnull
     */
    function calculateVolumePriceCorrelation() {
      if (!storedOhlcvData || storedOhlcvData.length < 7) {
        return null; // Ëá≥Â∞ëÈúÄË¶Å7Â§©Êï∞ÊçÆ
      }

      // ‰ΩøÁî®ÊúÄËøë30Â§©ÁöÑÊï∞ÊçÆÔºàÂ¶ÇÊûúÂèØÁî®Ôºâ
      const lookbackDays = Math.min(30, storedOhlcvData.length - 1);
      const recentData = storedOhlcvData.slice(-lookbackDays);
      
      // ÊèêÂèñ‰ª∑Ê†ºÊØîÁéáÔºàtoken0/token1ÔºâÂíå‰∫§ÊòìÈáè
      const priceRatios = [];
      const volumes = [];
      
      for (const entry of recentData) {
        const close0 = entry[4];  // token0Êî∂Áõò‰ª∑
        const close1 = entry[11]; // token1Êî∂Áõò‰ª∑
        const volume = entry[5];  // ‰∫§ÊòìÈáè
        
        if (close0 !== null && close1 !== null && volume !== null &&
            !isNaN(Number(close0)) && !isNaN(Number(close1)) && !isNaN(Number(volume)) &&
            Number(close0) > 0 && Number(close1) > 0 && Number(volume) > 0) {
          const priceRatio = Number(close0) / Number(close1);
          priceRatios.push(priceRatio);
          volumes.push(Number(volume));
        }
      }

      if (priceRatios.length < 2 || volumes.length < 2) {
        return null;
      }

      // ËÆ°ÁÆó‰ª∑Ê†ºÊØîÁéáÁöÑÂèòÂåñÁéáÔºàÂØπÊï∞Êî∂ÁõäÁéáÔºâÂíå‰∫§ÊòìÈáèÁöÑÂèòÂåñÁéá
      const priceReturns = [];
      const volumeReturns = [];
      
      for (let i = 1; i < priceRatios.length; i++) {
        const prevPrice = priceRatios[i - 1];
        const currPrice = priceRatios[i];
        const prevVolume = volumes[i - 1];
        const currVolume = volumes[i];
        
        if (prevPrice > 0 && currPrice > 0 && prevVolume > 0 && currVolume > 0) {
          priceReturns.push(Math.log(currPrice / prevPrice));
          volumeReturns.push(Math.log(currVolume / prevVolume));
        }
      }

      if (priceReturns.length < 2) {
        return null;
      }

      // ËÆ°ÁÆóÂùáÂÄº
      const meanPrice = priceReturns.reduce((a, b) => a + b, 0) / priceReturns.length;
      const meanVolume = volumeReturns.reduce((a, b) => a + b, 0) / volumeReturns.length;

      // ËÆ°ÁÆóÂçèÊñπÂ∑ÆÂíåÊñπÂ∑Æ
      let covariance = 0;
      let variancePrice = 0;
      let varianceVolume = 0;

      for (let i = 0; i < priceReturns.length; i++) {
        const diffPrice = priceReturns[i] - meanPrice;
        const diffVolume = volumeReturns[i] - meanVolume;
        covariance += diffPrice * diffVolume;
        variancePrice += diffPrice * diffPrice;
        varianceVolume += diffVolume * diffVolume;
      }

      // ‰ΩøÁî®Ê†∑Êú¨ÊñπÂ∑ÆÔºàn-1Ôºâ
      const n = priceReturns.length;
      covariance = covariance / (n - 1);
      variancePrice = variancePrice / (n - 1);
      varianceVolume = varianceVolume / (n - 1);

      const stdPrice = Math.sqrt(variancePrice);
      const stdVolume = Math.sqrt(varianceVolume);

      // ËÆ°ÁÆóÁõ∏ÂÖ≥Á≥ªÊï∞
      if (stdPrice === 0 || stdVolume === 0) {
        return null;
      }

      const correlation = covariance / (stdPrice * stdVolume);
      return correlation;
    }

    /**
     * ËÆ°ÁÆóÂπ∂ÊòæÁ§∫È£éÈô©ÊåáÊ†áÔºöÁõ∏ÂÖ≥ÊÄß„ÄÅÊÄªÂõûÊä•ÁéáÊ†áÂáÜÂ∑Æ„ÄÅÂ§èÊôÆÊØîÁéá
     * @param {number|null} netApr - Net APRÔºàÂ∞èÊï∞ÂΩ¢ÂºèÔºâ
     * @param {number|null} dailyIl - Êó•ÂùáILÔºàÂ∞èÊï∞ÂΩ¢ÂºèÔºâ
     * @param {number|null} days - Ê®°ÊãüÂ§©Êï∞
     */
    function calculateAndDisplayRiskMetrics(netApr, dailyIl, days) {
      const correlationEl = document.getElementById("volumeIlCorrelation");
      const totalReturnStdEl = document.getElementById("totalReturnStd");
      const sharpeRatioEl = document.getElementById("sharpeRatio");
      
      if (!correlationEl || !totalReturnStdEl || !sharpeRatioEl) return;
      
      const toPercent = (x) => (x * 100).toFixed(3) + " %";
      const toDecimal = (x) => x.toFixed(4);
      
      // 1. ËÆ°ÁÆóÁõ∏ÂÖ≥ÊÄß
      const correlation = calculateVolumePriceCorrelation();
      if (correlation !== null && Number.isFinite(correlation)) {
        correlationEl.textContent = toDecimal(correlation);
      } else {
        correlationEl.textContent = "‚Äì";
      }
      
      // 2. Ëé∑ÂèñILÊ†áÂáÜÂ∑ÆÔºàÂπ¥ÂåñÔºâ
      const ilStdEl = document.getElementById("ilStd");
      let ilStdDev = null;
      if (ilStdEl) {
        // ‰ºòÂÖà‰ªédataÂ±ûÊÄßËé∑ÂèñÂéüÂßãÂÄº
        const rawValue = ilStdEl.getAttribute("data-raw-value");
        if (rawValue) {
          ilStdDev = parseFloat(rawValue); // Â∑≤ÁªèÊòØÂ∞èÊï∞ÂΩ¢Âºè
          // Âπ¥ÂåñÔºöÂ¶ÇÊûústdÊòØÊÄªILÁöÑÊ†áÂáÜÂ∑ÆÔºåÈúÄË¶ÅËΩ¨Êç¢‰∏∫Âπ¥ÂåñÊ†áÂáÜÂ∑Æ
          // ÂÅáËÆæstdÊòØÊÄªILÁöÑÊ†áÂáÜÂ∑ÆÔºåÂπ¥ÂåñÊ†áÂáÜÂ∑Æ = std / sqrt(days) * sqrt(365)
          if (days !== null && Number.isFinite(days) && days > 0) {
            ilStdDev = ilStdDev / Math.sqrt(days) * Math.sqrt(365);
          }
        } else if (ilStdEl.textContent !== "‚Äì") {
          // Â¶ÇÊûúÊ≤°ÊúâdataÂ±ûÊÄßÔºå‰ªéÊñáÊú¨Ëß£Êûê
          const ilStdText = ilStdEl.textContent.trim();
          const ilStdMatch = ilStdText.match(/([-\d.]+)\s*%/);
          if (ilStdMatch) {
            ilStdDev = parseFloat(ilStdMatch[1]) / 100; // ËΩ¨Êç¢‰∏∫Â∞èÊï∞ÂΩ¢Âºè
            // Âπ¥ÂåñÂ§ÑÁêÜ
            if (days !== null && Number.isFinite(days) && days > 0) {
              ilStdDev = ilStdDev / Math.sqrt(days) * Math.sqrt(365);
            }
          }
        }
      }
      
      // 3. Ëé∑ÂèñÊâãÁª≠Ë¥πÊî∂ÂÖ•Ê†áÂáÜÂ∑Æ
      // ÊâãÁª≠Ë¥πÊî∂ÂÖ•Ê†áÂáÜÂ∑Æ = ÊâãÁª≠Ë¥πÁéá √ó ‰∫§ÊòìÈáèÊ†áÂáÜÂ∑Æ
      const feeDisplayStat = document.getElementById("feeDisplayStat");
      const dailyVolume7dStdDevValueEl = document.getElementById("dailyVolume7dStdDevValue");
      let feeIncomeStdDev = null;
      
      if (feeDisplayStat && dailyVolume7dStdDevValueEl) {
        const feePercentageInput = document.getElementById("feePercentageInput");
        if (feePercentageInput) {
          const feePercentage = parseFloat(feePercentageInput.value);
          if (!isNaN(feePercentage) && feePercentage >= 0 && feePercentage <= 100) {
            const feeRate = feePercentage / 100; // ÊâãÁª≠Ë¥πÁéáÔºàÂ∞èÊï∞ÂΩ¢ÂºèÔºâ
            
            // Ëé∑Âèñ‰∫§ÊòìÈáèÊ†áÂáÜÂ∑ÆÁöÑÂéüÂßãÂÄºÔºà‰ªédataÂ±ûÊÄßÔºâ
            const rawValue = dailyVolume7dStdDevValueEl.getAttribute("data-raw-value");
            const volumeStdDevRaw = rawValue ? parseFloat(rawValue) : null;
            
            if (volumeStdDevRaw !== null && volumeStdDevRaw > 0) {
              // ÊâãÁª≠Ë¥πÊî∂ÂÖ•Ê†áÂáÜÂ∑Æ = ÊâãÁª≠Ë¥πÁéá √ó ‰∫§ÊòìÈáèÊ†áÂáÜÂ∑Æ
              feeIncomeStdDev = feeRate * volumeStdDevRaw;
              
              // ËΩ¨Êç¢‰∏∫Áõ∏ÂØπ‰∫éTVLÁöÑÁôæÂàÜÊØîÊ†áÂáÜÂ∑ÆÔºàÂπ¥ÂåñÔºâ
              const currentTvlValueEl = document.getElementById("currentTvlValue");
              if (currentTvlValueEl) {
                const tvlRaw = parseFloat(currentTvlValueEl.getAttribute("data-raw-value"));
                if (tvlRaw && tvlRaw > 0) {
                  // Êó•ÂùáÊâãÁª≠Ë¥πÊî∂ÂÖ•Ê†áÂáÜÂ∑ÆÔºàÁõ∏ÂØπ‰∫éTVLÁöÑÁôæÂàÜÊØîÔºâ
                  const dailyFeeIncomeStdDevPct = feeIncomeStdDev / tvlRaw;
                  // Âπ¥ÂåñÔºö‰πò‰ª•‚àö365
                  feeIncomeStdDev = dailyFeeIncomeStdDevPct * Math.sqrt(365);
                }
              }
            }
          }
        }
      }
      
      // 4. ËÆ°ÁÆóÊÄªÂõûÊä•ÁéáÊ†áÂáÜÂ∑Æ
      // œÉ_R = ‚àö(œÉ_Fee¬≤ + œÉ_IL¬≤ + 2¬∑œÅ¬∑œÉ_Fee¬∑œÉ_IL)
      let totalReturnStdDev = null;
      if (feeIncomeStdDev !== null && ilStdDev !== null && 
          Number.isFinite(feeIncomeStdDev) && Number.isFinite(ilStdDev)) {
        if (correlation !== null && Number.isFinite(correlation)) {
          // ‰ΩøÁî®Áõ∏ÂÖ≥ÊÄßËÆ°ÁÆó
          totalReturnStdDev = Math.sqrt(
            Math.pow(feeIncomeStdDev, 2) + 
            Math.pow(ilStdDev, 2) + 
            2 * correlation * feeIncomeStdDev * ilStdDev
          );
        } else {
          // ÂÅáËÆæÁã¨Á´ãÔºàÁõ∏ÂÖ≥ÊÄß‰∏∫0Ôºâ
          totalReturnStdDev = Math.sqrt(
            Math.pow(feeIncomeStdDev, 2) + 
            Math.pow(ilStdDev, 2)
          );
        }
      }
      
      if (totalReturnStdDev !== null && Number.isFinite(totalReturnStdDev)) {
        totalReturnStdEl.textContent = toPercent(totalReturnStdDev);
      } else {
        totalReturnStdEl.textContent = "‚Äì";
      }
      
      // 5. ËÆ°ÁÆóÂ§èÊôÆÊØîÁéá
      // Sharpe Ratio = (E[R] - R_f) / œÉ_R
      // ‰ΩøÁî®ÈªòËÆ§Êó†È£éÈô©Âà©Áéá 4%ÔºàÂπ¥ÂåñÔºâ
      const riskFreeRate = 0.04; // 4% Âπ¥Âåñ
      let sharpeRatio = null;
      
      if (netApr !== null && Number.isFinite(netApr) && 
          totalReturnStdDev !== null && Number.isFinite(totalReturnStdDev) &&
          totalReturnStdDev > 0) {
        sharpeRatio = (netApr - riskFreeRate) / totalReturnStdDev;
      }
      
      if (sharpeRatio !== null && Number.isFinite(sharpeRatio)) {
        sharpeRatioEl.textContent = toDecimal(sharpeRatio);
        // Ê†πÊçÆÂ§èÊôÆÊØîÁéáÂÄºÂ∫îÁî®È¢úËâ≤
        const sharpeStatContainer = sharpeRatioEl.closest('.stat');
        if (sharpeStatContainer) {
          sharpeStatContainer.classList.remove('glow-green', 'glow-red');
          if (sharpeRatio > 1) {
            sharpeStatContainer.classList.add('glow-green');
          } else if (sharpeRatio < 0) {
            sharpeStatContainer.classList.add('glow-red');
          }
        }
      } else {
        sharpeRatioEl.textContent = "‚Äì";
        const sharpeStatContainer = sharpeRatioEl.closest('.stat');
        if (sharpeStatContainer) {
          sharpeStatContainer.classList.remove('glow-green', 'glow-red');
        }
      }
    }

    function runIlSimulation() {
      const lowerEl = document.getElementById("ilLower");
      const upperEl = document.getElementById("ilUpper");
      const p0El = document.getElementById("ilP0");
      const sigmaDailyEl = document.getElementById("ilSigmaDaily");
      const daysEl = document.getElementById("ilDays");
      const pathsEl = document.getElementById("ilPaths");
      const statusEl = document.getElementById("ilStatus");
      const errorEl = document.getElementById("ilError");

      const expectedEl = document.getElementById("ilExpected");
      const dailyIlEl = document.getElementById("ilDaily");
      const ciEl = document.getElementById("ilCI");
      const stdEl = document.getElementById("ilStd");
      const aprEl = document.getElementById("ilApr");
      const feeBreakEvenEl = document.getElementById("ilFeeBreakEven");

      errorEl.textContent = "";
      statusEl.textContent = t('runningSimulation');
      expectedEl.textContent = "‚Äì";
      if (dailyIlEl) dailyIlEl.textContent = "‚Äì";
      ciEl.textContent = "‚Äì";
      stdEl.textContent = "‚Äì";
      if (aprEl) aprEl.textContent = "‚Äì";
      if (feeBreakEvenEl) {
        feeBreakEvenEl.textContent = "‚Äì";
        // ÁßªÈô§ÂÖâÊôïÊïàÊûú
        const statContainer = feeBreakEvenEl.closest('.stat');
        if (statContainer) {
          statContainer.classList.remove('glow-green', 'glow-red');
        }
      }

      const Pl = Number(lowerEl.value);
      const Pu = Number(upperEl.value);
      const P0 = Number(p0El.value);
      const sigmaDailyPct = Number(sigmaDailyEl.value);
      const days = Number(daysEl.value);
      let paths = Number(pathsEl.value);

      if (!Number.isFinite(Pl) || !Number.isFinite(Pu) || !Number.isFinite(P0)) {
        errorEl.textContent = t('invalidPriceInput');
        statusEl.textContent = "";
        return;
      }
      if (Pl <= 0 || Pu <= 0 || P0 <= 0) {
        errorEl.textContent = t('priceMustBePositive');
        statusEl.textContent = "";
        return;
      }
      if (Pl >= Pu) {
        errorEl.textContent = t('lowerBoundMustBeLess');
        statusEl.textContent = "";
        return;
      }
      if (!Number.isFinite(sigmaDailyPct) || sigmaDailyPct <= 0) {
        errorEl.textContent = t('invalidVolatility');
        statusEl.textContent = "";
        return;
      }
      if (!Number.isFinite(days) || days <= 0) {
        errorEl.textContent = t('daysMustBePositive');
        statusEl.textContent = "";
        return;
      }
      // Ê®°ÊãüÂ§©Êï∞‰∏äÈôê‰∏∫3650
      if (days > 3650) {
        errorEl.textContent = t('daysExceedsLimit');
        statusEl.textContent = "";
        return;
      }
      if (!Number.isFinite(paths) || paths < 100) {
        paths = 1000;
      }
      // Ê®°ÊãüÊ¨°Êï∞‰∏äÈôê‰∏∫1000000ÔºåË∂ÖËøáÂàôÊä•Èîô
      if (paths > 1000000) {
        errorEl.textContent = t('pathsExceedsLimit');
        statusEl.textContent = "";
        return;
      }

      const sigmaDaily = sigmaDailyPct / 100;
      const T = days;

      const L = 1;
      const xy0 = uniswapV3XYForPrice(P0, Pl, Pu, L);
      const x0 = xy0.x;
      const y0 = xy0.y;

      const ils = new Array(paths);
      const mdds = new Array(paths); // Â≠òÂÇ®ÊØèÊù°Ë∑ØÂæÑÁöÑMDD
      // ËÆ°ÁÆóË¶ÅÂ±ïÁ§∫ÁöÑË∑ØÂæÑÊï∞ÈáèÔºöÊ®°ÊãüÊ¨°Êï∞^(1/3)ÔºåÂêë‰∏ãÂèñÊï¥Ôºå‰∏äÈôê‰∏∫100
      const pathsToShow = Math.min(Math.floor(Math.pow(paths, 1/3)), 100);
      // Â±ïÁ§∫Â§©Êï∞‰∏äÈôê‰∏∫365
      const daysToShow = Math.min(days, 365);
      const pathPricesArray = []; // Â≠òÂÇ®Â§öÊù°Ë∑ØÂæÑÁöÑÊØèÊó•‰ª∑Ê†º

      // Ëé∑ÂèñÊó•ÂùáÊâãÁª≠Ë¥πAPRÔºàÁî®‰∫éËÆ°ÁÆóÁ¥ØÁßØÂõûÊä•Ôºâ
      // ‰ºòÂÖà‰ΩøÁî® ilFeeApr ËæìÂÖ•Ê°ÜÁöÑÂÄºÔºåÂ¶ÇÊûúÊ≤°ÊúâÂàô‰ªé feeDisplayStat Ëé∑Âèñ
      let dailyFeeApr = 0;
      const ilFeeAprInput = document.getElementById("ilFeeApr");
      if (ilFeeAprInput && ilFeeAprInput.value !== "" && !isNaN(parseFloat(ilFeeAprInput.value))) {
        const annualFeeApr = parseFloat(ilFeeAprInput.value) / 100; // ËΩ¨Êç¢‰∏∫Â∞èÊï∞ÂΩ¢Âºè
        dailyFeeApr = annualFeeApr / 365; // Êó•ÂùáÊâãÁª≠Ë¥πAPR
      } else {
        const feeDisplayStat = document.getElementById("feeDisplayStat");
        if (feeDisplayStat) {
          const aprValue = feeDisplayStat.getAttribute("data-apr");
          if (aprValue && aprValue !== "") {
            const annualFeeApr = parseFloat(aprValue) / 100; // ËΩ¨Êç¢‰∏∫Â∞èÊï∞ÂΩ¢Âºè
            dailyFeeApr = annualFeeApr / 365; // Êó•ÂùáÊâãÁª≠Ë¥πAPR
          }
        }
      }

      for (let i = 0; i < paths; i++) {
        let currentPrice = P0;
        let cumulativeReturn = 1.0; // ÂàùÂßãÁ¥ØÁßØÂõûÊä•‰∏∫1
        let peak = 1.0; // Â≥∞ÂÄº
        let maxDrawdown = 0; // ÊúÄÂ§ßÂõûÊí§
        
        // ÂØπ‰∫éÂâçpathsToShowÊù°Ë∑ØÂæÑÔºåËÆ∞ÂΩïÊØèÊó•‰ª∑Ê†º
        const shouldRecordPath = i < pathsToShow;
        const pathPrices = shouldRecordPath ? [P0] : null;
        
        // ËÆ°ÁÆóÂàùÂßãHODL‰ª∑ÂÄºÔºà‰Ωú‰∏∫Âü∫ÂáÜÔºâ
        const vHodl0 = x0 * P0 + y0;
        let prevPrice = P0;
        let prevVLp = vHodl0; // ÂàùÂßãLP‰ª∑ÂÄºÁ≠â‰∫éHODL‰ª∑ÂÄº
        
        // ÈÄêÊó•ËÆ°ÁÆó‰ª∑Ê†ºÂèòÂåñÂíåÁ¥ØÁßØÂõûÊä•
        for (let day = 1; day <= days; day++) {
          const z = randnBoxMuller();
          const logP = Math.log(currentPrice) +
            (-0.5 * sigmaDaily * sigmaDaily) * 1 + // ÊØèÂ§©ÁöÑÊó∂Èó¥Ê≠•Èïø‰∏∫1
            sigmaDaily * Math.sqrt(1) * z;
          currentPrice = Math.exp(logP);
          
          // ËÆ°ÁÆóÂΩìÊó•ÁöÑLP‰ª∑ÂÄº
          const xyT = uniswapV3XYForPrice(currentPrice, Pl, Pu, L);
          const xT = xyT.x;
          const yT = xyT.y;
          const vLp = xT * currentPrice + yT;
          
          // ËÆ°ÁÆóÊØèÊó•ÂõûÊä•Ôºö
          // 1. LP‰ª∑ÂÄºÂèòÂåñÔºàËÄÉËôëILÔºâÔºöÁõ∏ÂØπ‰∫éÂâç‰∏ÄÊó•LP‰ª∑ÂÄº
          const lpReturn = vLp / prevVLp;
          // 2. ÊâãÁª≠Ë¥πÊî∂ÂÖ•ÔºöÊØèÊó•ÊâãÁª≠Ë¥πÁõ∏ÂØπ‰∫éÂàùÂßãTVLÁöÑÊØî‰æã
          // ÊâãÁª≠Ë¥πÊòØÂ§çÂà©ÁöÑÔºåÊâÄ‰ª•ÊØèÊó•Â¢ûÈïøÂõ†Â≠ê = 1 + dailyFeeApr
          const feeReturn = 1 + dailyFeeApr;
          // 3. Á¥ØÁßØÂõûÊä• = Á¥ØÁßØÂõûÊä• * LPÂõûÊä• * ÊâãÁª≠Ë¥πÂõûÊä•
          cumulativeReturn = cumulativeReturn * lpReturn * feeReturn;
          
          // Êõ¥Êñ∞Â≥∞ÂÄº
          if (cumulativeReturn > peak) {
            peak = cumulativeReturn;
          }
          
          // ËÆ°ÁÆóÂΩìÂâçÂõûÊí§
          const drawdown = (peak - cumulativeReturn) / peak;
          if (drawdown > maxDrawdown) {
            maxDrawdown = drawdown;
          }
          
          // Êõ¥Êñ∞Ââç‰∏ÄÊó•ÂÄº
          prevPrice = currentPrice;
          prevVLp = vLp;
          
          // Âè™ËÆ∞ÂΩïÂâç365Â§©ÁöÑÊï∞ÊçÆÁî®‰∫éÂõæË°®Â±ïÁ§∫
          if (shouldRecordPath && day <= daysToShow) {
            pathPrices.push(currentPrice);
          }
        }
        
        if (shouldRecordPath) {
          pathPricesArray.push(pathPrices);
        }
        
        // ‰øùÂ≠òÊúÄÁªàILÂíåMDD
        const PT = currentPrice;
        const xyT = uniswapV3XYForPrice(PT, Pl, Pu, L);
        const xT = xyT.x;
        const yT = xyT.y;
        const vHodl = x0 * PT + y0;
        const vLp = xT * PT + yT;
        const il = vLp / vHodl - 1;
        ils[i] = il;
        mdds[i] = maxDrawdown;
      }

      ils.sort((a, b) => a - b);

      const n = ils.length;
      const mean =
        ils.reduce((acc, v) => acc + v, 0) / n;

      let variance = 0;
      for (let i = 0; i < n; i++) {
        const d = ils[i] - mean;
        variance += d * d;
      }
      variance = variance / Math.max(1, n - 1);
      const std = Math.sqrt(variance);

      const idx5 = Math.floor(0.05 * (n - 1));
      const idx95 = Math.floor(0.95 * (n - 1));
      const il5 = ils[idx5];
      const il95 = ils[idx95];

      const toPercent = (x) => (x * 100).toFixed(3) + " %";

      expectedEl.textContent = toPercent(mean);
      
      // ËÆ°ÁÆóÊó•Âùá IL = È¢ÑÊúü IL / Ê®°ÊãüÂ§©Êï∞
      // mean ÊòØÂ∞èÊï∞ÂΩ¢ÂºèÔºà‰æãÂ¶Ç -0.025 Ë°®Á§∫ -2.5%Ôºâ
      const dailyIl = mean / days;
      if (dailyIlEl) {
        dailyIlEl.textContent = toPercent(dailyIl);
      }
      
      ciEl.textContent = `${toPercent(il5)}  ~  ${toPercent(il95)}`;
      stdEl.textContent = toPercent(std);
      // ‰øùÂ≠òILÊ†áÂáÜÂ∑ÆÁöÑÂéüÂßãÂÄºÔºàÂ∞èÊï∞ÂΩ¢ÂºèÔºâÂà∞dataÂ±ûÊÄßÔºåÁî®‰∫éÈ£éÈô©ÊåáÊ†áËÆ°ÁÆó
      stdEl.setAttribute("data-raw-value", std.toString());

      // ËÆ°ÁÆóÁ≠âÊïà IL APRÔºöÂ∞Ü IL Âπ¥Âåñ
      // Á≠âÊïà APR = (mean / days) * 365ÔºàÂ∞èÊï∞ÂΩ¢ÂºèÔºå‰æãÂ¶Ç -0.30417 Ë°®Á§∫ -30.417%Ôºâ
      const equivalentIlApr = (mean / days) * 365;
      if (aprEl) {
        aprEl.textContent = toPercent(equivalentIlApr);
      }

      // ËÆ°ÁÆó Net APRÔºö‰ΩøÁî®Êó•ÂùáILÂíåÊó•ÂùáÊâãÁª≠Ë¥πÊî∂ÂÖ•apr
      updateNetApr(dailyIl, days);
      
      // ËÆ°ÁÆó95% worst-case MDD
      mdds.sort((a, b) => a - b); // ÊåâÂçáÂ∫èÊéíÂ∫è
      const idx95Mdd = Math.floor(0.95 * (mdds.length - 1));
      const worstCaseMdd = mdds[idx95Mdd];
      
      const worstCaseMddEl = document.getElementById("worstCaseMdd");
      if (worstCaseMddEl) {
        worstCaseMddEl.textContent = toPercent(worstCaseMdd);
      }

      const minIl = ils[0];
      const maxIl = ils[n - 1];
      let lo = minIl;
      let hi = maxIl;
      if (hi - lo < 1e-6) {
        lo -= 0.0005;
        hi += 0.0005;
      }

      const binCount = 30;
      const binSize = (hi - lo) / binCount;
      const counts = new Array(binCount).fill(0);
      const labels = new Array(binCount);

      for (let i = 0; i < binCount; i++) {
        const mid = lo + (i + 0.5) * binSize;
        labels[i] = (mid * 100).toFixed(2) + "%";
      }

      for (let i = 0; i < n; i++) {
        let idx = Math.floor((ils[i] - lo) / binSize);
        if (idx < 0) idx = 0;
        if (idx >= binCount) idx = binCount - 1;
        counts[idx] += 1;
      }

      buildIlDistributionChart(labels, counts);

      // ÁªòÂà∂Â§öÊù°Ê®°ÊãüË∑ØÂæÑÁöÑ‰ª∑Ê†ºË∑ØÂæÑÂõæ
      if (pathPricesArray && pathPricesArray.length > 0) {
        const daysToShow = Math.min(days, 365);
        const dayLabels = Array.from({ length: daysToShow + 1 }, (_, i) => i.toString());
        // Á°Æ‰øùÊØèÊù°Ë∑ØÂæÑÊï∞ÊçÆÂè™ÂåÖÂê´Ââç365Â§©ÁöÑÊï∞ÊçÆ
        const trimmedPathPricesArray = pathPricesArray.map(prices => 
          prices.slice(0, daysToShow + 1)
        );
        // Store data for toggle functionality
        window.monteCarloPathData = {
          dayLabels,
          pathPricesArray: trimmedPathPricesArray,
          currentPrice: P0,
          sigmaDailyPct,
          days: daysToShow,
          Pl,
          Pu
        };
        buildMonteCarloPathChart(dayLabels, trimmedPathPricesArray, P0, sigmaDailyPct, daysToShow, Pl, Pu);
      }

      statusEl.textContent = t('simulationDone', { paths, days, sigma: sigmaDailyPct });
    }

    const runIlBtn = document.getElementById("runIlBtn");
    if (runIlBtn) {
      runIlBtn.addEventListener("click", runIlSimulation);
    }

    // Monte Carlo axis toggle button
    const monteCarloAxisToggle = document.getElementById("monteCarloAxisToggle");
    if (monteCarloAxisToggle) {
      monteCarloAxisToggle.addEventListener("click", toggleMonteCarloAxisMode);
    }

    // ÂéÜÂè≤Ê≥¢Âä®ÁéáËÆ°ÁÆóÊåâÈíÆ‰∫ã‰ª∂
    const calcHvBtn0 = document.getElementById("calcHvBtn0");
    if (calcHvBtn0) {
      calcHvBtn0.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        calculateAndFillHv('token0');
      });
    }

    const calcHvBtn1 = document.getElementById("calcHvBtn1");
    if (calcHvBtn1) {
      calcHvBtn1.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        calculateAndFillHv('token1');
      });
    }

    const calcRatioVolBtn = document.getElementById("calcRatioVolBtn");
    if (calcRatioVolBtn) {
      calcRatioVolBtn.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        calculateAndFillRatioVolatility();
      });
    }

    // Â§©Êï∞Âø´ÈÄüÈÄâÊã©ÊåâÈíÆ‰∫ã‰ª∂
    const daysQuickBtns = document.querySelectorAll(".days-quick-btn");
    daysQuickBtns.forEach(btn => {
      btn.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        const days = parseInt(btn.getAttribute("data-days"));
        const daysEl = document.getElementById("ilDays");
        if (daysEl && !isNaN(days) && days > 0) {
          daysEl.value = days;
          // Ëß¶Âèëinput‰∫ã‰ª∂ÔºåÁ°Æ‰øùUIÊõ¥Êñ∞
          daysEl.dispatchEvent(new Event('input', { bubbles: true }));
        }
      });
    });

    // ÂàùÂßãÊÉÖÂÜµ‰∏ãÂ∞±ËøêË°åÊ®°ÊãüÔºå‰ΩøÁî®ÈªòËÆ§ÂèÇÊï∞
    window.addEventListener("load", () => {
      setTimeout(() => {
        runIlSimulation();
      }, 1000); // Âª∂Ëøü1ÁßíÁ°Æ‰øùDOMÂíåÂõæË°®Â∫ìÂÆåÂÖ®Âä†ËΩΩ
    });
  </script>
</body>
</html>
