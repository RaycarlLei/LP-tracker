<!DOCTYPE html>
<html id="htmlLang" lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Is a Liquidity Pool Worth Investing In? - Solana æµåŠ¨æ€§æ± è¿½è¸ªå·¥å…·</title>
  <!-- Chart.js for charts -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    :root {
      color-scheme: dark;
      --bg: #020617;
      --bg-elevated: rgba(15, 23, 42, 0.98);
      --border-subtle: rgba(148, 163, 184, 0.22);
      --accent: #49e55e;
      --accent-soft: rgba(16, 229, 94, 0.18);
      --text-main: #e5e7eb;
      --text-muted: #94a3b8;
      --danger: #f97373;
      --radius-lg: 14px;
      --radius-md: 10px;
      --shadow-soft: 0 22px 60px rgba(15, 23, 42, 0.85);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 32px 16px 40px;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background:
        radial-gradient(circle at top, #1f2937 0, #020617 55%, #000 100%);
      color: var(--text-main);
    }

    .main {
      width: 100%;
      max-width: 960px;
    }

    .page-header {
      margin-bottom: 18px;
    }

    .page-title-row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 10px;
      margin-bottom: 6px;
    }

    h1 {
      font-size: 26px;
      letter-spacing: 0.02em;
      margin: 0;
    }

    .pill {
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 11px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      border: 1px solid rgba(148, 163, 184, 0.28);
      color: var(--text-muted);
      background: rgba(15, 23, 42, 0.75);
    }

    .tagline {
      margin: 0;
      font-size: 13px;
      color: var(--text-muted);
    }

    .small {
      font-size: 12px;
      color: var(--text-muted);
    }

    .card {
      border-radius: var(--radius-lg);
      padding: 18px 20px;
      margin-top: 18px;
      background:
        linear-gradient(145deg, rgba(15, 23, 42, 0.96), rgba(12, 18, 33, 0.96));
      border: 1px solid var(--border-subtle);
      box-shadow: var(--shadow-soft);
      backdrop-filter: blur(18px);
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      gap: 8px;
    }

    .card-title {
      font-size: 15px;
      font-weight: 600;
    }

    .badge {
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 999px;
      background: rgba(15, 118, 110, 0.15);
      border: 1px solid rgba(45, 212, 191, 0.4);
      color: #a5f3fc;
    }

    label {
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
      font-size: 13px;
      color: var(--text-muted);
    }

    .input-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    input {
      flex: 1 1 260px;
      min-width: 0;
      padding: 9px 11px;
      border-radius: var(--radius-md);
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(15, 23, 42, 0.9);
      color: var(--text-main);
      font-size: 13px;
      outline: none;
      transition: border-color 0.16s ease, box-shadow 0.16s ease, background-color 0.16s ease;
    }

    input::placeholder {
      color: rgba(148, 163, 184, 0.7);
    }

    input:focus {
      border-color: rgba(34, 197, 94, 0.8);
      box-shadow: 0 0 0 1px rgba(34, 197, 94, 0.55);
      background: rgba(15, 23, 42, 1);
    }

    button {
      padding: 9px 16px;
      cursor: pointer;
      border-radius: var(--radius-md);
      border: 1px solid rgba(34, 197, 94, 0.25);
      background: rgba(34, 197, 94, 0.12);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      color: var(--text-main);
      font-weight: 500;
      font-size: 13px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      box-shadow: 0 4px 12px rgba(15, 23, 42, 0.4), inset 0 1px 0 rgba(34, 197, 94, 0.15);
      transition: background-color 0.16s ease, transform 0.08s ease, box-shadow 0.16s ease, border-color 0.16s ease;
      white-space: nowrap;
    }

    button:hover {
      background: rgba(34, 197, 94, 0.18);
      border-color: rgba(34, 197, 94, 0.35);
      transform: translateY(-1px);
      box-shadow: 0 6px 16px rgba(15, 23, 42, 0.5), inset 0 1px 0 rgba(34, 197, 94, 0.2);
    }

    button:active {
      transform: translateY(0);
      background: rgba(34, 197, 94, 0.15);
      box-shadow: 0 2px 8px rgba(15, 23, 42, 0.3), inset 0 1px 0 rgba(34, 197, 94, 0.15);
    }

    button:disabled {
      opacity: 0.5;
      cursor: default;
      box-shadow: none;
      background: rgba(34, 197, 94, 0.08);
    }

    .button-icon {
      width: 14px;
      height: 14px;
      border-radius: 999px;
      border: 1px solid rgba(34, 197, 94, 0.3);
      background: rgba(34, 197, 94, 0.25);
      backdrop-filter: blur(4px);
      -webkit-backdrop-filter: blur(4px);
    }

    .days-quick-btn,
    .vol-quick-btn {
      padding: 3px 8px;
      font-size: 9px;
      min-width: auto;
      height: auto;
      border-radius: 6px;
      background: rgba(34, 197, 94, 0.12);
      border: 1px solid rgba(34, 197, 94, 0.25);
      color: var(--accent);
      cursor: pointer;
      transition: all 0.2s ease;
      font-weight: 500;
      white-space: nowrap;
    }

    .days-quick-btn:hover,
    .vol-quick-btn:hover {
      background: rgba(34, 197, 94, 0.22);
      border-color: rgba(34, 197, 94, 0.4);
      transform: translateY(-1px);
    }

    .days-quick-btn:active,
    .vol-quick-btn:active {
      transform: translateY(0);
      background: rgba(34, 197, 94, 0.18);
    }

    .run-simulation-btn {
      padding: 10px 18px !important;
      font-size: 13px !important;
      font-weight: 600 !important;
      background: linear-gradient(135deg, rgba(34, 197, 94, 0.25), rgba(16, 185, 129, 0.2)) !important;
      border: 2px solid rgba(34, 197, 94, 0.5) !important;
      box-shadow: 
        0 6px 20px rgba(34, 197, 94, 0.3),
        0 0 0 1px rgba(34, 197, 94, 0.2),
        inset 0 1px 0 rgba(255, 255, 255, 0.1) !important;
      gap: 6px !important;
      position: relative;
      overflow: hidden;
    }

    .run-simulation-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
      transition: left 0.5s ease;
    }

    .run-simulation-btn:hover::before {
      left: 100%;
    }

    .run-simulation-btn:hover {
      background: linear-gradient(135deg, rgba(34, 197, 94, 0.35), rgba(16, 185, 129, 0.3)) !important;
      border-color: rgba(34, 197, 94, 0.7) !important;
      transform: translateY(-2px) !important;
      box-shadow: 
        0 8px 28px rgba(34, 197, 94, 0.4),
        0 0 0 1px rgba(34, 197, 94, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.15) !important;
    }

    .run-simulation-btn:active {
      transform: translateY(0) !important;
      box-shadow: 
        0 4px 16px rgba(34, 197, 94, 0.25),
        0 0 0 1px rgba(34, 197, 94, 0.2),
        inset 0 1px 0 rgba(255, 255, 255, 0.1) !important;
    }

    .play-icon {
      font-size: 14px;
      line-height: 1;
      color: rgba(34, 197, 94, 1);
      text-shadow: 0 0 8px rgba(34, 197, 94, 0.6);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 18px;
      height: 18px;
      background: rgba(34, 197, 94, 0.2);
      border-radius: 50%;
      border: 1px solid rgba(34, 197, 94, 0.4);
    }

    .loading-text {
      min-height: 16px;
    }

    .error {
      color: var(--danger);
      margin-top: 8px;
      font-size: 12px;
    }

    .results-card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }

    .results-title {
      font-size: 16px;
      font-weight: 600;
    }

    .muted-label {
      font-size: 11px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.12em;
    }

    .stat-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(210px, 1fr));
      gap: 10px 18px;
      margin-bottom: 10px;
    }

    .stat {
      padding: 8px 10px;
      border-radius: 10px;
      background: radial-gradient(circle at top left, rgba(34, 197, 94, 0.06), transparent 55%);
      border: 1px solid rgba(148, 163, 184, 0.26);
    }

    .stat-label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      color: var(--text-muted);
      margin-bottom: 4px;
    }

    .clickable-stat .stat-label {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
    }

    .stat-value {
      font-size: 13px;
      font-weight: 500;
      color: var(--text-main);
      word-break: break-all;
    }

    .clickable-stat {
      cursor: pointer;
      transition: background-color 0.2s ease, border-color 0.2s ease, transform 0.1s ease;
      user-select: none;
    }

    .clickable-stat:hover {
      background: radial-gradient(circle at top left, rgba(34, 197, 94, 0.12), transparent 55%);
      border-color: rgba(34, 197, 94, 0.4);
      transform: translateY(-1px);
    }

    .clickable-stat:active {
      transform: translateY(0);
      background: radial-gradient(circle at top left, rgba(34, 197, 94, 0.08), transparent 55%);
    }

    .swap-icon {
      font-size: 14px;
      color: var(--accent);
      opacity: 0.7;
      transition: transform 0.3s ease, opacity 0.2s ease;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 18px;
      height: 18px;
      border-radius: 4px;
      background: rgba(34, 197, 94, 0.1);
      border: 1px solid rgba(34, 197, 94, 0.2);
    }

    .clickable-stat:hover .swap-icon {
      opacity: 1;
      transform: rotate(180deg);
      background: rgba(34, 197, 94, 0.2);
      border-color: rgba(34, 197, 94, 0.4);
    }

    pre {
      font-size: 11px;
      white-space: pre-wrap;
      word-wrap: break-word;
      background: rgba(15, 23, 42, 0.96);
      border-radius: 12px;
      padding: 10px 12px;
      max-height: 320px;
      overflow: auto;
      border: 1px solid rgba(30, 64, 175, 0.5);
      box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.8);
    }

    code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono",
        "Courier New", monospace;
      font-size: 11px;
      color: #a5b4fc;
    }

    /* chart card */
    .chart-container {
      margin-top: 16px;
    }

    .range-control {
      margin: 12px 0 6px;
      padding: 12px 14px 14px;
      border-radius: 14px;
      border: 1px solid rgba(34, 197, 94, 0.25);
      background:
        linear-gradient(135deg, rgba(15, 118, 110, 0.15), rgba(34, 197, 94, 0.05)),
        rgba(15, 23, 42, 0.85);
      box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.45), 0 10px 25px rgba(15, 23, 42, 0.5);
    }

    .range-meta {
      display: flex;
      justify-content: space-between;
      font-size: 10px;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: rgba(226, 232, 240, 0.75);
    }

    #daysRange {
      width: 100%;
      appearance: none;
      -webkit-appearance: none;
      margin-top: 12px;
      height: 6px;
      background: transparent;
      cursor: pointer;
    }

    #daysRange::-webkit-slider-runnable-track {
      height: 6px;
      border-radius: 999px;
      background:
        linear-gradient(90deg, rgba(16, 185, 129, 0.15), rgba(16, 185, 129, 0.8));
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.08);
    }

    #daysRange::-moz-range-track {
      height: 6px;
      border-radius: 999px;
      background:
        linear-gradient(90deg, rgba(16, 185, 129, 0.15), rgba(16, 185, 129, 0.8));
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.08);
    }

    #daysRange::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      border: 2px solid rgba(15, 23, 42, 0.95);
      background:
        radial-gradient(circle at 30% 30%, rgba(34, 197, 94, 0.4), #216e3e, #15803d);
      box-shadow: 0 4px 12px rgba(21, 128, 61, 0.35), inset 0 1px 0 rgba(34, 197, 94, 0.2);
      margin-top: -7px;
      transition: box-shadow 0.2s ease;
    }

    #daysRange::-webkit-slider-thumb:hover {
      box-shadow: 0 5px 16px rgba(21, 128, 61, 0.45), inset 0 1px 0 rgba(34, 197, 94, 0.3);
    }

    #daysRange::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      border: 2px solid rgba(15, 23, 42, 0.95);
      background:
        radial-gradient(circle at 30% 30%, rgba(34, 197, 94, 0.4), #136e34, #15803d);
      box-shadow: 0 4px 12px rgba(21, 128, 61, 0.35), inset 0 1px 0 rgba(34, 197, 94, 0.2);
      transition: box-shadow 0.2s ease;
    }

    #daysRange::-moz-range-thumb:hover {
      box-shadow: 0 5px 16px rgba(21, 128, 61, 0.45), inset 0 1px 0 rgba(34, 197, 94, 0.3);
    }

    #daysRange:focus-visible {
      outline: none;
      box-shadow: 0 0 0 2px rgba(34, 197, 94, 0.4);
    }

    .chart-wrapper {
      position: relative;
      width: 100%;
      height: 260px;
      margin-top: 10px;
      border-radius: 12px;
      background: radial-gradient(circle at top left, rgba(34, 197, 94, 0.06), rgba(15, 23, 42, 0.96));
      border: 1px solid rgba(148, 163, 184, 0.3);
      padding: 10px 12px 12px;
    }

    .chart-legend {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 8px;
      font-size: 11px;
      color: var(--text-muted);
    }

    .chart-legend-item {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      transition: opacity 0.2s ease;
    }

    .chart-legend-item:hover {
      opacity: 0.8;
    }

    .chart-legend-item.legend-hidden {
      opacity: 0.4;
    }

    .chart-legend-item.legend-hidden .legend-dot {
      opacity: 0.4;
    }

    .chart-legend-item.legend-hidden span:not(.legend-dot) {
      text-decoration: line-through;
    }

    .legend-dot {
      width: 10px;
      height: 10px;
      border-radius: 999px;
    }

    .collapsible-section {
      margin-bottom: 6px;
    }

    .collapsible-header {
      cursor: pointer;
      display: flex;
      align-items: center;
      padding: 4px 0;
      user-select: none;
      transition: opacity 0.2s ease;
    }

    .collapsible-header:hover {
      opacity: 0.8;
    }

    .collapsible-arrow {
      display: inline-block;
      font-size: 10px;
      color: var(--text-muted);
      transition: transform 0.2s ease;
      width: 12px;
      text-align: center;
    }

    .collapsible-content {
      margin-top: 8px;
      animation: fadeIn 0.2s ease;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }

    /* Popular pools selection bar */
    .popular-pools-container {
      margin-bottom: 12px;
      overflow: hidden;
      position: relative;
      padding: 8px 0;
      mask-image: linear-gradient(to right, transparent 0%, black 5%, black 95%, transparent 100%);
      -webkit-mask-image: linear-gradient(to right, transparent 0%, black 5%, black 95%, transparent 100%);
    }

    .popular-pools-scroll {
      display: flex;
      gap: 8px;
      animation: scrollHorizontal 40s linear infinite;
      width: fit-content;
    }

    .popular-pools-scroll:hover {
      animation-play-state: paused;
    }

    @keyframes scrollHorizontal {
      0% {
        transform: translateX(0);
      }
      100% {
        transform: translateX(-50%);
      }
    }

    .popular-pool-item {
      padding: 6px 12px;
      border-radius: var(--radius-md);
      border: 1px solid rgba(148, 163, 184, 0.3);
      background: rgba(15, 23, 42, 0.6);
      color: var(--text-main);
      font-size: 12px;
      cursor: pointer;
      white-space: nowrap;
      transition: all 0.2s ease;
      user-select: none;
      flex-shrink: 0;
    }

    .popular-pool-item:hover {
      background: rgba(34, 197, 94, 0.15);
      border-color: rgba(34, 197, 94, 0.4);
      transform: translateY(-1px);
    }

    .popular-pool-item:active {
      transform: translateY(0);
      background: rgba(34, 197, 94, 0.2);
    }

    .popular-pools-scroll::after {
      content: '';
      position: absolute;
      top: 0;
      right: 0;
      width: 40px;
      height: 100%;
      background: linear-gradient(to right, transparent, rgba(15, 23, 42, 0.95));
      pointer-events: none;
      z-index: 1;
    }

    /* Language switcher button */
    .lang-switcher {
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.28);
      background: rgba(15, 23, 42, 0.75);
      color: var(--text-muted);
      font-size: 11px;
      letter-spacing: 0.08em;
      font-weight: 500;
      cursor: pointer;
      transition: background-color 0.2s ease, border-color 0.2s ease, transform 0.1s ease;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      user-select: none;
    }

    .lang-switcher:hover {
      background: radial-gradient(circle at top left, rgba(34, 197, 94, 0.12), transparent 55%);
      border-color: rgba(34, 197, 94, 0.4);
      transform: translateY(-1px);
      color: var(--text-main);
    }

    .lang-switcher:active {
      transform: translateY(0);
      background: radial-gradient(circle at top left, rgba(34, 197, 94, 0.08), transparent 55%);
    }

    .lang-switcher-icon {
      font-size: 11px;
      opacity: 0.7;
      transition: transform 0.3s ease, opacity 0.2s ease;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .lang-switcher:hover .lang-switcher-icon {
      opacity: 1;
      transform: rotate(180deg);
    }

    @media (max-width: 640px) {
      body {
        padding-top: 22px;
      }

      .lang-switcher {
        padding: 4px 10px;
        font-size: 11px;
      }

      .card {
        padding: 16px 14px;
      }

      h1 {
        font-size: 22px;
      }

      button {
        width: 100%;
        justify-content: center;
      }

      .chart-wrapper {
        height: 240px;
      }
    }
  </style>
</head>
<body>
  <main class="main">
    <header class="page-header">
      <div class="page-title-row">
        <h1 id="pageTitle">Liquidity Pool ToolBox</h1>
        <span class="pill">Solana Liquidity Pool ToolBox</span>
      </div>
      <div class="page-title-row">
        <button class="lang-switcher" id="langSwitcher" title="Switch Language / åˆ‡æ¢è¯­è¨€">
          <span class="lang-switcher-icon">ğŸŒ</span>
          <span id="langSwitcherText">EN</span>
        </button>
      </div>
      <p class="tagline">
        <code id="pageTagline">Live Pool Metrics and Impermanent Loss Calculator</code>
      </p>
    </header>

    <div class="card">
      <div class="card-header">
        <div class="card-title" id="poolIdTitle">Pool ID</div>
        <span class="badge" id="geckoBadge">Popular Liquidity Pools</span>
      </div>

      <div class="popular-pools-container">
        <div class="popular-pools-scroll" id="popularPoolsScroll">
          <!-- Popular pools will be duplicated for seamless loop -->
        </div>
      </div>

      <label for="poolId" id="poolIdLabel">Paste any Solana pool address to inspect its stats.</label>
      <div class="input-row">
        <input
          id="poolId"
          type="text"
          value="DJNtGuBGEQiUCWE8F981M2C3ZghZt2XLD8f2sQdZ6rsZ"
          placeholder="DJNtGuBGEQiUCWE8F981M2C3ZghZt2XLD8f2sQdZ6rsZ"
        />
        <button id="loadBtn">
          <span class="button-icon"></span>
          <span id="loadBtnText">Load Pool</span>
        </button>
      </div>
      <div style="margin-top: 10px;">
        <button 
          id="toggleCustomKeyBtn" 
          type="button"
          style="padding: 0; margin: 0; border: none; background: transparent; box-shadow: none; outline: none; cursor: pointer;"
        >
          <span id="toggleCustomKeyText" style="color: rgba(148, 163, 184, 0.4); font-size: 10px; font-family: monospace;">api_key_config</span>
          <span id="toggleCustomKeyArrow" style="margin-left: 6px; color: rgba(148, 163, 184, 0.4); font-size: 10px;">â–¼</span>
        </button>
        <div id="customKeySection" style="display: none; margin-top: 8px;">
          <div class="input-row">
          <input
            id="birdeyeApiKey"
            type="password"
            placeholder="Enter your Birdeye API Key"
            autocomplete="off"
          />
          <button id="toggleKeyVisibilityBtn" type="button" title="Show/Hide API Key" style="padding: 9px 12px;">
            ğŸ‘ï¸
          </button>
          <button id="checkBirdeyeKeyBtn">
            <span class="button-icon"></span>
            <span id="checkKeyBtnText">Check Key</span>
          </button>
          </div>
          <div class="small" id="birdeyeStatus" style="margin-top: 4px; opacity: 0.9;"></div>

        </div>
        <div class="small" id="defaultKeyNote" style="margin-top: 6px; opacity: 0.8; color: var(--text-muted);">
          Default uses built-in API Key. To use your own Key, please click the button above.
        </div>
      </div>
      <div class="small loading-text" id="loading"></div>
      <div id="error" class="error"></div>
    </div>

    <div id="results" class="card" style="display:none;">
      <div class="results-card-header">
        <div>
          <div class="results-title" id="resultsTitle">Parsed Pool Data</div>
          <div class="muted-label" id="keyMetricsLabel">Key metrics</div>
        </div>
        <div class="muted-label" id="liveFromLabel">Live from GeckoTerminal</div>
      </div>
      <div id="poolInfo"></div>

      <!-- chart area -->
      <div class="chart-container">
        <div class="muted-label">
          <span id="lastDaysLabel">Last</span> <span id="daysLabel">30</span> <span id="daysLabelSuffix">Days Liquidity & Volume</span>
        </div>
        <div class="small" id="tvlLineNote">
          TVL line uses current liquidity as an approximate level, daily volume from OHLCV candles.
        </div>

        <div class="range-control">
          <div class="range-meta">
            <span id="lookbackWindowLabel">Lookback window</span>
            <span></span>
          </div>
          <input
            id="daysRange"
            type="range"
            min="2"
            max="180"
            step="1"
            value="30"
          />
        </div>

        <div class="chart-wrapper">
          <canvas id="tvlVolumeChart"></canvas>
        </div>
        <div class="chart-legend">
          <div class="chart-legend-item" id="tvlLegend">
            <span class="legend-dot" style="background: #1d5331;"></span>
            <span>TVL (USD)</span>
          </div>
          <div class="chart-legend-item" id="volumeLegend">
            <span class="legend-dot" style="background: rgba(148, 163, 184, 0.9);"></span>
            <span>Daily Volume (USD)</span>
          </div>
          <div class="chart-legend-item" id="token0HighLegend">
            <span class="legend-dot" style="background: rgba(250, 204, 21, 0.9);"></span>
            <span id="token0HighLabel">High Price</span>
          </div>
          <div class="chart-legend-item" id="token0LowLegend">
            <span class="legend-dot" style="background: rgba(248, 113, 113, 0.9);"></span>
            <span id="token0LowLabel">Low Price</span>
          </div>
          <div class="chart-legend-item" id="token1HighLegend">
            <span class="legend-dot" style="background: rgba(59, 130, 246, 0.9);"></span>
            <span id="token1HighLabel">High Price</span>
          </div>
          <div class="chart-legend-item" id="token1LowLegend">
            <span class="legend-dot" style="background: rgba(139, 92, 246, 0.9);"></span>
            <span id="token1LowLabel">Low Price</span>
          </div>
        </div>
      </div>

      <div class="collapsible-section" style="margin-top: 14px;">
        <div class="collapsible-header" onclick="toggleCollapsible('rawJsonSection')">
          <span class="collapsible-arrow" id="rawJsonArrow">â–¶</span>
          <span class="muted-label" id="rawGeckoLabel" style="margin-left: 6px;">Raw GeckoTerminal Response</span>
          <span class="small" id="rawGeckoDesc" style="margin-left: 8px; opacity: 0.7;">Full JSON payload from GeckoTerminal pool snapshot API.</span>
        </div>
        <div class="collapsible-content" id="rawJsonSection" style="display: none;">
          <pre id="rawJson"></pre>
        </div>
      </div>

      <div class="collapsible-section" style="margin-top: 10px;">
        <div class="collapsible-header" onclick="toggleCollapsible('birdeyeRawJsonSection')">
          <span class="collapsible-arrow" id="birdeyeRawJsonArrow">â–¶</span>
          <span class="muted-label" id="rawBirdeyeLabel" style="margin-left: 6px;">Raw Birdeye OHLCV Response</span>
          <span class="small" id="rawBirdeyeDesc" style="margin-left: 8px; opacity: 0.7;">Full JSON payload from Birdeye OHLCV API (if available).</span>
        </div>
        <div class="collapsible-content" id="birdeyeRawJsonSection" style="display: none;">
          <pre id="birdeyeRawJson"></pre>
        </div>
      </div>
    </div>

    <!-- Impermanent Loss Simulator -->
    <div class="card" id="ilSimulatorCard" style="margin-top: 20px;">
      <div class="card-header">
        <div>
          <div class="card-title" id="ilSimulatorTitle">Impermanent Loss Simulator</div>
          <div class="muted-label" id="ilSimulatorSubtitle">PancakeSwap V3 Â· SOL / USDC Â· Monte Carlo</div>
        </div>
        <span class="badge">IL Â· Distribution Â· CI</span>
      </div>

      <p class="small" id="ilSimulatorDesc" style="margin-bottom: 10px;">
        Enter the concentrated liquidity range, current price, daily volatility, and time period. Use geometric Brownian motion to perform Monte Carlo simulation on future prices, estimating expected IL, distribution, and confidence intervals.
      </p>

      <!-- Input Area -->
      <div class="stat-grid" style="margin-bottom: 8px;">
        <div class="stat">
          <div class="stat-label">Price lower bound</div>
          <input
            id="ilLower"
            type="number"
            step="0.0001"
            placeholder="e.g. 100"
            value="0.8"
          />
          <div style="display: flex; gap: 4px; margin-top: 4px; flex-wrap: wrap;">
            <button 
              type="button"
              class="vol-quick-btn"
              onclick="setLowerBound(-0.05)"
              title="Set lower bound to Current price Ã— (1 - 0.05%)"
            >
              -0.05%
            </button>
            <button 
              type="button"
              class="vol-quick-btn"
              onclick="setLowerBound(-1)"
              title="Set lower bound to Current price Ã— (1 - 1%)"
            >
              -1%
            </button>
            <button 
              type="button"
              class="vol-quick-btn"
              onclick="setLowerBound(-20)"
              title="Set lower bound to Current price Ã— (1 - 20%)"
            >
              -20%
            </button>
            <button 
              type="button"
              class="vol-quick-btn"
              onclick="setLowerBound(-99.9)"
              title="Set lower bound to Current price Ã— (1 - 99.9%)"
            >
              -99.9%
            </button>
          </div>
        </div>
        <div class="stat">
          <div class="stat-label">Price upper bound</div>
          <input
            id="ilUpper"
            type="number"
            step="0.0001"
            placeholder="e.g. 200"
            value="1.2"
          />
          <div style="display: flex; gap: 4px; margin-top: 4px; flex-wrap: wrap;">
            <button 
              type="button"
              class="vol-quick-btn"
              onclick="setUpperBound(0.05)"
              title="Set upper bound to Current price Ã— (1 + 0.05%)"
            >
              +0.05%
            </button>
            <button 
              type="button"
              class="vol-quick-btn"
              onclick="setUpperBound(1)"
              title="Set upper bound to Current price Ã— (1 + 1%)"
            >
              +1%
            </button>
            <button 
              type="button"
              class="vol-quick-btn"
              onclick="setUpperBound(20)"
              title="Set upper bound to Current price Ã— (1 + 20%)"
            >
              +20%
            </button>
            <button 
              type="button"
              class="vol-quick-btn"
              onclick="setUpperBound(99.9)"
              title="Set upper bound to Current price Ã— (1 + 99.9%)"
            >
              +99.9%
            </button>
          </div>
        </div>
        <div class="stat">
          <div class="stat-label">Current price (Pâ‚€)</div>
          <input
            id="ilP0"
            type="number"
            step="0.0001"
            placeholder="e.g. 130"
            value="1"
          />
        </div>
      </div>

      <div class="stat-grid" style="margin-bottom: 4px;">
        <div class="stat">
          <div class="stat-label">
            <span>Daily volatility (percent)</span>
          </div>
          <input
            id="ilSigmaDaily"
            type="number"
            step="0.01"
            placeholder="e.g. 7.26 means 7.26%"
            value="7.26"
          />
          <div style="display: flex; gap: 4px; margin-top: 4px; flex-wrap: wrap;">
            <button 
              id="calcHvBtn0" 
              type="button"
              class="vol-quick-btn"
              title="Calculate historical volatility for token0 from loaded price data"
              style="display: none;"
            >
              ğŸ“Š HV
            </button>
            <button 
              id="calcHvBtn1" 
              type="button"
              class="vol-quick-btn"
              title="Calculate historical volatility for token1 from loaded price data"
              style="display: none;"
            >
              ğŸ“Š HV
            </button>
            <button 
              id="calcRatioVolBtn" 
              type="button"
              class="vol-quick-btn"
              title="Calculate price ratio volatility from token0 and token1 HV and correlation"
              style="display: none;"
            >
              <span id="ratioVolatilityBtnText">Ratio Volatility</span>
            </button>
          </div>
          <div class="small" id="hvInfo" style="margin-top: 4px; opacity: 0.7; font-size: 10px;"></div>
        </div>
        <div class="stat">
          <div class="stat-label">
            <span>simulation days</span>
          </div>
          <input
            id="ilDays"
            type="number"
            step="1"
            min="1"
            placeholder="Forecast days, e.g. 30"
            value="30"
          />
          <div style="display: flex; gap: 4px; margin-top: 4px; flex-wrap: wrap;">
            <button 
              class="days-quick-btn"
              data-days="1"
              type="button"
              title="Set to 1 day"
            >
              1d
            </button>
            <button 
              class="days-quick-btn"
              data-days="7"
              type="button"
              title="Set to 7 days"
            >
              7d
            </button>
            <button 
              class="days-quick-btn"
              data-days="30"
              type="button"
              title="Set to 30 days"
            >
              30d
            </button>
            <button 
              class="days-quick-btn"
              data-days="365"
              type="button"
              title="Set to 365 days"
            >
              365d
            </button>
          </div>
        </div>
        <div class="stat">
          <div class="stat-label">Number of simulations</div>
          <input
            id="ilPaths"
            type="number"
            step="1000"
            min="1000"
            placeholder="Number of simulations, default 1000"
            value="1000"
          />
        </div>
      </div>

      <div style="margin-top: 6px; margin-bottom: 4px; display: flex; flex-direction: column; align-items: center; gap: 8px;">
        <button id="runIlBtn" class="run-simulation-btn">
          <span class="play-icon">â–¶</span>
          <span id="runSimulationText">Run Simulation</span>
        </button>
        <span class="small" id="ilStatus"></span>
      </div>
      <div class="error" id="ilError"></div>

      <!-- Output Overview -->
      <div style="margin-top: 12px;">
        <div class="muted-label" id="simulationResultsLabel" style="margin-bottom: 4px;">Simulation results</div>
        <div class="stat-grid">
          <div class="stat">
            <div class="stat-label" id="expectedILLabel">Expected IL</div>
            <div class="stat-value" id="ilExpected">â€“</div>
          </div>
          <div class="stat">
            <div class="stat-label" id="equivalentILAprLabel">Equivalent IL APR</div>
            <div class="stat-value" id="ilApr">â€“</div>
          </div>
          <div class="stat">
            <div class="stat-label" id="feeBreakEvenAprLabel">Fee Break-even APR</div>
            <div class="stat-value" id="ilFeeBreakEven">â€“</div>
          </div>
          <div class="stat">
            <div class="stat-label" id="ilIntervalLabel">5% â€“ 95% IL interval</div>
            <div class="stat-value" id="ilCI">â€“</div>
          </div>
          <div class="stat">
            <div class="stat-label" id="stdDeviationILLabel">Std. deviation of IL</div>
            <div class="stat-value" id="ilStd">â€“</div>
          </div>
        </div>
      </div>

      <!-- Distribution Chart -->
      <div class="chart-container" style="margin-top: 12px;">
        <div class="muted-label" id="ilDistributionLabel">IL distribution (percent)</div>
        <div class="small" id="ilDistributionDesc">
          Based on IL samples obtained from Monte Carlo simulation, bin the results and plot as a frequency histogram.
        </div>
        <div class="chart-wrapper" style="margin-top: 10px;">
          <canvas id="ilDistributionChart"></canvas>
        </div>
        <div class="chart-legend" style="margin-top: 6px;">
          <div class="chart-legend-item">
            <span class="legend-dot" style="background: rgba(148,163,184,0.9);"></span>
            <span id="frequencyLabel">Frequency of simulated IL</span>
          </div>
        </div>
      </div>

      <!-- Monte Carlo Simulation Path Chart -->
      <div class="chart-container" style="margin-top: 18px;">
        <div style="display: flex; justify-content: space-between; align-items: center;">
          <div class="muted-label" id="monteCarloPathLabel">è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿè·¯å¾„</div>
          <button id="monteCarloAxisToggle" style="background: rgba(30, 41, 59, 0.8); border: 1px solid rgba(148, 163, 184, 0.3); border-radius: 4px; padding: 4px 8px; cursor: pointer; color: rgba(148, 163, 184, 0.9); font-size: 11px; display: flex; align-items: center; gap: 4px;" title="ç‚¹å‡»Yè½´æˆ–æ­¤æŒ‰é’®åˆ‡æ¢ä»·æ ¼/ç™¾åˆ†æ¯”">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M12 2v20M2 12h20"></path>
            </svg>
            <span id="monteCarloAxisToggleText">ä»·æ ¼</span>
          </button>
        </div>
        <div class="small" id="monteCarloPathDesc">
          å±•ç¤ºè’™ç‰¹å¡æ´›æ¨¡æ‹Ÿçš„ä»·æ ¼å˜åŒ–è¿‡ç¨‹ï¼ŒåŒ…æ‹¬å½“å‰ä»·æ ¼ã€æ¯æ—¥æ³¢åŠ¨ç‡å’Œæ¨¡æ‹Ÿå¤©æ•°ã€‚
        </div>
        <div class="chart-wrapper" style="margin-top: 10px;">
          <canvas id="monteCarloPathChart"></canvas>
        </div>
        <div class="chart-legend" style="margin-top: 6px;">
          <div class="chart-legend-item">
            <span class="legend-dot" style="background: rgba(73, 229, 94, 0.75);"></span>
            <span id="pricePathLabel">ä»·æ ¼è·¯å¾„</span>
          </div>
          <div class="chart-legend-item">
            <span class="legend-dot" style="background: rgba(168, 85, 247, 0.5);"></span>
            <span id="lpRangeLabel">LP Range</span>
          </div>
        </div>
      </div>
    </div>
  </main>

  <script>
    const API_BASE = "https://api.geckoterminal.com/api/v2";
    const BIRDEYE_BASE = "https://public-api.birdeye.so";

    // Language system
    const translations = {
      en: {
        // Page header
        title: "Is a Liquidity Pool Worth Investing In?",
        tagline: "Live Pool Metrics and Impermanent Loss Calculator",
        // Pool ID section
        poolId: "Pool ID",
        geckoTerminalBadge: "GeckoTerminal Pool Address",
        poolIdLabel: "Paste any Solana pool address to inspect its stats.",
        loadPool: "Load Pool",
        apiKeyConfig: "api_key_config",
        enterBirdeyeKey: "Enter your Birdeye API Key",
        checkKey: "Check Key",
        defaultApiKeyNote: "Default uses built-in API Key. To use your own Key, please click the button above.",
        // Results section
        parsedPoolData: "Parsed Pool Data",
        keyMetrics: "Key metrics",
        liveFromGeckoTerminal: "Live from GeckoTerminal",
        lastDaysLiquidity: "Last {days} Days Liquidity & Volume",
        tvlLineNote: "TVL line uses current liquidity as an approximate level, daily volume from OHLCV candles.",
        lookbackWindow: "Lookback window",
        rawGeckoTerminalResponse: "Raw GeckoTerminal Response",
        rawGeckoTerminalDesc: "Full JSON payload from GeckoTerminal pool snapshot API.",
        rawBirdeyeResponse: "Raw Birdeye OHLCV Response",
        rawBirdeyeDesc: "Full JSON payload from Birdeye OHLCV API (if available).",
        // Chart labels
        tvlUsd: "TVL (USD)",
        dailyVolumeUsd: "Daily Volume (USD)",
        highPrice: "High Price",
        lowPrice: "Low Price",
        // IL Simulator
        ilSimulator: "Impermanent Loss Simulator",
        ilSimulatorSubtitle: "PancakeSwap V3 Â· SOL / USDC Â· Monte Carlo",
        ilSimulatorDesc: "Enter the concentrated liquidity range, current price, daily volatility, and time period. Use geometric Brownian motion to perform Monte Carlo simulation on future prices, estimating expected IL, distribution, and confidence intervals.",
        priceLowerBound: "Price lower bound",
        priceLowerBoundPlaceholder: "e.g. 100",
        priceUpperBound: "Price upper bound",
        priceUpperBoundPlaceholder: "e.g. 200",
        currentPrice: "Current price (Pâ‚€)",
        currentPricePlaceholder: "e.g. 130",
        dailyVolatility: "Daily volatility (percent)",
        dailyVolatilityPlaceholder: "e.g. 7.26 means 7.26%",
        simulationDays: "simulation days",
        simulationDaysPlaceholder: "Forecast days, e.g. 30",
        numberOfPaths: "Number of simulations",
        numberOfPathsPlaceholder: "Number of simulations, default 1000",
        runSimulation: "Run Simulation",
        runningSimulation: "Running Monte Carlo simulation...",
        simulationResults: "Simulation results",
        expectedIL: "Expected IL",
        equivalentILApr: "Equivalent IL APR",
        feeBreakEvenApr: "Fee Break-even APR",
        ilInterval: "5% â€“ 95% IL interval",
        stdDeviationIL: "Std. deviation of IL",
        ilDistribution: "IL distribution (percent)",
        ilDistributionDesc: "Based on IL samples obtained from Monte Carlo simulation, bin the results and plot as a frequency histogram.",
        frequencyOfSimulatedIL: "Frequency of simulated IL",
        monteCarloPath: "Monte Carlo Simulation Path",
        monteCarloPathDesc: "Shows the price evolution of the Monte Carlo simulation paths, based on current price, daily volatility, and simulation days.",
        pricePath: "Price Path",
        lpRange: "LP Range",
        dayLabel: "Day {day}",
        priceLabel: "Price",
        percentageLabel: "Percentage (%)",
        currentPriceLabel: "Current Price",
        dailyVolatilityLabel: "Daily Volatility",
        simulationDaysLabel: "Simulation Days",
        daysAxisLabel: "Days",
        // Stats
        dex: "DEX",
        pair: "Pair",
        poolIdLpId: "Pool ID (LP ID)",
        priceUsd: "{symbol} Price (USD)",
        volume7d: "7-Day Daily Average (USD)",
        marketCap: "Market Cap (USD)",
        correlationCoefficient: "Correlation Coefficient (Ï)",
        lastUpdated: "Last Updated",
        calculating: "Calculating...",
        // Loading messages
        loadingFromGeckoTerminal: "Loading from GeckoTerminal API...",
        loadingOhlcvData: "Loading 180 days of OHLCV data for both tokens...",
        // Simulation status
        simulationDone: "Done. Simulated {paths} paths over {days} days (Ïƒâ‚dailyâ‚ = {sigma}%).",
        // Errors
        pleaseInputPoolId: "Please input a pool id (Solana pool address).",
        invalidPriceInput: "Please enter valid prices, including lower bound, upper bound, and current price.",
        priceMustBePositive: "Price must be greater than 0.",
        lowerBoundMustBeLess: "Lower bound must be less than upper bound.",
        invalidVolatility: "Please enter a valid daily volatility (percentage).",
        daysMustBePositive: "Forecast days must be a positive integer.",
        daysExceedsLimit: "Simulation days cannot exceed 3650.",
        pathsExceedsLimit: "Number of simulations cannot exceed 1000000.",
        // Ratio volatility
        ratioVolatility: "Ratio Volatility",
        // HV buttons
        hvToken0: " HV",
        hvToken1: " HV",
        // HV errors
        insufficientPriceData: "Insufficient price data to calculate volatility for {tokenName} (need at least 10 valid prices).",
        needBothVolatilities: "Insufficient data: Need both token0 and token1 volatility.",
        cannotCalculateCorrelation: "Insufficient data: Cannot calculate correlation coefficient.",
        invalidVolatilityCalculation: "Error: Invalid volatility calculation (negative variance).",
        noPriceDataAvailable: "No price data available. Please load a pool first.",
        calculatingRatioVolatility: "Calculating price ratio volatility...",
      },
      zh: {
        // Page header
        title: "è¿™ä¸ªæµåŠ¨æ€§æ± å€¼å¾—æŠ•èµ„å—ï¼Ÿ",
        tagline: "å®æ—¶æŒ‡æ ‡å’Œæ— å¸¸æŸå¤±è®¡ç®—å™¨",
        // Pool ID section
        poolId: "æµåŠ¨æ€§æ± ID",
        geckoTerminalBadge: "çƒ­é—¨æµåŠ¨æ€§æ± ",
        poolIdLabel: "ç²˜è´´ä»»æ„ Solana æ± åœ°å€ä»¥æŸ¥çœ‹å…¶ç»Ÿè®¡ä¿¡æ¯ã€‚",
        loadPool: "åŠ è½½æµåŠ¨æ€§æ± ",
        apiKeyConfig: "api_key_config",
        enterBirdeyeKey: "è¾“å…¥æ‚¨çš„ Birdeye API å¯†é’¥",
        checkKey: "æ£€æŸ¥å¯†é’¥",
        defaultApiKeyNote: "é»˜è®¤ä½¿ç”¨å†…ç½® API å¯†é’¥ã€‚è¦ä½¿ç”¨æ‚¨è‡ªå·±çš„å¯†é’¥ï¼Œè¯·ç‚¹å‡»ä¸Šé¢çš„æŒ‰é’®ã€‚",
        // Results section
        parsedPoolData: "æµåŠ¨æ€§æ± æ•°æ®",
        keyMetrics: "å…³é”®æŒ‡æ ‡",
        liveFromGeckoTerminal: "æ¥è‡ª GeckoTerminal çš„å®æ—¶æ•°æ®",
        lastDaysLiquidity: "æœ€è¿‘ {days} å¤©çš„æµåŠ¨æ€§å’Œäº¤æ˜“é‡",
        tvlLineNote: "TVL çº¿ä½¿ç”¨å½“å‰æµåŠ¨æ€§ä½œä¸ºè¿‘ä¼¼æ°´å¹³ï¼Œæ¯æ—¥äº¤æ˜“é‡æ¥è‡ª OHLCV ã€‚",
        lookbackWindow: "å›çœ‹çª—å£",
        rawGeckoTerminalResponse: "åŸå§‹ GeckoTerminal å“åº”",
        rawGeckoTerminalDesc: "æ¥è‡ª GeckoTerminal æ± å¿«ç…§ API çš„å®Œæ•´ JSON ã€‚",
        rawBirdeyeResponse: "åŸå§‹ Birdeye OHLCV å“åº”",
        rawBirdeyeDesc: "æ¥è‡ª Birdeye OHLCV API çš„å®Œæ•´ JSONï¼ˆå¦‚æœå¯ç”¨ï¼‰ã€‚",
        // Chart labels
        tvlUsd: "TVL (ç¾å…ƒ)",
        dailyVolumeUsd: "æ¯æ—¥äº¤æ˜“é‡ (ç¾å…ƒ)",
        highPrice: "æœ€é«˜ä»·",
        lowPrice: "æœ€ä½ä»·",
        // IL Simulator
        ilSimulator: "æ— å¸¸æŸå¤±æ¨¡æ‹Ÿå™¨",
        ilSimulatorSubtitle: "PancakeSwap V3 Â· SOL / USDC Â· è’™ç‰¹å¡æ´›",
        ilSimulatorDesc: "è¾“å…¥é›†ä¸­æµåŠ¨æ€§èŒƒå›´ã€å½“å‰ä»·æ ¼ã€æ¯æ—¥æ³¢åŠ¨ç‡å’Œæ—¶é—´æ®µã€‚ä½¿ç”¨GBMï¼ˆå‡ ä½•å¸ƒæœ—è¿åŠ¨ï¼‰å¯¹æœªæ¥ä»·æ ¼è¿›è¡Œè’™ç‰¹å¡æ´›æ¨¡æ‹Ÿï¼Œä¼°ç®—é¢„æœŸ ILã€åˆ†å¸ƒå’Œç½®ä¿¡åŒºé—´ã€‚",
        priceLowerBound: "LP range ä»·æ ¼ä¸‹é™",
        priceLowerBoundPlaceholder: "ä¾‹å¦‚ï¼š100",
        priceUpperBound: "LP rangeä»·æ ¼ä¸Šé™",
        priceUpperBoundPlaceholder: "ä¾‹å¦‚ï¼š200",
        currentPrice: "å½“å‰ä»·æ ¼ (Pâ‚€)",
        currentPricePlaceholder: "ä¾‹å¦‚ï¼š130",
        dailyVolatility: "æ¯æ—¥æ³¢åŠ¨ç‡ (ç™¾åˆ†æ¯”)",
        dailyVolatilityPlaceholder: "ä¾‹å¦‚ 7.26 è¡¨ç¤º 7.26%",
        simulationDays: "æ¨¡æ‹Ÿå¤©æ•°",
        simulationDaysPlaceholder: "é¢„æµ‹å¤©æ•°ï¼Œä¾‹å¦‚ 30",
        numberOfPaths: "æ¨¡æ‹Ÿæ¬¡æ•°",
        numberOfPathsPlaceholder: "æ¨¡æ‹Ÿæ¬¡æ•°ï¼Œé»˜è®¤ 1000",
        runSimulation: "è¿è¡Œæ¨¡æ‹Ÿ",
        runningSimulation: "æ­£åœ¨è¿è¡Œè’™ç‰¹å¡æ´›æ¨¡æ‹Ÿ...",
        simulationResults: "æ¨¡æ‹Ÿç»“æœ",
        expectedIL: "é¢„æœŸ IL",
        equivalentILApr: "ç­‰æ•ˆ IL å¹´åŒ–",
        feeBreakEvenApr: "ç›ˆäºå¹³è¡¡çº¿",
        ilInterval: "5% â€“ 95% IL åŒºé—´",
        stdDeviationIL: "IL æ ‡å‡†å·®",
        ilDistribution: "IL åˆ†å¸ƒ (ç™¾åˆ†æ¯”)",
        ilDistributionDesc: "åŸºäºä»è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿè·å¾—çš„ IL æ ·æœ¬ï¼Œå°†ç»“æœç»˜åˆ¶ä¸ºé¢‘ç‡ç›´æ–¹å›¾ã€‚",
        frequencyOfSimulatedIL: "æ¨¡æ‹Ÿå¾—åˆ°çš„ IL åˆ†å¸ƒé¢‘ç‡",
        monteCarloPath: "è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿè·¯å¾„",
        monteCarloPathDesc: "å±•ç¤ºç¬¬ä¸€æ¬¡æ¨¡æ‹Ÿçš„ä»·æ ¼å˜åŒ–è¿‡ç¨‹ï¼ŒåŒ…æ‹¬å½“å‰ä»·æ ¼ã€æ¯æ—¥æ³¢åŠ¨ç‡å’Œæ¨¡æ‹Ÿå¤©æ•°ã€‚",
        pricePath: "ä»·æ ¼è·¯å¾„",
        lpRange: "LP Range",
        dayLabel: "ç¬¬ {day} å¤©",
        priceLabel: "ä»·æ ¼",
        percentageLabel: "ç™¾åˆ†æ¯” (%)",
        currentPriceLabel: "å½“å‰ä»·æ ¼",
        dailyVolatilityLabel: "æ¯æ—¥æ³¢åŠ¨ç‡",
        simulationDaysLabel: "æ¨¡æ‹Ÿå¤©æ•°",
        daysAxisLabel: "å¤©æ•°",
        // Stats
        dex: "å»ä¸­å¿ƒåŒ–äº¤æ˜“æ‰€",
        pair: "äº¤æ˜“å¯¹",
        poolIdLpId: "æµåŠ¨æ€§æ± ID (LP ID)",
        priceUsd: "{symbol} ä»·æ ¼ (ç¾å…ƒ)",
        volume7d: "7æ—¥æ—¥å‡äº¤æ˜“é‡ (ç¾å…ƒ)",
        marketCap: "å¸‚å€¼ (ç¾å…ƒ)",
        correlationCoefficient: "ç›¸å…³ç³»æ•° (Ï)",
        lastUpdated: "æœ€åä¸€æ¬¡æ›´æ–°äºï¼š",
        calculating: "è®¡ç®—ä¸­...",
        // Loading messages
        loadingFromGeckoTerminal: "æ­£åœ¨ä» GeckoTerminal API åŠ è½½...",
        loadingOhlcvData: "æ­£åœ¨åŠ è½½ä¸¤ä¸ªä»£å¸çš„ 180 å¤© OHLCV æ•°æ®...",
        // Simulation status
        simulationDone: "å®Œæˆã€‚æ¨¡æ‹Ÿäº† {paths} æ¬¡ï¼Œæ¯æ¬¡æ¨¡æ‹Ÿ {days} å¤© (Ïƒâ‚dailyâ‚ = {sigma}%)ã€‚",
        // Errors
        pleaseInputPoolId: "è¯·è¾“å…¥æµåŠ¨æ€§æ± ID (Solana æµåŠ¨æ€§æ± åœ°å€)ã€‚",
        invalidPriceInput: "è¯·å¡«å†™æœ‰æ•ˆçš„ä»·æ ¼ï¼ŒåŒ…å«åŒºé—´ä¸‹ç•Œã€ä¸Šç•Œå’Œå½“å‰ä»·æ ¼ã€‚",
        priceMustBePositive: "ä»·æ ¼å¿…é¡»å¤§äº 0ã€‚",
        lowerBoundMustBeLess: "åŒºé—´ä¸‹ç•Œå¿…é¡»å°äºä¸Šç•Œã€‚",
        invalidVolatility: "è¯·å¡«å†™æœ‰æ•ˆçš„æ—¥æ³¢åŠ¨ç‡ï¼ˆç™¾åˆ†æ¯”ï¼‰ã€‚",
        daysMustBePositive: "é¢„æµ‹å¤©æ•°å¿…é¡»ä¸ºæ­£æ•´æ•°ã€‚",
        daysExceedsLimit: "æ¨¡æ‹Ÿå¤©æ•°ä¸èƒ½è¶…è¿‡ 3650ã€‚",
        pathsExceedsLimit: "æ¨¡æ‹Ÿæ¬¡æ•°ä¸èƒ½è¶…è¿‡ 1000000ã€‚",
        // Ratio volatility
        ratioVolatility: "åŠ æƒæ³¢åŠ¨ç‡",
        // HV buttons
        hvToken0: " å†å²æ³¢åŠ¨ç‡",
        hvToken1: " å†å²æ³¢åŠ¨ç‡",
        // HV errors
        insufficientPriceData: "ä»·æ ¼æ•°æ®ä¸è¶³ï¼Œæ— æ³•è®¡ç®— {tokenName} çš„æ³¢åŠ¨ç‡ï¼ˆè‡³å°‘éœ€è¦ 10 ä¸ªæœ‰æ•ˆä»·æ ¼ï¼‰ã€‚",
        needBothVolatilities: "æ•°æ®ä¸è¶³ï¼šéœ€è¦ token0 å’Œ token1 çš„æ³¢åŠ¨ç‡ã€‚",
        cannotCalculateCorrelation: "æ•°æ®ä¸è¶³ï¼šæ— æ³•è®¡ç®—ç›¸å…³ç³»æ•°ã€‚",
        invalidVolatilityCalculation: "é”™è¯¯ï¼šæ— æ•ˆçš„æ³¢åŠ¨ç‡è®¡ç®—ï¼ˆæ–¹å·®ä¸ºè´Ÿï¼‰ã€‚",
        noPriceDataAvailable: "æ²¡æœ‰ä»·æ ¼æ•°æ®å¯ç”¨ã€‚è¯·å…ˆåŠ è½½ä¸€ä¸ªæ± ã€‚",
        calculatingRatioVolatility: "æ­£åœ¨è®¡ç®—ä»·æ ¼æ¯”ç‡æ³¢åŠ¨ç‡...",
      }
    };

    // Detect user language
    function detectUserLanguage() {
      // Check localStorage first
      const savedLang = localStorage.getItem('appLanguage');
      if (savedLang && (savedLang === 'en' || savedLang === 'zh')) {
        return savedLang;
      }
      // Detect from browser
      const browserLang = navigator.language || navigator.userLanguage;
      if (browserLang.startsWith('zh')) {
        return 'zh';
      }
      return 'en';
    }

    // Current language
    let currentLang = detectUserLanguage();

    // Translation function
    function t(key, params = {}) {
      const translation = translations[currentLang]?.[key] || translations.en[key] || key;
      if (params && Object.keys(params).length > 0) {
        return translation.replace(/\{(\w+)\}/g, (match, paramKey) => {
          return params[paramKey] !== undefined ? params[paramKey] : match;
        });
      }
      return translation;
    }

    // Update all text content
    function updateLanguage() {
      // Save to localStorage
      localStorage.setItem('appLanguage', currentLang);
      
      // Update HTML lang attribute
      const htmlLang = document.getElementById('htmlLang');
      if (htmlLang) {
        htmlLang.setAttribute('lang', currentLang === 'zh' ? 'zh-CN' : 'en');
      } else {
        document.documentElement.setAttribute('lang', currentLang === 'zh' ? 'zh-CN' : 'en');
      }
      
      // Update language switcher
      const langSwitcherText = document.getElementById('langSwitcherText');
      if (langSwitcherText) {
        langSwitcherText.textContent = currentLang === 'zh' ? 'EN/ä¸­æ–‡' : 'ä¸­æ–‡/EN';
      }

      // Update page title
      const pageTitle = document.getElementById('pageTitle');
      if (pageTitle) pageTitle.textContent = t('title');
      const pageTagline = document.getElementById('pageTagline');
      if (pageTagline) pageTagline.textContent = t('tagline');
      
      // Update Pool ID section
      const poolIdTitle = document.getElementById('poolIdTitle');
      if (poolIdTitle) poolIdTitle.textContent = t('poolId');
      const geckoBadge = document.getElementById('geckoBadge');
      if (geckoBadge) geckoBadge.textContent = t('geckoTerminalBadge');
      const poolIdLabel = document.getElementById('poolIdLabel');
      if (poolIdLabel) poolIdLabel.textContent = t('poolIdLabel');
      const loadBtnText = document.getElementById('loadBtnText');
      if (loadBtnText) loadBtnText.textContent = t('loadPool');
      const toggleKeyText = document.getElementById('toggleCustomKeyText');
      if (toggleKeyText) toggleKeyText.textContent = t('apiKeyConfig');
      const birdeyeKeyInput = document.getElementById('birdeyeApiKey');
      if (birdeyeKeyInput) birdeyeKeyInput.placeholder = t('enterBirdeyeKey');
      const checkKeyBtnText = document.getElementById('checkKeyBtnText');
      if (checkKeyBtnText) checkKeyBtnText.textContent = t('checkKey');
      const defaultKeyNote = document.getElementById('defaultKeyNote');
      if (defaultKeyNote) defaultKeyNote.textContent = t('defaultApiKeyNote');

      // Update results section
      const resultsTitle = document.getElementById('resultsTitle');
      if (resultsTitle) resultsTitle.textContent = t('parsedPoolData');
      const keyMetricsLabel = document.getElementById('keyMetricsLabel');
      if (keyMetricsLabel) keyMetricsLabel.textContent = t('keyMetrics');
      const liveFromLabel = document.getElementById('liveFromLabel');
      if (liveFromLabel) liveFromLabel.textContent = t('liveFromGeckoTerminal');
      
      // Update chart section
      const lastDaysLabel = document.getElementById('lastDaysLabel');
      const daysLabelSuffix = document.getElementById('daysLabelSuffix');
      if (lastDaysLabel && daysLabelSuffix) {
        const daysText = t('lastDaysLiquidity', { days: document.getElementById('daysLabel')?.textContent || '30' });
        // Split the text appropriately
        if (currentLang === 'zh') {
          lastDaysLabel.textContent = 'æœ€è¿‘ ';
          daysLabelSuffix.textContent = ' å¤©çš„æµåŠ¨æ€§å’Œäº¤æ˜“é‡';
        } else {
          lastDaysLabel.textContent = 'Last ';
          daysLabelSuffix.textContent = ' Days Liquidity & Volume';
        }
      }
      const tvlLineNote = document.getElementById('tvlLineNote');
      if (tvlLineNote) tvlLineNote.textContent = t('tvlLineNote');
      const lookbackWindowLabel = document.getElementById('lookbackWindowLabel');
      if (lookbackWindowLabel) lookbackWindowLabel.textContent = t('lookbackWindow');
      
      // Update raw JSON sections
      const rawGeckoLabel = document.getElementById('rawGeckoLabel');
      if (rawGeckoLabel) rawGeckoLabel.textContent = t('rawGeckoTerminalResponse');
      const rawGeckoDesc = document.getElementById('rawGeckoDesc');
      if (rawGeckoDesc) rawGeckoDesc.textContent = t('rawGeckoTerminalDesc');
      const rawBirdeyeLabel = document.getElementById('rawBirdeyeLabel');
      if (rawBirdeyeLabel) rawBirdeyeLabel.textContent = t('rawBirdeyeResponse');
      const rawBirdeyeDesc = document.getElementById('rawBirdeyeDesc');
      if (rawBirdeyeDesc) rawBirdeyeDesc.textContent = t('rawBirdeyeDesc');

      // Update IL Simulator
      const ilSimulatorTitle = document.getElementById('ilSimulatorTitle');
      if (ilSimulatorTitle) ilSimulatorTitle.textContent = t('ilSimulator');
      const ilSimulatorSubtitle = document.getElementById('ilSimulatorSubtitle');
      if (ilSimulatorSubtitle) ilSimulatorSubtitle.textContent = t('ilSimulatorSubtitle');
      const ilSimulatorDesc = document.getElementById('ilSimulatorDesc');
      if (ilSimulatorDesc) ilSimulatorDesc.textContent = t('ilSimulatorDesc');
      const runSimulationText = document.getElementById('runSimulationText');
      if (runSimulationText) runSimulationText.textContent = t('runSimulation');
      const simulationResultsLabel = document.getElementById('simulationResultsLabel');
      if (simulationResultsLabel) simulationResultsLabel.textContent = t('simulationResults');
      const expectedILLabel = document.getElementById('expectedILLabel');
      if (expectedILLabel) expectedILLabel.textContent = t('expectedIL');
      const equivalentILAprLabel = document.getElementById('equivalentILAprLabel');
      if (equivalentILAprLabel) equivalentILAprLabel.textContent = t('equivalentILApr');
      const feeBreakEvenAprLabel = document.getElementById('feeBreakEvenAprLabel');
      if (feeBreakEvenAprLabel) feeBreakEvenAprLabel.textContent = t('feeBreakEvenApr');
      const ilIntervalLabel = document.getElementById('ilIntervalLabel');
      if (ilIntervalLabel) ilIntervalLabel.textContent = t('ilInterval');
      const stdDeviationILLabel = document.getElementById('stdDeviationILLabel');
      if (stdDeviationILLabel) stdDeviationILLabel.textContent = t('stdDeviationIL');
      const ilDistributionLabel = document.getElementById('ilDistributionLabel');
      if (ilDistributionLabel) ilDistributionLabel.textContent = t('ilDistribution');
      const ilDistributionDesc = document.getElementById('ilDistributionDesc');
      if (ilDistributionDesc) ilDistributionDesc.textContent = t('ilDistributionDesc');
      const frequencyLabel = document.getElementById('frequencyLabel');
      if (frequencyLabel) frequencyLabel.textContent = t('frequencyOfSimulatedIL');
      const monteCarloPathLabel = document.getElementById('monteCarloPathLabel');
      if (monteCarloPathLabel) monteCarloPathLabel.textContent = t('monteCarloPath');
      const monteCarloPathDesc = document.getElementById('monteCarloPathDesc');
      if (monteCarloPathDesc) monteCarloPathDesc.textContent = t('monteCarloPathDesc');
      const pricePathLabel = document.getElementById('pricePathLabel');
      if (pricePathLabel) pricePathLabel.textContent = t('pricePath');
      const lpRangeLabel = document.getElementById('lpRangeLabel');
      if (lpRangeLabel) lpRangeLabel.textContent = t('lpRange');
      
      // Update ratio volatility button
      const ratioVolatilityBtnText = document.getElementById('ratioVolatilityBtnText');
      if (ratioVolatilityBtnText) ratioVolatilityBtnText.textContent = t('ratioVolatility');

      // Update stat labels
      updateStatLabels();
      
      // Update chart labels
      updateChartLabels();
      
      // Update input placeholders
      const ilLower = document.getElementById('ilLower');
      if (ilLower) ilLower.placeholder = t('priceLowerBoundPlaceholder');
      const ilUpper = document.getElementById('ilUpper');
      if (ilUpper) ilUpper.placeholder = t('priceUpperBoundPlaceholder');
      const ilP0 = document.getElementById('ilP0');
      if (ilP0) ilP0.placeholder = t('currentPricePlaceholder');
      const ilSigmaDaily = document.getElementById('ilSigmaDaily');
      if (ilSigmaDaily) ilSigmaDaily.placeholder = t('dailyVolatilityPlaceholder');
      const ilDays = document.getElementById('ilDays');
      if (ilDays) ilDays.placeholder = t('simulationDaysPlaceholder');
      const ilPaths = document.getElementById('ilPaths');
      if (ilPaths) ilPaths.placeholder = t('numberOfPathsPlaceholder');
    }

    // Update stat labels dynamically
    function updateStatLabels() {
      const statLabels = document.querySelectorAll('.stat-label');
      statLabels.forEach(label => {
        const text = label.textContent.trim();
        if (text === 'Price lower bound' || text === 'ä»·æ ¼ä¸‹é™' || text.includes('LP range ä»·æ ¼ä¸‹é™') || text.includes('ä»·æ ¼ä¸‹é™')) {
          label.textContent = t('priceLowerBound');
        } else if (text === 'Price upper bound' || text === 'ä»·æ ¼ä¸Šé™' || text.includes('LP rangeä»·æ ¼ä¸Šé™') || text.includes('ä»·æ ¼ä¸Šé™')) {
          label.textContent = t('priceUpperBound');
        } else if (text.includes('Current price') || text.includes('å½“å‰ä»·æ ¼')) {
          label.textContent = t('currentPrice');
        } else if (text.includes('Daily volatility') || text.includes('æ¯æ—¥æ³¢åŠ¨ç‡')) {
          label.innerHTML = `<span>${t('dailyVolatility')}</span>`;
        } else if (text.includes('simulation days') || text.includes('æ¨¡æ‹Ÿå¤©æ•°')) {
          label.innerHTML = `<span>${t('simulationDays')}</span>`;
        } else if (text === 'Number of paths' || text === 'Number of simulations' || text === 'è·¯å¾„æ•°é‡' || text === 'æ¨¡æ‹Ÿæ¬¡æ•°') {
          label.textContent = t('numberOfPaths');
        } else if (text === 'Expected IL' || text === 'é¢„æœŸ IL') {
          label.textContent = t('expectedIL');
        } else if (text === 'Equivalent IL APR' || text.includes('ç­‰æ•ˆ IL å¹´åŒ–æ”¶ç›Šç‡')) {
          label.textContent = t('equivalentILApr');
        } else if (text === 'Fee Break-even APR' || text.includes('æ‰‹ç»­è´¹ç›ˆäºå¹³è¡¡') || text === 'ç›ˆäºå¹³è¡¡çº¿') {
          label.textContent = t('feeBreakEvenApr');
        } else if (text.includes('5% â€“ 95%') || text.includes('5% â€“ 95%')) {
          label.textContent = t('ilInterval');
        } else if (text.includes('Std. deviation') || text.includes('æ ‡å‡†å·®')) {
          label.textContent = t('stdDeviationIL');
        } else if (text === 'DEX' || text === 'å»ä¸­å¿ƒåŒ–äº¤æ˜“æ‰€') {
          label.textContent = t('dex');
        } else if (text === 'Pair' || text === 'äº¤æ˜“å¯¹') {
          label.textContent = t('pair');
        } else if (text.includes('Pool ID (LP ID)') || text.includes('æ± ID (LP ID)')) {
          label.textContent = t('poolIdLpId');
        } else if (text.includes('Volume 7d') || text.includes('7-Day Daily Average') || text.includes('7å¤©äº¤æ˜“é‡') || text.includes('7æ—¥æ—¥å‡')) {
          label.textContent = t('volume7d');
        } else if (text.includes('Market Cap') || text.includes('å¸‚å€¼')) {
          label.textContent = t('marketCap');
        } else if (text.includes('Correlation Coefficient') || text.includes('ç›¸å…³ç³»æ•°')) {
          label.textContent = t('correlationCoefficient');
        } else if (text === 'Last Updated' || text === 'æœ€åæ›´æ–°') {
          label.textContent = t('lastUpdated');
        } else if (text.includes('ä»·æ ¼ (ç¾å…ƒ)') || (text.includes('Price (USD)') && text.includes('ä»·æ ¼'))) {
          // Handle price labels that might have Chinese text
          // Try to extract symbol from text like "SOL ä»·æ ¼ (ç¾å…ƒ)" or "{symbol} ä»·æ ¼ (ç¾å…ƒ)"
          const symbolMatch = text.match(/(\w+)\s*ä»·æ ¼/);
          if (symbolMatch && symbolMatch[1]) {
            label.textContent = t('priceUsd', { symbol: symbolMatch[1] });
          } else {
            // Fallback: replace Chinese with English
            label.textContent = text.replace(/\s*ä»·æ ¼\s*\(ç¾å…ƒ\)/g, ' Price (USD)').replace(/ä»·æ ¼/g, 'Price');
          }
        }
      });
    }

    // Update chart labels
    function updateChartLabels() {
      const tvlLegend = document.getElementById('tvlLegend');
      if (tvlLegend) {
        const span = tvlLegend.querySelector('span:last-child');
        if (span && (span.textContent.includes('TVL') || span.textContent.includes('TVL'))) {
          span.textContent = t('tvlUsd');
        }
      }
      const volumeLegend = document.getElementById('volumeLegend');
      if (volumeLegend) {
        const span = volumeLegend.querySelector('span:last-child');
        if (span && (span.textContent.includes('Daily Volume') || span.textContent.includes('æ¯æ—¥äº¤æ˜“é‡'))) {
          span.textContent = t('dailyVolumeUsd');
        }
      }
      const highLabels = document.querySelectorAll('#token0HighLabel, #token1HighLabel');
      highLabels.forEach(el => {
        if (el && (el.textContent.includes('High Price') || el.textContent.includes('æœ€é«˜ä»·'))) {
          el.textContent = t('highPrice');
        }
      });
      const lowLabels = document.querySelectorAll('#token0LowLabel, #token1LowLabel');
      lowLabels.forEach(el => {
        if (el && (el.textContent.includes('Low Price') || el.textContent.includes('æœ€ä½ä»·'))) {
          el.textContent = t('lowPrice');
        }
      });
      
      // Update Monte Carlo Simulation Path chart axis labels
      if (monteCarloPathChartInstance) {
        monteCarloPathChartInstance.options.scales.x.title.text = t('daysAxisLabel');
        monteCarloPathChartInstance.options.scales.y.title.text = monteCarloAxisMode === 'percentage' ? t('percentageLabel') : t('priceLabel');
        monteCarloPathChartInstance.update('none');
      }
      
      // Update Monte Carlo axis toggle button text
      const toggleText = document.getElementById('monteCarloAxisToggleText');
      if (toggleText) {
        toggleText.textContent = monteCarloAxisMode === 'price' ? t('priceLabel') : t('percentageLabel');
      }
    }

    // Language switcher button event
    const langSwitcher = document.getElementById('langSwitcher');
    if (langSwitcher) {
      langSwitcher.addEventListener('click', () => {
        currentLang = currentLang === 'en' ? 'zh' : 'en';
        updateLanguage();
      });
    }

    // Initialize language on page load
    window.addEventListener('DOMContentLoaded', () => {
      updateLanguage();
    });

    function toggleCollapsible(sectionId) {
      const section = document.getElementById(sectionId);
      const arrow = document.getElementById(sectionId.replace('Section', 'Arrow'));
      if (section && arrow) {
        const isExpanded = section.style.display !== 'none';
        section.style.display = isExpanded ? 'none' : 'block';
        arrow.textContent = isExpanded ? 'â–¶' : 'â–¼';
      }
    }

    // Format number to 12 significant digits
    function toSignificantDigits(num, digits = 12) {
      // Ensure input is a number type
      if (typeof num !== 'number') {
        num = Number(num);
      }
      
      if (!Number.isFinite(num)) {
        return String(num);
      }
      
      if (num === 0) {
        return "0";
      }
      
      // Use toPrecision to ensure specified number of significant digits
      const formatted = num.toPrecision(digits);
      
      // If result contains scientific notation (e or E), return directly
      if (formatted.includes('e') || formatted.includes('E')) {
        return formatted;
      }
      
      // Remove trailing unnecessary zeros
      // Example: 139.387752996000 -> 139.387752996
      // Note: parseFloat may lose some precision, so we need to handle carefully
      const parsed = parseFloat(formatted);
      const parsedStr = parsed.toString();
      
      // If parsed string length is reasonable, use it (more concise)
      // Otherwise use the original toPrecision result
      if (parsedStr.length <= formatted.length + 2) {
        return parsedStr;
      }
      
      return formatted;
    }

    // ========== Default API Key Configuration ==========
    // To set a default API Key, follow these steps:
    // 1. Run in browser console: obfuscateKey('your actual API Key')
    // 2. Replace the DEFAULT_BIRDEYE_API_KEY_OBFUSCATED value below with the returned obfuscated string
    // 3. Save the file
    // 
    // Example:
    // const DEFAULT_BIRDEYE_API_KEY_OBFUSCATED = 'QXJhY2h5X0FQSV9LZXlfMTIzNDU2Nzg5MA==';
    const DEFAULT_BIRDEYE_API_KEY_OBFUSCATED = 'YOUR_OBFUSCATED_KEY_HERE'; // Please replace with obfuscated API Key

    // Simple obfuscation function (only to prevent casual users from seeing it, cannot prevent professional users)
    // Warning: Pure frontend encryption cannot truly protect API Key, this is only obfuscation
    function obfuscateKey(key) {
      if (!key) return null;
      // Use simple character offset + Base64 encoding
      const offset = 13; // ROT13-like
      let obfuscated = '';
      for (let i = 0; i < key.length; i++) {
        const charCode = key.charCodeAt(i);
        obfuscated += String.fromCharCode(charCode + offset);
      }
      return btoa(obfuscated); // Base64 encoding
    }

    function deobfuscateKey(obfuscated) {
      if (!obfuscated) return null;
      try {
        const decoded = atob(obfuscated); // Base64 decoding
        const offset = 13;
        let key = '';
        for (let i = 0; i < decoded.length; i++) {
          const charCode = decoded.charCodeAt(i);
          key += String.fromCharCode(charCode - offset);
        }
        return key;
      } catch (e) {
        console.error('Failed to deobfuscate key:', e);
        return null;
      }
    }

    // Get default API Key (if set)
    function getDefaultBirdeyeApiKey() {
      // Check if default Key is set (not a placeholder)
      if (!DEFAULT_BIRDEYE_API_KEY_OBFUSCATED || DEFAULT_BIRDEYE_API_KEY_OBFUSCATED === 'YOUR_OBFUSCATED_KEY_HERE') {
        return null;
      }
      
      try {
        const deobfuscated = deobfuscateKey(DEFAULT_BIRDEYE_API_KEY_OBFUSCATED);
        if (deobfuscated && deobfuscated.trim()) {
          return deobfuscated.trim();
        }
      } catch (e) {
        console.error("Failed to deobfuscate default API key:", e);
      }
      
      return null;
    }

    // Read obfuscated key from localStorage (if exists)
    function getStoredBirdeyeApiKey() {
      try {
        const stored = localStorage.getItem('birdeye_api_key_obf');
        if (stored) {
          return deobfuscateKey(stored);
        }
      } catch (e) {
        console.error('Failed to read stored key:', e);
      }
      return null;
    }

    // Save obfuscated key to localStorage
    function storeBirdeyeApiKey(key) {
      try {
        if (key && key.trim()) {
          const obfuscated = obfuscateKey(key.trim());
          localStorage.setItem('birdeye_api_key_obf', obfuscated);
        } else {
          localStorage.removeItem('birdeye_api_key_obf');
        }
      } catch (e) {
        console.error('Failed to store key:', e);
      }
    }

    function getBirdeyeApiKey() {
      // Priority 1: Get from input field (user newly entered)
      const el = document.getElementById("birdeyeApiKey");
      if (el && el.value && el.value.trim()) {
        const inputKey = el.value.trim();
        // Automatically save to localStorage
        storeBirdeyeApiKey(inputKey);
        return inputKey;
      }
      
      // Priority 2: Read from localStorage (user previously saved)
      const storedKey = getStoredBirdeyeApiKey();
      if (storedKey) {
        return storedKey;
      }
      
      // ä¼˜å…ˆçº§ 3: ä½¿ç”¨é»˜è®¤çš„ API Keyï¼ˆæ··æ·†åçš„ï¼‰- å½“è¾“å…¥æ¡†ä¸ºç©ºæ—¶è‡ªåŠ¨ä½¿ç”¨
      const defaultKey = getDefaultBirdeyeApiKey();
      if (defaultKey) {
        console.log("ä½¿ç”¨é»˜è®¤çš„ Birdeye API Keyï¼ˆè¾“å…¥æ¡†ä¸ºç©ºï¼‰");
        return defaultKey;
      }
      
      // If all methods fail, return null
      console.warn("Birdeye API Key not found: input field is empty, localStorage is empty, and no default Key is set");
      return null;
    }

    let currentDays = 30; // Currently selected days (controlled by slider), default 30 days
    let tvlVolumeChartInstance = null;
    let storedOhlcvData = []; // Store complete 180 days of data [ts, open0, high0, low0, close0, volume, tvl, trades, open1, high1, low1, close1]
    let currentBaseSymbol = "N/A";
    let currentQuoteSymbol = "N/A";

    async function fetchOhlcv(poolId, days, token = "base") {
      const limit = days ?? currentDays;
      const url = `${API_BASE}/networks/solana/pools/${poolId}/ohlcv/day?aggregate=1&limit=${limit}&currency=usd&token=${token}`;
      const resp = await fetch(url);
      if (!resp.ok) {
        throw new Error(`OHLCV HTTP error ${resp.status} (${resp.statusText})`);
      }
      const json = await resp.json();
      const list = json?.data?.attributes?.ohlcv_list || [];
      return list;
    }

    async function fetchBirdeyeOhlcv(poolId, days) {
      const apiKey = getBirdeyeApiKey();
      if (!apiKey) {
        throw new Error("Birdeye API Key is required. Please enter your API key in the input field above.");
      }

      const nowSec = Math.floor(Date.now() / 1000);
      const lookbackDays = days ?? currentDays;
      // Add 1 day buffer
      const fromSec = nowSec - (lookbackDays + 1) * 24 * 60 * 60;

      const url = `${BIRDEYE_BASE}/defi/ohlcv/pair?address=${poolId}&type=1D&time_from=${fromSec}&time_to=${nowSec}`;
      const headers = {
        "accept": "application/json",
        "x-chain": "solana",
        "X-API-KEY": apiKey
      };

      const resp = await fetch(url, { headers });
      if (!resp.ok) {
        throw new Error(`Birdeye OHLCV HTTP error ${resp.status} (${resp.statusText})`);
      }
      const json = await resp.json();

      // Display Birdeye raw response (if corresponding container exists)
      const birdeyeRawEl = document.getElementById("birdeyeRawJson");
      if (birdeyeRawEl) {
        birdeyeRawEl.textContent = JSON.stringify(json, null, 2);
      }

      const data = json && json.data ? json.data : null;

      const rawItems =
        (data && (data.items || data.ohlcv_list || data.ohlcv || data.candles)) ||
        (Array.isArray(data) ? data : []) ||
        [];

      const normalized = rawItems
        .map((item) => {
          if (Array.isArray(item)) {
            const ts = Number(item[0] ?? 0);
            const open = Number(item[1] ?? 0);
            const high = Number(item[2] ?? open);
            const low = Number(item[3] ?? open);
            const close = Number(item[4] ?? open);
            const volume = Number(item[5] ?? 0);
            // Try to read TVL from column 7/8 (if available)
            const tvlCandidate = Number(item[6] ?? item[7] ?? 0);
            const tvl = Number.isFinite(tvlCandidate) && tvlCandidate > 0 ? tvlCandidate : null;
            // Try to read trade count from subsequent columns (if available)
            const tradesCandidate = Number(item[8] ?? item[9] ?? 0);
            const trades =
              Number.isFinite(tradesCandidate) && tradesCandidate >= 0 ? tradesCandidate : 0;
            return [ts, open, high, low, close, volume, tvl, trades];
          } else if (item && typeof item === "object") {
            const ts = Number(item.unixTime ?? item.time ?? item.t ?? 0);
            const open = Number(item.open ?? item.o ?? 0);
            const high = Number(item.high ?? item.h ?? open);
            const low = Number(item.low ?? item.l ?? open);
            const close = Number(item.close ?? item.c ?? open);
            const volume = Number(item.volume ?? item.v ?? 0);
            // Try common TVL field names
            const tvlCandidate = Number(
              item.tvl ?? item.tvlUsd ?? item.tvl_usd ??
              item.liquidity ?? item.liquidityUsd ?? item.liquidity_usd ?? 0
            );
            const tvl = Number.isFinite(tvlCandidate) && tvlCandidate > 0 ? tvlCandidate : null;
            // Try common trade count field names
            const tradesCandidate = Number(
              item.n ?? item.txCount ?? item.trades ?? item.tradeCount ?? 0
            );
            const trades =
              Number.isFinite(tradesCandidate) && tradesCandidate >= 0 ? tradesCandidate : 0;
            return [ts, open, high, low, close, volume, tvl, trades];
          }
          return null;
        })
        .filter((row) => Array.isArray(row) && row[0]);

      // Pad one entry per day according to slider days (use placeholder for days without data)
      const daysCount = lookbackDays;
      const endDay = Math.floor(nowSec / 86400) * 86400; // Today 00:00
      const startDay = endDay - (daysCount - 1) * 86400;

      // First normalize keys by "day"
      const byDay = new Map();
      normalized.forEach((row) => {
        const ts = row[0];
        const dayTs = Math.floor(ts / 86400) * 86400;
        // Latest entry overwrites old (if multiple entries on same day)
        byDay.set(dayTs, row);
      });

      const padded = [];
      for (let t = startDay; t <= endDay; t += 86400) {
        if (byDay.has(t)) {
          padded.push(byDay.get(t));
        } else {
          // Days without data, use placeholder: price null, volume 0, TVL null, trade count 0
          padded.push([t, null, null, null, null, 0, null, 0]);
        }
      }

      return padded;
    }

    async function checkBirdeyeKey() {
      const statusEl = document.getElementById("birdeyeStatus");
      if (!statusEl) return;

      const key = getBirdeyeApiKey();
      if (!key) {
        statusEl.textContent = "Birdeye API Key is empty.";
        statusEl.style.color = "var(--danger)";
        return;
      }

      // Check if using default key (by checking if input field is empty)
      const keyInput = document.getElementById("birdeyeApiKey");
      const isUsingDefaultKey = !keyInput || !keyInput.value || !keyInput.value.trim();
      
      statusEl.textContent = isUsingDefaultKey 
        ? "Checking default Birdeye API Key..." 
        : "Checking Birdeye API Key...";
      statusEl.style.color = "var(--text-muted)";

      // Use current poolId (or default) to test if data can be fetched normally
      const poolInput = document.getElementById("poolId");
      const fallbackPoolId = "DJNtGuBGEQiUCWE8F981M2C3ZghZt2XLD8f2sQdZ6rsZ";
      const testPoolId =
        (poolInput && (poolInput.value || "").trim()) || fallbackPoolId;

      try {
        const list = await fetchBirdeyeOhlcv(testPoolId, 1);
        if (Array.isArray(list) && list.length > 0) {
          const keyInput = document.getElementById("birdeyeApiKey");
          const isUsingDefaultKey = !keyInput || !keyInput.value || !keyInput.value.trim();
          statusEl.textContent = isUsingDefaultKey 
            ? "Default Birdeye API Key is available." 
            : "Birdeye API Key is available.";
          statusEl.style.color = "var(--accent)";
        } else {
          statusEl.textContent =
            "Birdeye API Key request succeeded but returned no data, may be a permission or test pool issue.";
          statusEl.style.color = "var(--text-muted)";
        }
      } catch (e) {
        console.error("Birdeye key check failed", e);
        const msg = e && e.message ? e.message : String(e);
        const keyInput = document.getElementById("birdeyeApiKey");
        const isUsingDefaultKey = !keyInput || !keyInput.value || !keyInput.value.trim();
        statusEl.textContent = isUsingDefaultKey
          ? `Default Birdeye API Key is unavailable: ${msg}. Please use your own API Key.`
          : `Birdeye API Key is unavailable: ${msg}`;
        statusEl.style.color = "var(--danger)";
      }
    }

    function buildTvlVolumeChart(
      ctx,
      labels,
      tvlData,
      volData,
      hasTvl,
      _openData = [],      // No longer using open/close, only keeping high/low
      highData0 = [],
      lowData0 = [],
      _closeData = [],
      hasPrice0 = false,
      highData1 = [],
      lowData1 = [],
      hasPrice1 = false,
      hiddenStates = {}    // Save dataset hidden state
    ) {
      if (tvlVolumeChartInstance) {
        tvlVolumeChartInstance.destroy();
      }

      const datasets = [];

      if (hasTvl) {
        datasets.push({
          type: "line",
          label: "TVL (USD)",
          data: tvlData,
          borderColor: "#22c55e",
          backgroundColor: "rgba(34, 197, 94, 0.15)",
          borderWidth: 2,
          tension: 0.3,
          yAxisID: "y",
          pointRadius: 2.5,
          pointHoverRadius: 4
        });
      }

      if (hasPrice0) {
        datasets.push(
          {
            type: "line",
            label: `${currentBaseSymbol} High`,
            data: highData0,
            borderColor: "rgba(250, 204, 21, 0.9)",
            backgroundColor: "rgba(250, 204, 21, 0.12)",
            borderWidth: 1.5,
            tension: 0.25,
            yAxisID: "y",
            pointRadius: 0,
            pointHoverRadius: 2.5
          },
          {
            type: "line",
            label: `${currentBaseSymbol} Low`,
            data: lowData0,
            borderColor: "rgba(248, 113, 113, 0.9)",
            backgroundColor: "rgba(248, 113, 113, 0.12)",
            borderWidth: 1.5,
            tension: 0.25,
            yAxisID: "y",
            pointRadius: 0,
            pointHoverRadius: 2.5
          }
        );
      }

      if (hasPrice1) {
        datasets.push(
          {
            type: "line",
            label: `${currentQuoteSymbol} High`,
            data: highData1,
            borderColor: "rgba(59, 130, 246, 0.9)",  // blue
            backgroundColor: "rgba(59, 130, 246, 0.12)",
            borderWidth: 1.5,
            tension: 0.25,
            yAxisID: "y",
            pointRadius: 0,
            pointHoverRadius: 2.5
          },
          {
            type: "line",
            label: `${currentQuoteSymbol} Low`,
            data: lowData1,
            borderColor: "rgba(139, 92, 246, 0.9)",  // purple
            backgroundColor: "rgba(139, 92, 246, 0.12)",
            borderWidth: 1.5,
            tension: 0.25,
            yAxisID: "y",
            pointRadius: 0,
            pointHoverRadius: 2.5
          }
        );
      }

      datasets.push({
        type: "bar",
        label: "Volume (USD)",
        data: volData,
        backgroundColor: "rgba(148, 163, 184, 0.65)",
        borderColor: "rgba(148, 163, 184, 0.9)",
        borderWidth: 1,
        yAxisID: "y1",
        maxBarThickness: 18
      });

      tvlVolumeChartInstance = new Chart(ctx, {
        type: "bar",
        data: {
          labels,
          datasets
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              mode: "index",
              intersect: false,
              backgroundColor: "rgba(15, 23, 42, 0.95)",
              borderColor: "rgba(148, 163, 184, 0.5)",
              borderWidth: 1,
              padding: 10,
              titleFont: {
                size: 12
              },
              bodyFont: {
                size: 11
              },
              callbacks: {
                label: function (ctx) {
                  const label = ctx.dataset.label || "";
                  const value = ctx.parsed.y;
                  if (value == null) return "";
                  const formatted =
                    Math.abs(value) >= 1e9
                      ? (value / 1e9).toFixed(2) + "B"
                      : Math.abs(value) >= 1e6
                      ? (value / 1e6).toFixed(2) + "M"
                      : Math.abs(value) >= 1e3
                      ? (value / 1e3).toFixed(2) + "K"
                      : value.toFixed(2);
                  return `${label}: ${formatted} USD`;
                }
              }
            }
          },
          interaction: {
            mode: "index",
            intersect: false
          },
          scales: {
            x: {
              ticks: {
                color: "rgba(148, 163, 184, 0.9)",
                font: {
                  size: 11
                }
              },
              grid: {
                display: false
              }
            },
            y: {
              position: "left",
              ticks: {
                color: "rgba(34, 197, 94, 0.9)",
                font: {
                  size: 10
                },
                callback: function (value) {
                  if (Math.abs(value) >= 1e9) return (value / 1e9).toFixed(1) + "B";
                  if (Math.abs(value) >= 1e6) return (value / 1e6).toFixed(1) + "M";
                  if (Math.abs(value) >= 1e3) return (value / 1e3).toFixed(0) + "K";
                  return value;
                }
              },
              grid: {
                color: "rgba(30, 64, 175, 0.25)"
              }
            },
            y1: {
              position: "right",
              ticks: {
                color: "rgba(148, 163, 184, 0.9)",
                font: {
                  size: 10
                },
                callback: function (value) {
                  if (Math.abs(value) >= 1e9) return (value / 1e9).toFixed(1) + "B";
                  if (Math.abs(value) >= 1e6) return (value / 1e6).toFixed(1) + "M";
                  if (Math.abs(value) >= 1e3) return (value / 1e3).toFixed(0) + "K";
                  return value;
                }
              },
              grid: {
                display: false
              }
            }
          }
        }
      });

      // Restore dataset hidden state
      if (tvlVolumeChartInstance && tvlVolumeChartInstance.data && tvlVolumeChartInstance.data.datasets) {
        tvlVolumeChartInstance.data.datasets.forEach((dataset) => {
          if (dataset.label && hiddenStates.hasOwnProperty(dataset.label)) {
            dataset.hidden = hiddenStates[dataset.label];
          }
        });
        // å¦‚æœæœ‰ä»»ä½•æ•°æ®é›†è¢«éšè—ï¼Œæ›´æ–°å›¾è¡¨
        const hasHidden = tvlVolumeChartInstance.data.datasets.some(d => d.hidden);
        if (hasHidden) {
          tvlVolumeChartInstance.update('none'); // 'none' æ¨¡å¼é¿å…åŠ¨ç”»
        }
      }

      // Control whether TVL is displayed in legend
      const tvlLegendEl = document.getElementById("tvlLegend");
      if (tvlLegendEl) {
        tvlLegendEl.style.display = hasTvl ? "inline-flex" : "none";
        if (hasTvl) {
          // Find TVL dataset index
          const tvlDatasetIndex = datasets.findIndex(d => d.label === "TVL (USD)");
          if (tvlDatasetIndex !== -1) {
            tvlLegendEl.setAttribute("data-dataset-index", tvlDatasetIndex);
            tvlLegendEl.style.cursor = "pointer";
            tvlLegendEl.classList.remove("legend-hidden");
          }
        }
      }

      // Update token0 price legend
      const token0HighLegendEl = document.getElementById("token0HighLegend");
      const token0LowLegendEl = document.getElementById("token0LowLegend");
      const token0HighLabelEl = document.getElementById("token0HighLabel");
      const token0LowLabelEl = document.getElementById("token0LowLabel");
      if (token0HighLegendEl) {
        token0HighLegendEl.style.display = hasPrice0 ? "inline-flex" : "none";
        if (hasPrice0) {
          const highDatasetIndex = datasets.findIndex(d => d.label === `${currentBaseSymbol} High`);
          if (highDatasetIndex !== -1) {
            token0HighLegendEl.setAttribute("data-dataset-index", highDatasetIndex);
            token0HighLegendEl.style.cursor = "pointer";
            token0HighLegendEl.classList.remove("legend-hidden");
          }
        }
      }
      if (token0LowLegendEl) {
        token0LowLegendEl.style.display = hasPrice0 ? "inline-flex" : "none";
        if (hasPrice0) {
          const lowDatasetIndex = datasets.findIndex(d => d.label === `${currentBaseSymbol} Low`);
          if (lowDatasetIndex !== -1) {
            token0LowLegendEl.setAttribute("data-dataset-index", lowDatasetIndex);
            token0LowLegendEl.style.cursor = "pointer";
            token0LowLegendEl.classList.remove("legend-hidden");
          }
        }
      }
      if (token0HighLabelEl && hasPrice0) {
        token0HighLabelEl.textContent = `${currentBaseSymbol} High`;
      }
      if (token0LowLabelEl && hasPrice0) {
        token0LowLabelEl.textContent = `${currentBaseSymbol} Low`;
      }

      // Update token1 price legend
      const token1HighLegendEl = document.getElementById("token1HighLegend");
      const token1LowLegendEl = document.getElementById("token1LowLegend");
      const token1HighLabelEl = document.getElementById("token1HighLabel");
      const token1LowLabelEl = document.getElementById("token1LowLabel");
      if (token1HighLegendEl) {
        token1HighLegendEl.style.display = hasPrice1 ? "inline-flex" : "none";
        if (hasPrice1) {
          const highDatasetIndex = datasets.findIndex(d => d.label === `${currentQuoteSymbol} High`);
          if (highDatasetIndex !== -1) {
            token1HighLegendEl.setAttribute("data-dataset-index", highDatasetIndex);
            token1HighLegendEl.style.cursor = "pointer";
            token1HighLegendEl.classList.remove("legend-hidden");
          }
        }
      }
      if (token1LowLegendEl) {
        token1LowLegendEl.style.display = hasPrice1 ? "inline-flex" : "none";
        if (hasPrice1) {
          const lowDatasetIndex = datasets.findIndex(d => d.label === `${currentQuoteSymbol} Low`);
          if (lowDatasetIndex !== -1) {
            token1LowLegendEl.setAttribute("data-dataset-index", lowDatasetIndex);
            token1LowLegendEl.style.cursor = "pointer";
            token1LowLegendEl.classList.remove("legend-hidden");
          }
        }
      }
      if (token1HighLabelEl && hasPrice1) {
        token1HighLabelEl.textContent = `${currentQuoteSymbol} High`;
      }
      if (token1LowLabelEl && hasPrice1) {
        token1LowLabelEl.textContent = `${currentQuoteSymbol} Low`;
      }

      // Add click functionality to Volume legend
      const volumeLegendEl = document.getElementById("volumeLegend");
      if (volumeLegendEl) {
        const volumeDatasetIndex = datasets.findIndex(d => d.label === "Volume (USD)");
        if (volumeDatasetIndex !== -1) {
          volumeLegendEl.setAttribute("data-dataset-index", volumeDatasetIndex);
          volumeLegendEl.style.cursor = "pointer";
          volumeLegendEl.classList.remove("legend-hidden");
        }
      }

      // Restore legend visual style (based on dataset hidden state)
      if (tvlVolumeChartInstance && tvlVolumeChartInstance.data && tvlVolumeChartInstance.data.datasets) {
        tvlVolumeChartInstance.data.datasets.forEach((dataset, index) => {
          const legendItem = document.querySelector(`.chart-legend-item[data-dataset-index="${index}"]`);
          if (legendItem) {
            if (dataset.hidden) {
              legendItem.classList.add('legend-hidden');
            } else {
              legendItem.classList.remove('legend-hidden');
            }
          }
        });
      }

      // Setup legend click events
      setupLegendClickHandlers();
    }

    function setupLegendClickHandlers() {
      // Remove all old event listeners
      const legendItems = document.querySelectorAll('.chart-legend-item[data-dataset-index]');
      legendItems.forEach(item => {
        // Use cloneNode to remove old event listeners
        const newItem = item.cloneNode(true);
        if (item.parentNode) {
          item.parentNode.replaceChild(newItem, item);
        }
        
        // Add new click event listener
        newItem.addEventListener('click', function(e) {
          e.stopPropagation();
          const datasetIndex = parseInt(this.getAttribute('data-dataset-index'));
          if (tvlVolumeChartInstance && !isNaN(datasetIndex) && datasetIndex >= 0 && datasetIndex < tvlVolumeChartInstance.data.datasets.length) {
            const dataset = tvlVolumeChartInstance.data.datasets[datasetIndex];
            const isHidden = dataset.hidden || false;
            
            // Toggle hidden state
            dataset.hidden = !isHidden;
            tvlVolumeChartInstance.update();
            
            // Update legend visual style
            if (dataset.hidden) {
              this.classList.add('legend-hidden');
            } else {
              this.classList.remove('legend-hidden');
            }
          }
        });
      });
    }

    function updateChartFromStoredData(days) {
      if (!storedOhlcvData || storedOhlcvData.length === 0) {
        // If no stored data, clear chart
        const ctx = document.getElementById("tvlVolumeChart").getContext("2d");
        buildTvlVolumeChart(ctx, [], [], [], false, [], [], [], [], false, [], [], false, {});
        return;
      }

      // Get last N days of data from stored data
      const displayDays = days || currentDays;
      const startIndex = Math.max(0, storedOhlcvData.length - displayDays);
      const displayData = storedOhlcvData.slice(startIndex);

      const labels = [];
      const tvlData = [];
      const volData = [];
      const highData0 = [];  // token0 high
      const lowData0 = [];   // token0 low
      const highData1 = [];  // token1 high
      const lowData1 = [];   // token1 low
      let hasTvl = false;
      let hasPrice0 = false;
      let hasPrice1 = false;

      displayData.forEach(entry => {
        // æ•°æ®æ ¼å¼: [ts, open0, high0, low0, close0, volume, tvl, trades, open1, high1, low1, close1]
        const ts = entry[0];       // timestamp in seconds
        const _open0 = entry[1];  // token0 open
        const high0 = entry[2];   // token0 high
        const low0 = entry[3];    // token0 low
        const _close0 = entry[4]; // token0 close
        const volume = entry[5];   // volume in USD (with currency=usd)
        const tvl = entry[6];      // TVL (if available)
        const trades = entry[7];   // Daily trade count (if available)
        const _open1 = entry[8];  // token1 open
        const high1 = entry[9];   // token1 high
        const low1 = entry[10];   // token1 low
        const _close1 = entry[11]; // token1 close
        
        const date = new Date(ts * 1000);
        const label = date.toLocaleDateString("en-US", {
          month: "short",
          day: "numeric"
        });

        labels.push(label);

        // token0 high/low price
        if (high0 != null && !isNaN(Number(high0))) {
          highData0.push(Number(high0));
          hasPrice0 = true;
        } else {
          highData0.push(null);
        }

        if (low0 != null && !isNaN(Number(low0))) {
          lowData0.push(Number(low0));
          hasPrice0 = true;
        } else {
          lowData0.push(null);
        }

        // token1 high/low price
        if (high1 != null && !isNaN(Number(high1))) {
          highData1.push(Number(high1));
          hasPrice1 = true;
        } else {
          highData1.push(null);
        }

        if (low1 != null && !isNaN(Number(low1))) {
          lowData1.push(Number(low1));
          hasPrice1 = true;
        } else {
          lowData1.push(null);
        }

        // TVL
        if (tvl != null && !isNaN(Number(tvl)) && Number(tvl) > 0) {
          tvlData.push(Number(tvl));
          hasTvl = true;
        } else {
          tvlData.push(null);
        }

        volData.push(volume);
      });

      // Save current dataset hidden state (if chart exists)
      const hiddenStates = {};
      if (tvlVolumeChartInstance && tvlVolumeChartInstance.data && tvlVolumeChartInstance.data.datasets) {
        tvlVolumeChartInstance.data.datasets.forEach((dataset, index) => {
          if (dataset.label) {
            hiddenStates[dataset.label] = dataset.hidden || false;
          }
        });
      }

      const ctx = document.getElementById("tvlVolumeChart").getContext("2d");
      buildTvlVolumeChart(
        ctx,
        labels,
        tvlData,
        volData,
        hasTvl,
        [],        // openData no longer used
        highData0,
        lowData0,
        [],        // closeData no longer used
        hasPrice0,
        highData1,
        lowData1,
        hasPrice1,
        hiddenStates  // Pass hidden state
      );
    }

    async function loadPool(poolId, daysOverride) {
      const errorEl = document.getElementById("error");
      const loadingEl = document.getElementById("loading");
      const resultsEl = document.getElementById("results");
      const infoEl = document.getElementById("poolInfo");
      const rawEl = document.getElementById("rawJson");
      const birdeyeRawEl = document.getElementById("birdeyeRawJson");

      errorEl.textContent = "";
      loadingEl.textContent = t('loadingFromGeckoTerminal');
      resultsEl.style.display = "none";
      infoEl.innerHTML = "";
      rawEl.textContent = "";
      if (birdeyeRawEl) birdeyeRawEl.textContent = "";

      try {
        if (!poolId || poolId.trim() === "") {
          throw new Error(t('pleaseInputPoolId'));
        }

        const cleanId = poolId.trim();

        // 1, current pool snapshot
        const url = `${API_BASE}/networks/solana/pools/${cleanId}`;
        const resp = await fetch(url);
        if (!resp.ok) {
          throw new Error(`HTTP error ${resp.status} (${resp.statusText})`);
        }
        const json = await resp.json();

        rawEl.textContent = JSON.stringify(json, null, 2);

        const data = json.data;
        if (!data || !data.attributes) {
          throw new Error("Unexpected API format, no data.attributes field.");
        }

        const attr = data.attributes;

        // Get token name, try multiple possible fields
        let baseSymbol = attr.base_token_symbol || 
                        attr.base_token?.symbol ||
                        attr.base?.symbol ||
                        attr.token0?.symbol ||
                        (data.relationships?.base_token?.data?.attributes?.symbol) ||
                        (data.relationships?.base_token?.data?.symbol) ||
                        "N/A";
        
        let quoteSymbol = attr.quote_token_symbol || 
                         attr.quote_token?.symbol ||
                         attr.quote?.symbol ||
                         attr.token1?.symbol ||
                         (data.relationships?.quote_token?.data?.attributes?.symbol) ||
                         (data.relationships?.quote_token?.data?.symbol) ||
                         "N/A";
        
        // If still N/A, try to find from included array (GeckoTerminal API usually includes this)
        if ((baseSymbol === "N/A" || quoteSymbol === "N/A") && json.included && Array.isArray(json.included)) {
          const tokens = json.included.filter(item => item.type === 'token' && item.attributes?.symbol);
          
          // Try to find corresponding token through relationships
          if (data.relationships) {
            const baseTokenId = data.relationships?.base_token?.data?.id || 
                               data.relationships?.base_token?.data?.data?.id;
            const quoteTokenId = data.relationships?.quote_token?.data?.id || 
                                data.relationships?.quote_token?.data?.data?.id;
            
            if (baseTokenId && baseSymbol === "N/A") {
              const baseToken = tokens.find(t => t.id === baseTokenId);
              if (baseToken?.attributes?.symbol) {
                baseSymbol = baseToken.attributes.symbol;
              }
            }
            
            if (quoteTokenId && quoteSymbol === "N/A") {
              const quoteToken = tokens.find(t => t.id === quoteTokenId);
              if (quoteToken?.attributes?.symbol) {
                quoteSymbol = quoteToken.attributes.symbol;
              }
            }
          }
          
          // å¦‚æœè¿˜æ˜¯æ‰¾ä¸åˆ°ï¼Œå°è¯•æŒ‰é¡ºåºå–å‰ä¸¤ä¸ª token
          if (tokens.length >= 2) {
            if (baseSymbol === "N/A" && tokens[0]?.attributes?.symbol) {
              baseSymbol = tokens[0].attributes.symbol;
            }
            if (quoteSymbol === "N/A" && tokens[1]?.attributes?.symbol) {
              quoteSymbol = tokens[1].attributes.symbol;
            }
          } else if (tokens.length === 1 && baseSymbol === "N/A") {
            baseSymbol = tokens[0].attributes.symbol;
          }
        }
        
        // æœ€åçš„å¤‡ç”¨æ–¹æ¡ˆï¼šå°è¯•ä» name å­—æ®µè§£æï¼ˆå¦‚æœæœ‰æ ¼å¼å¦‚ "SOL/USDC"ï¼‰
        if ((baseSymbol === "N/A" || quoteSymbol === "N/A") && attr.name) {
          const nameParts = attr.name.split('/');
          if (nameParts.length >= 2) {
            if (baseSymbol === "N/A") baseSymbol = nameParts[0].trim();
            if (quoteSymbol === "N/A") quoteSymbol = nameParts[1].trim();
          }
        }
        
        // è°ƒè¯•ï¼šå¦‚æœè¿˜æ˜¯ N/Aï¼Œè¾“å‡ºè­¦å‘Š
        if (baseSymbol === "N/A" || quoteSymbol === "N/A") {
          console.warn("Could not find token symbols. Available attributes:", Object.keys(attr));
          console.warn("Relationships:", data.relationships);
          console.warn("Included items:", json.included?.map(i => ({ type: i.type, id: i.id, symbol: i.attributes?.symbol })));
        }
        
        // è·å– token0 (base token) çš„ USD ä»·æ ¼
        let token0PriceUsd = attr.base_token_price_usd || 
                            attr.base_token?.price_usd ||
                            attr.token0?.price_usd ||
                            attr.price_in_usd ||
                            null;
        
        // è·å– token1 (quote token) çš„ USD ä»·æ ¼
        let token1PriceUsd = attr.quote_token_price_usd || 
                            attr.quote_token?.price_usd ||
                            attr.token1?.price_usd ||
                            null;
        
        // è·å– market_cap_usdï¼ˆé€šå¸¸æ¥è‡ª base tokenï¼‰
        let marketCapUsd = attr.base_token_market_cap_usd || 
                          attr.base_token?.market_cap_usd ||
                          attr.market_cap_usd ||
                          null;
        
        // å¦‚æœè¿˜æ˜¯æ‰¾ä¸åˆ°ï¼Œå°è¯•ä» included æ•°ç»„ä¸­æŸ¥æ‰¾
        if ((!token0PriceUsd || !token1PriceUsd || !marketCapUsd) && json.included && Array.isArray(json.included)) {
          const tokens = json.included.filter(item => item.type === 'token' && item.attributes);
          
          if (data.relationships) {
            const baseTokenId = data.relationships?.base_token?.data?.id || 
                               data.relationships?.base_token?.data?.data?.id;
            const quoteTokenId = data.relationships?.quote_token?.data?.id || 
                                data.relationships?.quote_token?.data?.data?.id;
            
            if (baseTokenId) {
              const baseToken = tokens.find(t => t.id === baseTokenId);
              if (baseToken?.attributes) {
                if (!token0PriceUsd && baseToken.attributes.price_usd) {
                  token0PriceUsd = baseToken.attributes.price_usd;
                }
                if (!marketCapUsd && baseToken.attributes.market_cap_usd) {
                  marketCapUsd = baseToken.attributes.market_cap_usd;
                }
              }
            }
            
            if (quoteTokenId && !token1PriceUsd) {
              const quoteToken = tokens.find(t => t.id === quoteTokenId);
              if (quoteToken?.attributes?.price_usd) {
                token1PriceUsd = quoteToken.attributes.price_usd;
              }
            }
          }
          
          // å¦‚æœè¿˜æ˜¯æ‰¾ä¸åˆ°ï¼Œå°è¯•æŒ‰é¡ºåºå–å‰ä¸¤ä¸ª token
          if (tokens.length >= 2) {
            if (!token0PriceUsd && tokens[0]?.attributes?.price_usd) {
              token0PriceUsd = tokens[0].attributes.price_usd;
            }
            if (!token1PriceUsd && tokens[1]?.attributes?.price_usd) {
              token1PriceUsd = tokens[1].attributes.price_usd;
            }
            if (!marketCapUsd && tokens[0]?.attributes?.market_cap_usd) {
              marketCapUsd = tokens[0].attributes.market_cap_usd;
            }
          } else if (tokens.length === 1 && !marketCapUsd && tokens[0]?.attributes?.market_cap_usd) {
            marketCapUsd = tokens[0].attributes.market_cap_usd;
          }
        }
        
        // æ ¼å¼åŒ– token0 ä»·æ ¼ä¸º12ä½æœ‰æ•ˆæ•°å­—
        let token0PriceDisplay = "N/A";
        if (token0PriceUsd !== undefined && token0PriceUsd !== null && token0PriceUsd !== "N/A") {
          const priceNum = typeof token0PriceUsd === "number" ? token0PriceUsd : Number(token0PriceUsd);
          if (Number.isFinite(priceNum) && priceNum > 0) {
            token0PriceDisplay = toSignificantDigits(priceNum, 12);
          } else {
            token0PriceDisplay = String(token0PriceUsd);
          }
        }
        
        // æ ¼å¼åŒ– token1 ä»·æ ¼ä¸º12ä½æœ‰æ•ˆæ•°å­—
        let token1PriceDisplay = "N/A";
        if (token1PriceUsd !== undefined && token1PriceUsd !== null && token1PriceUsd !== "N/A") {
          const priceNum = typeof token1PriceUsd === "number" ? token1PriceUsd : Number(token1PriceUsd);
          if (Number.isFinite(priceNum) && priceNum > 0) {
            token1PriceDisplay = toSignificantDigits(priceNum, 12);
          } else {
            token1PriceDisplay = String(token1PriceUsd);
          }
        }
        
        // æ ¼å¼åŒ– market_cap_usd
        let marketCapUsdDisplay = "N/A";
        if (marketCapUsd !== undefined && marketCapUsd !== null && marketCapUsd !== "N/A") {
          const marketCapNum = typeof marketCapUsd === "number" ? marketCapUsd : Number(marketCapUsd);
          if (Number.isFinite(marketCapNum) && marketCapNum > 0) {
            // æ ¼å¼åŒ–å¸‚å€¼ï¼Œä½¿ç”¨ B/M/K å•ä½
            if (Math.abs(marketCapNum) >= 1e9) {
              marketCapUsdDisplay = (marketCapNum / 1e9).toFixed(2) + "B";
            } else if (Math.abs(marketCapNum) >= 1e6) {
              marketCapUsdDisplay = (marketCapNum / 1e6).toFixed(2) + "M";
            } else if (Math.abs(marketCapNum) >= 1e3) {
              marketCapUsdDisplay = (marketCapNum / 1e3).toFixed(2) + "K";
            } else {
              marketCapUsdDisplay = marketCapNum.toFixed(2);
            }
          } else {
            marketCapUsdDisplay = String(marketCapUsd);
          }
        }
        
        // è®¡ç®— token1/token0 ä»·æ ¼æ¯”ç‡ï¼ˆé€šè¿‡å‚¨å¤‡é‡æˆ– USD ä»·æ ¼ï¼‰
        let token1PerToken0 = null;
        let token0PerToken1 = null;
        
        // æ–¹æ³•1: ä»å‚¨å¤‡é‡è®¡ç®—
        const baseReserve = attr.base_token_reserve || attr.reserve_base || 
                           (attr.base_token && attr.base_token.reserve);
        const quoteReserve = attr.quote_token_reserve || attr.reserve_quote || 
                            (attr.quote_token && attr.quote_token.reserve);
        
        if (baseReserve && quoteReserve && Number(baseReserve) > 0) {
          const baseDecimals = attr.base_token_decimals || 
                              (attr.base_token && attr.base_token.decimals) || 9;
          const quoteDecimals = attr.quote_token_decimals || 
                               (attr.quote_token && attr.quote_token.decimals) || 6;
          
          const baseAmount = Number(baseReserve) / Math.pow(10, baseDecimals);
          const quoteAmount = Number(quoteReserve) / Math.pow(10, quoteDecimals);
          
          if (baseAmount > 0) {
            // token1/token0 = quoteAmount / baseAmount
            token1PerToken0 = quoteAmount / baseAmount;
            // token0/token1 = baseAmount / quoteAmount
            token0PerToken1 = baseAmount / quoteAmount;
          }
        }
        
        // æ–¹æ³•2: å¦‚æœå‚¨å¤‡é‡è®¡ç®—å¤±è´¥ï¼Œä½¿ç”¨ USD ä»·æ ¼è®¡ç®—
        if ((!token1PerToken0 || !Number.isFinite(token1PerToken0)) && 
            token0PriceUsd && token1PriceUsd && 
            Number.isFinite(Number(token0PriceUsd)) && Number.isFinite(Number(token1PriceUsd)) &&
            Number(token0PriceUsd) > 0) {
          const token0Usd = Number(token0PriceUsd);
          const token1Usd = Number(token1PriceUsd);
          // token1/token0 = (token1_usd / token0_usd)
          token1PerToken0 = token1Usd / token0Usd;
          token0PerToken1 = token0Usd / token1Usd;
        }
        
        // æ ¼å¼åŒ–ä»·æ ¼æ¯”ç‡
        let token1PerToken0Display = "N/A";
        let token0PerToken1Display = "N/A";
        
        if (token1PerToken0 && Number.isFinite(token1PerToken0) && token1PerToken0 > 0) {
          token1PerToken0Display = toSignificantDigits(token1PerToken0, 12);
        }
        
        if (token0PerToken1 && Number.isFinite(token0PerToken1) && token0PerToken1 > 0) {
          token0PerToken1Display = toSignificantDigits(token0PerToken1, 12);
        }
        
        const liquidityUsd = attr.reserve_in_usd || attr.liquidity_in_usd || "N/A";
        
        // æå–DEXä¿¡æ¯ï¼ŒæŒ‰ä¼˜å…ˆçº§å°è¯•å¤šä¸ªå¯èƒ½çš„è·¯å¾„
        let dexName = "N/A";
        
        // æ–¹æ³•1: ä» json.dex.data.id è·å–ï¼ˆç›´æ¥è·¯å¾„ï¼‰
        if (json.dex?.data?.id) {
          dexName = json.dex.data.id;
        }
        // æ–¹æ³•2: ä» relationships.dex è·å–
        else if (data.relationships?.dex?.data?.id) {
          dexName = data.relationships.dex.data.id;
        }
        // æ–¹æ³•3: ä» included æ•°ç»„ä¸­æŸ¥æ‰¾ type ä¸º 'dex' çš„é¡¹
        else if (json.included && Array.isArray(json.included)) {
          const dexItem = json.included.find(item => item.type === 'dex');
          if (dexItem?.id) {
            dexName = dexItem.id;
          } else if (dexItem?.attributes?.name) {
            dexName = dexItem.attributes.name;
          }
        }
        // æ–¹æ³•4: ä» attributes.dex_name è·å–
        else if (attr.dex_name) {
          dexName = attr.dex_name;
        }
        // æ–¹æ³•5: ä» attributes.dex è·å–
        else if (attr.dex) {
          dexName = typeof attr.dex === 'string' ? attr.dex : (attr.dex.name || attr.dex.id || "N/A");
        }
        
        // æ ¼å¼åŒ–DEXåç§°ï¼ˆå°†è¿å­—ç¬¦è½¬æ¢ä¸ºç©ºæ ¼å¹¶é¦–å­—æ¯å¤§å†™ï¼‰
        if (dexName !== "N/A" && dexName) {
          dexName = dexName
            .split('-')
            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
            .join(' ');
        }
        
        // æ˜¾ç¤ºæœ€è¿‘ä¸€æ¬¡æ‹‰å–æ—¶é—´çš„æ—¶é—´æˆ³
        const lastUpdated = new Date().toISOString();

        infoEl.innerHTML = `
          <div class="stat-grid">
            <div class="stat">
              <div class="stat-label">${t('dex')}</div>
              <div class="stat-value">${dexName}</div>
            </div>
            <div class="stat">
              <div class="stat-label">${t('pair')}</div>
              <div class="stat-value">${baseSymbol} / ${quoteSymbol}</div>
            </div>
            <div class="stat">
              <div class="stat-label">${t('poolIdLpId')}</div>
              <div class="stat-value">${cleanId}</div>
            </div>
            <div class="stat">
              <div class="stat-label">${t('priceUsd', { symbol: baseSymbol })}</div>
              <div class="stat-value">
                ${token0PriceDisplay} USD
              </div>
            </div>
            <div class="stat">
              <div class="stat-label">${t('priceUsd', { symbol: quoteSymbol })}</div>
              <div class="stat-value">
                ${token1PriceDisplay} USD
              </div>
            </div>
            <div class="stat clickable-stat" id="priceRatioStat" 
                 data-ratio-type="token1-token0"
                 data-base-symbol="${baseSymbol}"
                 data-quote-symbol="${quoteSymbol}"
                 data-token1-per-token0="${token1PerToken0Display}"
                 data-token0-per-token1="${token0PerToken1Display}">
              <div class="stat-label">
                <span id="priceRatioLabel">${quoteSymbol} / ${baseSymbol}</span>
                <span class="swap-icon" id="swapIcon">â‡„</span>
              </div>
              <div class="stat-value" id="priceRatioValue">
                1 ${quoteSymbol} = ${token1PerToken0Display} ${baseSymbol}
              </div>
            </div>
            <div class="stat">
              <div class="stat-label">${t('volume7d')}</div>
              <div class="stat-value" id="volume7dValue">${t('calculating')}</div>
            </div>
            <div class="stat">
              <div class="stat-label">${baseSymbol !== "N/A" ? `${baseSymbol} ${t('marketCap')}` : t('marketCap')}</div>
              <div class="stat-value" id="marketCapUsdValue">${marketCapUsdDisplay}</div>
            </div>
            <div class="stat">
              <div class="stat-label">${t('correlationCoefficient')}</div>
              <div class="stat-value" id="correlationValue">${t('calculating')}</div>
            </div>
            <div class="stat">
              <div class="stat-label">${t('lastUpdated')}</div>
              <div class="stat-value">${lastUpdated}</div>
            </div>
          </div>
        `;

        // ä½¿ç”¨ä¼ å…¥çš„å¤©æ•°ï¼ˆå¦‚æœæœ‰ï¼‰ï¼Œå¦åˆ™ç”¨å½“å‰å…¨å±€çš„å¤©æ•°
        const days = daysOverride ?? currentDays;
        currentDays = days;

        // æ›´æ–°æ ‡é¢˜é‡Œçš„å¤©æ•°å’Œæ»‘æ†çš„ä½ç½®
        const daysLabelEl = document.getElementById("daysLabel");
        const daysRangeEl = document.getElementById("daysRange");
        if (daysLabelEl) daysLabelEl.textContent = days;
        if (daysRangeEl && String(daysRangeEl.value) !== String(days)) {
          daysRangeEl.value = days;
        }

        // ä¿å­˜ token ç¬¦å·ä¾›å›¾ä¾‹ä½¿ç”¨
        currentBaseSymbol = baseSymbol;
        currentQuoteSymbol = quoteSymbol;

        // 2, fetch ohlcv - æ€»æ˜¯è·å–180å¤©çš„æ•°æ®å¹¶å­˜å‚¨
        loadingEl.textContent = t('loadingOhlcvData');
        let ohlcvList0 = [];
        let ohlcvList1 = [];
        
        // å°è¯•ä» Birdeye è·å–ï¼ˆå¦‚æœå¯ç”¨ï¼‰
        try {
          const birdeyeData = await fetchBirdeyeOhlcv(cleanId, 180);
          // Birdeye è¿”å›çš„æ˜¯ base token çš„ä»·æ ¼ï¼Œæˆ‘ä»¬éœ€è¦åŒæ—¶è·å– quote token
          ohlcvList0 = birdeyeData;
          // å°è¯•ä» GeckoTerminal è·å– quote token çš„ä»·æ ¼
          try {
            ohlcvList1 = await fetchOhlcv(cleanId, 180, "quote");
          } catch (e1) {
            console.warn("Failed to load quote token OHLCV from GeckoTerminal", e1);
          }
        } catch (e) {
          console.error("Failed to load OHLCV from Birdeye, falling back to GeckoTerminal", e);
          try {
            // ä» GeckoTerminal åŒæ—¶è·å– base å’Œ quote token çš„æ•°æ®
            const [baseData, quoteData] = await Promise.all([
              fetchOhlcv(cleanId, 180, "base"),
              fetchOhlcv(cleanId, 180, "quote")
            ]);
            ohlcvList0 = baseData;
            ohlcvList1 = quoteData;
          } catch (inner) {
            console.error("Failed to load OHLCV from GeckoTerminal as well", inner);
          }
        }

        // åˆå¹¶ token0 å’Œ token1 çš„æ•°æ®
        // æ•°æ®æ ¼å¼: [ts, open0, high0, low0, close0, volume, tvl, trades, open1, high1, low1, close1]
        const mergedData = [];
        const dataMap0 = new Map();
        const dataMap1 = new Map();
        
        // å»ºç«‹ token0 æ•°æ®çš„æ—¶é—´æˆ³æ˜ å°„
        ohlcvList0.forEach(item => {
          if (Array.isArray(item) && item.length >= 5) {
            const ts = item[0];
            const dayTs = Math.floor(ts / 86400) * 86400;
            dataMap0.set(dayTs, item);
          }
        });
        
        // å»ºç«‹ token1 æ•°æ®çš„æ—¶é—´æˆ³æ˜ å°„
        ohlcvList1.forEach(item => {
          if (Array.isArray(item) && item.length >= 5) {
            const ts = item[0];
            const dayTs = Math.floor(ts / 86400) * 86400;
            dataMap1.set(dayTs, item);
          }
        });
        
        // åˆå¹¶æ‰€æœ‰æ—¶é—´æˆ³
        const allTimestamps = new Set([...dataMap0.keys(), ...dataMap1.keys()]);
        const sortedTimestamps = Array.from(allTimestamps).sort((a, b) => a - b);
        
        sortedTimestamps.forEach(dayTs => {
          const item0 = dataMap0.get(dayTs);
          const item1 = dataMap1.get(dayTs);
          
          // token0 æ•°æ®: [ts, open, high, low, close, volume, tvl?, trades?]
          const ts = item0 ? item0[0] : (item1 ? item1[0] : dayTs);
          const open0 = item0 ? (item0[1] ?? null) : null;
          const high0 = item0 ? (item0[2] ?? null) : null;
          const low0 = item0 ? (item0[3] ?? null) : null;
          const close0 = item0 ? (item0[4] ?? null) : null;
          const volume = item0 ? (item0[5] ?? 0) : (item1 ? (item1[5] ?? 0) : 0);
          const tvl = item0 ? (item0[6] ?? null) : null;
          const trades = item0 ? (item0[7] ?? 0) : 0;
          
          // token1 æ•°æ®
          const open1 = item1 ? (item1[1] ?? null) : null;
          const high1 = item1 ? (item1[2] ?? null) : null;
          const low1 = item1 ? (item1[3] ?? null) : null;
          const close1 = item1 ? (item1[4] ?? null) : null;
          
          mergedData.push([ts, open0, high0, low0, close0, volume, tvl, trades, open1, high1, low1, close1]);
        });

        // å­˜å‚¨å®Œæ•´çš„180å¤©æ•°æ®
        storedOhlcvData = mergedData.length > 0 
          ? [...mergedData].sort((a, b) => a[0] - b[0]) 
          : [];

        // æ›´æ–° Current price (Pâ‚€) å’Œç›¸å…³ä»·æ ¼èŒƒå›´
        const ilP0El = document.getElementById("ilP0");
        const ilLowerEl = document.getElementById("ilLower");
        const ilUpperEl = document.getElementById("ilUpper");
        
        let currentPrice = 1; // é»˜è®¤å€¼ä¸º 1
        
        // å¦‚æœæœ‰æ•°æ®ï¼Œå°è¯•ä» token0 çš„æœ€æ–°ä»·æ ¼è·å–
        if (storedOhlcvData.length > 0) {
          const lastEntry = storedOhlcvData[storedOhlcvData.length - 1];
          const token0LatestPrice = lastEntry[4]; // close0 åœ¨ç´¢å¼•4
          if (token0LatestPrice !== null && token0LatestPrice !== undefined && !isNaN(Number(token0LatestPrice)) && Number(token0LatestPrice) > 0) {
            currentPrice = Number(token0LatestPrice);
          }
        }
        
        // æ›´æ–° Current price (Pâ‚€)
        if (ilP0El) {
          ilP0El.value = currentPrice;
        }
        
        // æ ¹æ® Current price è®¡ç®—å¹¶æ›´æ–° Price lower bound å’Œ Price upper bound
        if (ilLowerEl) {
          ilLowerEl.value = (currentPrice * 0.8).toFixed(4);
        }
        if (ilUpperEl) {
          ilUpperEl.value = (currentPrice * 1.2).toFixed(4);
        }

        // è®¡ç®—7æ—¥æ—¥å‡æˆäº¤é‡
        let volume7d = "N/A";
        if (storedOhlcvData.length > 0) {
          // å–æœ€å7å¤©çš„æ•°æ®
          const last7Days = storedOhlcvData.slice(-7);
          // è®¡ç®—æ€»æˆäº¤é‡ï¼ˆvolumeåœ¨ç´¢å¼•5ï¼‰
          const totalVolume = last7Days.reduce((sum, entry) => {
            const vol = entry[5] || 0; // volumeåœ¨ç´¢å¼•5
            return sum + (Number.isFinite(vol) ? Number(vol) : 0);
          }, 0);
          
          // è®¡ç®—7æ—¥æ—¥å‡ï¼ˆæ€»æˆäº¤é‡é™¤ä»¥7ï¼‰
          const dailyAverage = totalVolume / 7;
          
          if (dailyAverage > 0) {
            // æ ¼å¼åŒ–æ˜¾ç¤º
            if (Math.abs(dailyAverage) >= 1e9) {
              volume7d = (dailyAverage / 1e9).toFixed(2) + "B";
            } else if (Math.abs(dailyAverage) >= 1e6) {
              volume7d = (dailyAverage / 1e6).toFixed(2) + "M";
            } else if (Math.abs(dailyAverage) >= 1e3) {
              volume7d = (dailyAverage / 1e3).toFixed(2) + "K";
            } else {
              volume7d = dailyAverage.toFixed(2);
            }
          } else {
            volume7d = "0";
          }
        }
        
        // æ›´æ–°7æ—¥æ—¥å‡æˆäº¤é‡æ˜¾ç¤º
        const volume7dEl = document.getElementById("volume7dValue");
        if (volume7dEl) {
          volume7dEl.textContent = volume7d;
        }

        // è®¡ç®—ç›¸å…³ç³»æ•°
        let correlationDisplay = "N/A";
        const correlationResult = calculatePriceCorrelation(30);
        if (correlationResult && !isNaN(correlationResult.correlation)) {
          correlationDisplay = correlationResult.correlation.toFixed(4);
        }
        
        // æ›´æ–°ç›¸å…³ç³»æ•°æ˜¾ç¤º
        const correlationEl = document.getElementById("correlationValue");
        if (correlationEl) {
          correlationEl.textContent = correlationDisplay;
        }

        // ä½¿ç”¨å­˜å‚¨çš„æ•°æ®æ›´æ–°å›¾è¡¨ï¼ˆæ˜¾ç¤ºå½“å‰é€‰æ‹©çš„å¤©æ•°ï¼‰
        updateChartFromStoredData(days);

        resultsEl.style.display = "block";
        
        // è®¾ç½®ä»·æ ¼æ¯”ç‡åˆ‡æ¢åŠŸèƒ½
        setupPriceRatioToggle();
        
        // æ›´æ–°HVæŒ‰é’®çš„æ˜¾ç¤ºçŠ¶æ€
        updateHvButtonsVisibility();
      } catch (e) {
        console.error(e);
        errorEl.textContent = e.message || String(e);
        // å‘ç”Ÿé”™è¯¯æ—¶éšè—HVæŒ‰é’®
        updateHvButtonsVisibility();
      } finally {
        loadingEl.textContent = "";
      }
    }

    function setupPriceRatioToggle() {
      const priceRatioStat = document.getElementById("priceRatioStat");
      if (!priceRatioStat) return;
      
      // ä½¿ç”¨ once: false ç¡®ä¿å¯ä»¥å¤šæ¬¡ç‚¹å‡»
      priceRatioStat.onclick = function() {
        const currentType = this.getAttribute("data-ratio-type");
        const baseSymbol = this.getAttribute("data-base-symbol");
        const quoteSymbol = this.getAttribute("data-quote-symbol");
        const token1PerToken0 = this.getAttribute("data-token1-per-token0");
        const token0PerToken1 = this.getAttribute("data-token0-per-token1");
        
        const labelEl = document.getElementById("priceRatioLabel");
        const valueEl = document.getElementById("priceRatioValue");
        
        if (currentType === "token1-token0") {
          // åˆ‡æ¢åˆ° token0/token1
          this.setAttribute("data-ratio-type", "token0-token1");
          if (labelEl) labelEl.textContent = `${baseSymbol} / ${quoteSymbol}`;
          if (valueEl) valueEl.textContent = `1 ${baseSymbol} = ${token0PerToken1} ${quoteSymbol}`;
        } else {
          // åˆ‡æ¢åˆ° token1/token0
          this.setAttribute("data-ratio-type", "token1-token0");
          if (labelEl) labelEl.textContent = `${quoteSymbol} / ${baseSymbol}`;
          if (valueEl) valueEl.textContent = `1 ${quoteSymbol} = ${token1PerToken0} ${baseSymbol}`;
        }
      };
    }

    document.getElementById("loadBtn").addEventListener("click", () => {
      const poolId = document.getElementById("poolId").value;
      loadPool(poolId, currentDays);
    });

    document.getElementById("poolId").addEventListener("keyup", (e) => {
      if (e.key === "Enter") {
        loadPool(e.target.value, currentDays);
      }
    });

    const checkBirdeyeKeyBtn = document.getElementById("checkBirdeyeKeyBtn");
    if (checkBirdeyeKeyBtn) {
      checkBirdeyeKeyBtn.addEventListener("click", () => {
        checkBirdeyeKey();
      });
    }

    // æŠ˜å /å±•å¼€è‡ªå®šä¹‰ API Key è¾“å…¥åŒºåŸŸ
    const toggleCustomKeyBtn = document.getElementById("toggleCustomKeyBtn");
    const customKeySection = document.getElementById("customKeySection");
    const toggleCustomKeyText = document.getElementById("toggleCustomKeyText");
    const toggleCustomKeyArrow = document.getElementById("toggleCustomKeyArrow");
    
    if (toggleCustomKeyBtn && customKeySection) {
      toggleCustomKeyBtn.addEventListener("click", () => {
        const isExpanded = customKeySection.style.display !== "none";
        if (isExpanded) {
          // æŠ˜å 
          customKeySection.style.display = "none";
          toggleCustomKeyText.textContent = "api_key_config";
          toggleCustomKeyArrow.textContent = "â–¼";
        } else {
          // å±•å¼€
          customKeySection.style.display = "block";
          toggleCustomKeyText.textContent = "api_key_config";
          toggleCustomKeyArrow.textContent = "â–²";
        }
      });
    }

    // æ˜¾ç¤º/éšè— API Key æŒ‰é’®
    const toggleKeyVisibilityBtn = document.getElementById("toggleKeyVisibilityBtn");
    if (toggleKeyVisibilityBtn) {
      toggleKeyVisibilityBtn.addEventListener("click", () => {
        const keyInput = document.getElementById("birdeyeApiKey");
        if (keyInput) {
          if (keyInput.type === "password") {
            keyInput.type = "text";
            toggleKeyVisibilityBtn.textContent = "ğŸ™ˆ";
          } else {
            keyInput.type = "password";
            toggleKeyVisibilityBtn.textContent = "ğŸ‘ï¸";
          }
        }
      });
    }

    // é¡µé¢åŠ è½½æ—¶å°è¯•æ¢å¤å­˜å‚¨çš„ keyï¼ˆä½†ä¸æ˜¾ç¤ºåœ¨è¾“å…¥æ¡†ä¸­ï¼Œä¿æŒéšç§ï¼‰
    function restoreStoredKey() {
      const storedKey = getStoredBirdeyeApiKey();
      if (storedKey) {
        const keyInput = document.getElementById("birdeyeApiKey");
        if (keyInput && !keyInput.value) {
          // é™é»˜æ¢å¤ï¼Œä¸æ˜¾ç¤ºåœ¨è¾“å…¥æ¡†ä¸­
          // å¦‚æœéœ€è¦è‡ªåŠ¨å¡«å……ï¼Œå–æ¶ˆä¸‹é¢çš„æ³¨é‡Šï¼š
          // keyInput.value = storedKey;
          console.log("å·²ä»æœ¬åœ°å­˜å‚¨æ¢å¤ API Keyï¼ˆå·²æ··æ·†ï¼‰");
        }
      }
    }

    // æ»‘æ†ï¼šå®æ—¶æ›´æ–°å¤©æ•°ï¼Œåªæ›´æ–°å›¾è¡¨æ˜¾ç¤ºï¼Œä¸é‡æ–°åŠ è½½æ•°æ®
    const daysRangeEl = document.getElementById("daysRange");
    if (daysRangeEl) {
      const updateChartFromSlider = () => {
        const newDays = Number(daysRangeEl.value);
        currentDays = newDays;

        const daysLabelEl = document.getElementById("daysLabel");
        if (daysLabelEl) {
          daysLabelEl.textContent = newDays;
        }

        // åªæ›´æ–°å›¾è¡¨ï¼Œä¸é‡æ–°åŠ è½½æ•°æ®
        const resultsEl = document.getElementById("results");
        if (resultsEl && resultsEl.style.display !== "none") {
          updateChartFromStoredData(newDays);
        }
      };

      daysRangeEl.addEventListener("input", updateChartFromSlider);
      daysRangeEl.addEventListener("change", updateChartFromSlider);
    }

    // Popular pools data
    const popularPools = [
      { name: "cbBTC/USDC", id: "7ENJsaWAy4PRs24NYd1WqUdY3DWi43rHvyZXhCjEiNWE" },
      { name: "SOL/USDT", id: "22HUWiJaTNph96KQTKZVy2wg8KzfCems5nyW7E5H5J6w" },
      { name: "SOL/USDC", id: "DJNtGuBGEQiUCWE8F981M2C3ZghZt2XLD8f2sQdZ6rsZ" },
      { name: "USDC/USDT", id: "46Z4iBRb8Kwj2qBoDyLAWt99vKXsUS1vE7vFU2vy5x2V" },
      { name: "SOL/HYPE", id: "4nDy9TQUTfqbmexZi25ujv11KMkDfFMmGeKPRw8HryWY" },
      { name: "SOL/WBTC", id: "GLfJcQZgtLV2QyEBxmNNZ75uJFG1VRiLiki8PfcTZQjW" },
      { name: "USD1/USDC", id: "CWNajRMzUb7ywfuVu9N7b9myhm6GPGFVNaMNAPkNpSjn" },
      { name: "CAKE/USDC", id: "J734vwZxCrrFLhGxwkZdFo3537snbYtLbkvtM15HkETr" },
    ];

    // Initialize popular pools scroll bar
    function initPopularPools() {
      const scrollContainer = document.getElementById("popularPoolsScroll");
      if (!scrollContainer) return;

      // Create pool items (duplicate for seamless loop)
      const createPoolItems = () => {
        return popularPools.map(pool => {
          const item = document.createElement("div");
          item.className = "popular-pool-item";
          item.textContent = pool.name;
          item.dataset.poolId = pool.id;
          item.addEventListener("click", () => {
            const poolIdInput = document.getElementById("poolId");
            if (poolIdInput) {
              poolIdInput.value = pool.id;
              // Automatically trigger Load Pool button
              const loadBtn = document.getElementById("loadBtn");
              if (loadBtn) {
                loadBtn.click();
              } else {
                // Fallback: directly call loadPool if button not found
                loadPool(pool.id, currentDays);
              }
            }
          });
          return item;
        });
      };

      // Duplicate items for seamless scrolling
      const items = createPoolItems();
      const duplicatedItems = createPoolItems();
      
      items.forEach(item => scrollContainer.appendChild(item));
      duplicatedItems.forEach(item => scrollContainer.appendChild(item));
    }

    window.addEventListener("load", () => {
      // Initialize popular pools
      initPopularPools();
      
      // å°è¯•æ¢å¤å­˜å‚¨çš„ API Key
      restoreStoredKey();
      
      const poolId = document.getElementById("poolId").value;
      loadPool(poolId, currentDays);
      // å¦‚æœç”¨æˆ·å·²è¾“å…¥ Birdeye API Keyï¼Œåˆ™æ£€æŸ¥å…¶æ˜¯å¦å¯ç”¨
      checkBirdeyeKey();
    });

    // ========= Historical Volatility Calculation =========

    /**
     * è®¡ç®—å†å²æ³¢åŠ¨ç‡ï¼ˆæ—¥çº§åˆ«ï¼‰
     * @param {Array} prices - ä»·æ ¼æ•°ç»„ï¼ˆæ”¶ç›˜ä»·ï¼‰
     * @param {number} minDays - æœ€å°‘éœ€è¦çš„æ•°æ®å¤©æ•°ï¼Œé»˜è®¤30
     * @returns {number|null} - æ—¥æ³¢åŠ¨ç‡ï¼ˆç™¾åˆ†æ¯”ï¼‰ï¼Œå¦‚æœæ•°æ®ä¸è¶³è¿”å›null
     */
    function calculateHistoricalVolatility(prices, minDays = 30) {
      // è¿‡æ»¤æ‰æ— æ•ˆä»·æ ¼ï¼ˆnull, undefined, 0, NaNï¼‰
      const validPrices = prices.filter(p => 
        p !== null && 
        p !== undefined && 
        !isNaN(Number(p)) && 
        Number(p) > 0
      );

      if (validPrices.length < minDays) {
        return null; // æ•°æ®ä¸è¶³
      }

      if (validPrices.length < 2) {
        return null; // è‡³å°‘éœ€è¦2ä¸ªä»·æ ¼ç‚¹
      }

      // è®¡ç®—å¯¹æ•°æ”¶ç›Šç‡
      const returns = [];
      for (let i = 1; i < validPrices.length; i++) {
        const prevPrice = Number(validPrices[i - 1]);
        const currPrice = Number(validPrices[i]);
        
        if (prevPrice > 0 && currPrice > 0) {
          const logReturn = Math.log(currPrice / prevPrice);
          returns.push(logReturn);
        }
      }

      if (returns.length === 0) {
        return null;
      }

      // è®¡ç®—å‡å€¼
      const mean = returns.reduce((a, b) => a + b, 0) / returns.length;

      // è®¡ç®—æ–¹å·®ï¼ˆæ ·æœ¬æ–¹å·®ï¼Œä½¿ç”¨ n-1ï¼‰
      const variance = returns.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / (returns.length - 1);

      // æ—¥æ³¢åŠ¨ç‡ï¼ˆæ ‡å‡†å·®ï¼‰
      const dailyVolatility = Math.sqrt(variance);

      // è½¬æ¢ä¸ºç™¾åˆ†æ¯”
      return dailyVolatility * 100;
    }

    /**
     * ä»å­˜å‚¨çš„OHLCVæ•°æ®ä¸­æå–ä»·æ ¼å¹¶è®¡ç®—å†å²æ³¢åŠ¨ç‡
     * @param {string} token - 'token0' æˆ– 'token1' æˆ– 'average'
     * @param {number} lookbackDays - å›çœ‹å¤©æ•°ï¼Œé»˜è®¤30
     * @returns {Object|null} - {volatility: number, token: string, days: number, prices: number} æˆ– null
     */
    function calculateHvFromStoredData(token = 'token0', lookbackDays = 30) {
      if (!storedOhlcvData || storedOhlcvData.length === 0) {
        return null;
      }

      // æå–æœ€è¿‘Nå¤©çš„æ•°æ®
      const recentData = storedOhlcvData.slice(-lookbackDays);
      
      let prices = [];
      
      if (token === 'token0') {
        // token0 çš„æ”¶ç›˜ä»·åœ¨ç´¢å¼•4
        prices = recentData.map(entry => entry[4]); // close0
      } else if (token === 'token1') {
        // token1 çš„æ”¶ç›˜ä»·åœ¨ç´¢å¼•11
        prices = recentData.map(entry => entry[11]); // close1
      } else if (token === 'average') {
        // è®¡ç®—ä¸¤è€…çš„å¹³å‡å€¼
        prices = recentData.map(entry => {
          const close0 = entry[4];
          const close1 = entry[11];
          if (close0 !== null && close1 !== null && 
              !isNaN(Number(close0)) && !isNaN(Number(close1)) &&
              Number(close0) > 0 && Number(close1) > 0) {
            return (Number(close0) + Number(close1)) / 2;
          }
          return null;
        });
      } else {
        return null;
      }

      // è®¡ç®—æ³¢åŠ¨ç‡ï¼Œæœ€å°‘éœ€è¦10ä¸ªæœ‰æ•ˆä»·æ ¼ç‚¹
      const minPrices = Math.min(10, Math.floor(lookbackDays * 0.5));
      const volatility = calculateHistoricalVolatility(prices, minPrices);
      
      if (volatility === null) {
        return null;
      }

      const validPricesCount = prices.filter(p => p !== null && !isNaN(Number(p)) && Number(p) > 0).length;

      return {
        volatility: volatility,
        token: token,
        days: recentData.length,
        prices: validPricesCount
      };
    }

    /**
     * æ›´æ–°HVæŒ‰é’®çš„æ˜¾ç¤ºçŠ¶æ€
     * æ ¹æ®kçº¿æ•°æ®çš„å¯ç”¨æ€§åŠ¨æ€æ˜¾ç¤º/éšè—æŒ‰é’®
     */
    function updateHvButtonsVisibility() {
      const calcHvBtn0 = document.getElementById("calcHvBtn0");
      const calcHvBtn1 = document.getElementById("calcHvBtn1");
      const calcRatioVolBtn = document.getElementById("calcRatioVolBtn");
      
      if (!calcHvBtn0 || !calcHvBtn1) {
        return;
      }

      // æ£€æŸ¥æ˜¯å¦æœ‰Kçº¿æ•°æ®
      if (!storedOhlcvData || storedOhlcvData.length === 0) {
        calcHvBtn0.style.display = "none";
        calcHvBtn1.style.display = "none";
        if (calcRatioVolBtn) calcRatioVolBtn.style.display = "none";
        return;
      }

      // æ£€æŸ¥token0æ˜¯å¦æœ‰è¶³å¤Ÿçš„æ•°æ®
      const hvResult0 = calculateHvFromStoredData('token0', 30);
      if (hvResult0) {
        const token0Name = currentBaseSymbol || 'Token0';
        calcHvBtn0.textContent = `${token0Name} HV`;
        calcHvBtn0.style.display = "inline-block";
      } else {
        calcHvBtn0.style.display = "none";
      }

      // æ£€æŸ¥token1æ˜¯å¦æœ‰è¶³å¤Ÿçš„æ•°æ®
      const hvResult1 = calculateHvFromStoredData('token1', 30);
      if (hvResult1) {
        const token1Name = currentQuoteSymbol || 'Token1';
        calcHvBtn1.textContent = `${token1Name} HV`;
        calcHvBtn1.style.display = "inline-block";
      } else {
        calcHvBtn1.style.display = "none";
      }

      // æ£€æŸ¥æ˜¯å¦å¯ä»¥è®¡ç®—ä»·æ ¼æ¯”ç‡æ³¢åŠ¨ç‡ï¼ˆéœ€è¦token0ã€token1çš„HVå’Œç›¸å…³ç³»æ•°ï¼‰
      if (calcRatioVolBtn) {
        const correlationResult = calculatePriceCorrelation(30);
        if (hvResult0 && hvResult1 && correlationResult && !isNaN(correlationResult.correlation)) {
          calcRatioVolBtn.style.display = "inline-block";
        } else {
          calcRatioVolBtn.style.display = "none";
        }
      }
    }

    /**
     * è®¡ç®—å¹¶å¡«å…¥æŒ‡å®štokençš„å†å²æ³¢åŠ¨ç‡
     * @param {string} token - 'token0' æˆ– 'token1'
     */
    function calculateAndFillHv(token) {
      const hvInfoEl = document.getElementById("hvInfo");
      const sigmaDailyEl = document.getElementById("ilSigmaDaily");
      const calcHvBtn0 = document.getElementById("calcHvBtn0");
      const calcHvBtn1 = document.getElementById("calcHvBtn1");
      const calcHvBtn = token === 'token0' ? calcHvBtn0 : calcHvBtn1;
      
      if (!hvInfoEl || !sigmaDailyEl) {
        return;
      }

      // æ£€æŸ¥æ˜¯å¦æœ‰Kçº¿æ•°æ®
      if (!storedOhlcvData || storedOhlcvData.length === 0) {
        hvInfoEl.textContent = t('noPriceDataAvailable');
        hvInfoEl.style.color = "var(--danger)";
        return;
      }

      // æ˜¾ç¤ºè®¡ç®—ä¸­çŠ¶æ€
      if (calcHvBtn) {
        const originalText = calcHvBtn.textContent;
        calcHvBtn.textContent = "â³";
        calcHvBtn.disabled = true;
      }
      hvInfoEl.textContent = t('calculating');
      hvInfoEl.style.color = "var(--text-muted)";

      // ä½¿ç”¨setTimeoutè®©UIæœ‰æ—¶é—´æ›´æ–°
      setTimeout(() => {
        const hvResult = calculateHvFromStoredData(token, 30);
        const tokenName = token === 'token0' 
          ? (currentBaseSymbol || 'Token0')
          : (currentQuoteSymbol || 'Token1');

        // æ¢å¤æŒ‰é’®çŠ¶æ€
        if (calcHvBtn) {
          calcHvBtn.textContent = `${tokenName} HV`;
          calcHvBtn.disabled = false;
        }

        if (!hvResult) {
          hvInfoEl.textContent = t('insufficientPriceData', { tokenName: tokenName });
          hvInfoEl.style.color = "var(--danger)";
          return;
        }

        // å¡«å…¥æ³¢åŠ¨ç‡
        sigmaDailyEl.value = hvResult.volatility.toFixed(2);
        
        // æ˜¾ç¤ºä¿¡æ¯
        hvInfoEl.textContent = `HV: ${hvResult.volatility.toFixed(2)}% (${tokenName}, ${hvResult.days}d, ${hvResult.prices} prices)`;
        hvInfoEl.style.color = "var(--accent)";
        
        // è§¦å‘inputäº‹ä»¶ï¼Œç¡®ä¿UIæ›´æ–°
        sigmaDailyEl.dispatchEvent(new Event('input', { bubbles: true }));
      }, 10);
    }

    /**
     * è®¡ç®—ä»·æ ¼æ¯”ç‡çš„æ—¥æ³¢åŠ¨ç‡å¹¶å¡«å…¥è¾“å…¥æ¡†
     * å…¬å¼: Ïƒ_ratio = âˆš(Ïƒâ‚€Â² + Ïƒâ‚Â² - 2Ï Ã— Ïƒâ‚€ Ã— Ïƒâ‚)
     */
    function calculateAndFillRatioVolatility() {
      const hvInfoEl = document.getElementById("hvInfo");
      const sigmaDailyEl = document.getElementById("ilSigmaDaily");
      const calcRatioVolBtn = document.getElementById("calcRatioVolBtn");
      
      if (!hvInfoEl || !sigmaDailyEl) {
        return;
      }

      // æ£€æŸ¥æ˜¯å¦æœ‰Kçº¿æ•°æ®
      if (!storedOhlcvData || storedOhlcvData.length === 0) {
        hvInfoEl.textContent = t('noPriceDataAvailable');
        hvInfoEl.style.color = "var(--danger)";
        return;
      }

      // æ˜¾ç¤ºè®¡ç®—ä¸­çŠ¶æ€
      if (calcRatioVolBtn) {
        calcRatioVolBtn.textContent = "â³";
        calcRatioVolBtn.disabled = true;
      }
      hvInfoEl.textContent = t('calculatingRatioVolatility');
      hvInfoEl.style.color = "var(--text-muted)";

      // ä½¿ç”¨setTimeoutè®©UIæœ‰æ—¶é—´æ›´æ–°
      setTimeout(() => {
        // è·å–token0å’Œtoken1çš„æ³¢åŠ¨ç‡
        const hvResult0 = calculateHvFromStoredData('token0', 30);
        const hvResult1 = calculateHvFromStoredData('token1', 30);
        const correlationResult = calculatePriceCorrelation(30);

        // æ¢å¤æŒ‰é’®çŠ¶æ€
        if (calcRatioVolBtn) {
          const ratioVolText = document.getElementById('ratioVolatilityBtnText');
          if (ratioVolText) {
            ratioVolText.textContent = t('ratioVolatility');
          } else {
            calcRatioVolBtn.textContent = t('ratioVolatility');
          }
          calcRatioVolBtn.disabled = false;
        }

        // æ£€æŸ¥æ•°æ®æ˜¯å¦è¶³å¤Ÿ
        if (!hvResult0 || !hvResult1) {
          hvInfoEl.textContent = t('needBothVolatilities');
          hvInfoEl.style.color = "var(--danger)";
          return;
        }

        if (!correlationResult || isNaN(correlationResult.correlation)) {
          hvInfoEl.textContent = t('cannotCalculateCorrelation');
          hvInfoEl.style.color = "var(--danger)";
          return;
        }

        // è½¬æ¢ä¸ºå°æ•°å½¢å¼ï¼ˆä»ç™¾åˆ†æ¯”ï¼‰
        const sigma0 = hvResult0.volatility / 100;
        const sigma1 = hvResult1.volatility / 100;
        const rho = correlationResult.correlation;

        // è®¡ç®—ä»·æ ¼æ¯”ç‡æ³¢åŠ¨ç‡: Ïƒ_ratio = âˆš(Ïƒâ‚€Â² + Ïƒâ‚Â² - 2Ï Ã— Ïƒâ‚€ Ã— Ïƒâ‚)
        const sigmaRatioSquared = sigma0 * sigma0 + sigma1 * sigma1 - 2 * rho * sigma0 * sigma1;
        
        if (sigmaRatioSquared < 0) {
          hvInfoEl.textContent = t('invalidVolatilityCalculation');
          hvInfoEl.style.color = "var(--danger)";
          return;
        }

        const sigmaRatio = Math.sqrt(sigmaRatioSquared);
        const sigmaRatioPercent = sigmaRatio * 100;

        // å¡«å…¥æ³¢åŠ¨ç‡
        sigmaDailyEl.value = sigmaRatioPercent.toFixed(2);
        
        // æ˜¾ç¤ºä¿¡æ¯
        const token0Name = currentBaseSymbol || 'Token0';
        const token1Name = currentQuoteSymbol || 'Token1';
        hvInfoEl.textContent = `Ratio Vol: ${sigmaRatioPercent.toFixed(2)}% (Ïƒâ‚€=${hvResult0.volatility.toFixed(2)}%, Ïƒâ‚=${hvResult1.volatility.toFixed(2)}%, Ï=${rho.toFixed(3)})`;
        hvInfoEl.style.color = "var(--accent)";
        
        // è§¦å‘inputäº‹ä»¶ï¼Œç¡®ä¿UIæ›´æ–°
        sigmaDailyEl.dispatchEvent(new Event('input', { bubbles: true }));
      }, 10);
    }

    // ========= Correlation Coefficient Calculation =========

    /**
     * è®¡ç®—ä¸¤ä¸ªä»£å¸ä»·æ ¼çš„å¯¹æ•°æ”¶ç›Šç‡çš„ç›¸å…³ç³»æ•°
     * @param {number} lookbackDays - å›çœ‹å¤©æ•°ï¼Œé»˜è®¤30
     * @returns {Object|null} - {correlation: number, days: number, validPairs: number} æˆ– null
     */
    function calculatePriceCorrelation(lookbackDays = 30) {
      if (!storedOhlcvData || storedOhlcvData.length === 0) {
        return null;
      }

      // æå–æœ€è¿‘Nå¤©çš„æ•°æ®
      const recentData = storedOhlcvData.slice(-lookbackDays);
      
      // æå–token0å’Œtoken1çš„æ”¶ç›˜ä»·
      const prices0 = [];
      const prices1 = [];
      
      for (const entry of recentData) {
        const close0 = entry[4];  // token0æ”¶ç›˜ä»·
        const close1 = entry[11]; // token1æ”¶ç›˜ä»·
        
        if (close0 !== null && close1 !== null && 
            !isNaN(Number(close0)) && !isNaN(Number(close1)) &&
            Number(close0) > 0 && Number(close1) > 0) {
          prices0.push(Number(close0));
          prices1.push(Number(close1));
        }
      }

      if (prices0.length < 2 || prices1.length < 2) {
        return null; // è‡³å°‘éœ€è¦2ä¸ªä»·æ ¼ç‚¹æ¥è®¡ç®—æ”¶ç›Šç‡
      }

      // è®¡ç®—å¯¹æ•°æ”¶ç›Šç‡
      const returns0 = [];
      const returns1 = [];
      
      for (let i = 1; i < prices0.length; i++) {
        const prev0 = prices0[i - 1];
        const curr0 = prices0[i];
        const prev1 = prices1[i - 1];
        const curr1 = prices1[i];
        
        if (prev0 > 0 && curr0 > 0 && prev1 > 0 && curr1 > 0) {
          returns0.push(Math.log(curr0 / prev0));
          returns1.push(Math.log(curr1 / prev1));
        }
      }

      if (returns0.length < 2) {
        return null; // è‡³å°‘éœ€è¦2ä¸ªæ”¶ç›Šç‡ç‚¹
      }

      // è®¡ç®—å‡å€¼
      const mean0 = returns0.reduce((a, b) => a + b, 0) / returns0.length;
      const mean1 = returns1.reduce((a, b) => a + b, 0) / returns1.length;

      // è®¡ç®—åæ–¹å·®å’Œæ–¹å·®
      let covariance = 0;
      let variance0 = 0;
      let variance1 = 0;

      for (let i = 0; i < returns0.length; i++) {
        const diff0 = returns0[i] - mean0;
        const diff1 = returns1[i] - mean1;
        covariance += diff0 * diff1;
        variance0 += diff0 * diff0;
        variance1 += diff1 * diff1;
      }

      // ä½¿ç”¨æ ·æœ¬æ–¹å·®ï¼ˆn-1ï¼‰
      const n = returns0.length;
      covariance = covariance / (n - 1);
      variance0 = variance0 / (n - 1);
      variance1 = variance1 / (n - 1);

      const std0 = Math.sqrt(variance0);
      const std1 = Math.sqrt(variance1);

      // è®¡ç®—ç›¸å…³ç³»æ•°
      if (std0 === 0 || std1 === 0) {
        return null; // æ ‡å‡†å·®ä¸º0ï¼Œæ— æ³•è®¡ç®—ç›¸å…³ç³»æ•°
      }

      const correlation = covariance / (std0 * std1);

      return {
        correlation: correlation,
        days: recentData.length,
        validPairs: returns0.length
      };
    }

    // ========= Impermanent Loss Monte Carlo Simulator =========

    let ilChartInstance = null;
    let monteCarloPathChartInstance = null;
    let monteCarloAxisMode = 'price'; // 'price' or 'percentage'
    let monteCarloCurrentPrice = null; // Store current price for percentage calculation

    function randnBoxMuller() {
      let u = 0;
      let v = 0;
      while (u === 0) u = Math.random();
      while (v === 0) v = Math.random();
      return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
    }

    function uniswapV3XYForPrice(P, Pl, Pu, L) {
      const sqrtP = Math.sqrt(P);
      const sqrtPl = Math.sqrt(Pl);
      const sqrtPu = Math.sqrt(Pu);

      if (P <= Pl) {
        const x = L * (1 / sqrtPl - 1 / sqrtPu);
        return { x, y: 0 };
      } else if (P >= Pu) {
        const y = L * (sqrtPu - sqrtPl);
        return { x: 0, y };
      } else {
        const x = L * (1 / sqrtP - 1 / sqrtPu);
        const y = L * (sqrtP - sqrtPl);
        return { x, y };
      }
    }

    function buildIlDistributionChart(labels, counts) {
      const ctx = document.getElementById("ilDistributionChart").getContext("2d");
      if (ilChartInstance) {
        ilChartInstance.destroy();
      }

      ilChartInstance = new Chart(ctx, {
        type: "bar",
        data: {
          labels,
          datasets: [
            {
              label: "Frequency",
              data: counts,
              backgroundColor: "rgba(148, 163, 184, 0.65)",
              borderColor: "rgba(148, 163, 184, 0.95)",
              borderWidth: 1,
              maxBarThickness: 18
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              backgroundColor: "rgba(15, 23, 42, 0.96)",
              borderColor: "rgba(148, 163, 184, 0.6)",
              borderWidth: 1,
              padding: 8,
              callbacks: {
                label: (ctx) => {
                  const label = ctx.label || "";
                  const c = ctx.parsed.y;
                  return `${label}: ${c}`;
                }
              }
            }
          },
          scales: {
            x: {
              ticks: {
                color: "rgba(148, 163, 184, 0.9)",
                font: { size: 10 },
                maxRotation: 0,
                minRotation: 0
              },
              grid: { display: false }
            },
            y: {
              ticks: {
                color: "rgba(148, 163, 184, 0.9)",
                font: { size: 10 },
                precision: 0
              },
              grid: {
                color: "rgba(30, 64, 175, 0.25)"
              }
            }
          }
        }
      });
    }

    function buildMonteCarloPathChart(dayLabels, pathPricesArray, currentPrice, sigmaDailyPct, days, Pl, Pu) {
      const ctx = document.getElementById("monteCarloPathChart");
      if (!ctx) return;
      
      const chartCtx = ctx.getContext("2d");
      if (monteCarloPathChartInstance) {
        monteCarloPathChartInstance.destroy();
      }

      // Store current price for percentage calculation
      monteCarloCurrentPrice = currentPrice;

      // Helper function to transform data based on mode
      const transformData = (price) => {
        if (monteCarloAxisMode === 'percentage') {
          return ((price / currentPrice - 1) * 100);
        }
        return price;
      };

      // åˆ›å»ºå¤šä¸ªæ•°æ®é›†ï¼Œæ¯ä¸ªè·¯å¾„ä¸€æ¡æŠ˜çº¿
      const datasets = pathPricesArray.map((prices, index) => ({
        label: `${t('pricePath')} ${index + 1}`,
        data: prices.map(transformData),
        borderColor: "rgba(73, 229, 94, 0.75)",
        backgroundColor: "rgba(73, 229, 94, 0.1)",
        borderWidth: 1.5,
        pointRadius: 0,
        pointHoverRadius: 0,
        tension: 0.1,
        fill: false
      }));

      // æ·»åŠ LP rangeä»·æ ¼ä¸‹é™å’Œä¸Šé™çš„æ¨ªçº¿
      if (Pl && Pu && Number.isFinite(Pl) && Number.isFinite(Pu)) {
        // LP range ä»·æ ¼ä¸‹é™æ¨ªçº¿
        datasets.push({
          label: t('lpRange'),
          data: new Array(dayLabels.length).fill(transformData(Pl)),
          borderColor: "rgba(168, 85, 247, 0.5)", // äº®ç´«è‰²ï¼Œ50%é€æ˜åº¦
          backgroundColor: "transparent",
          borderWidth: 2,
          pointRadius: 0,
          pointHoverRadius: 0,
          tension: 0,
          fill: false
        });

        // LP range ä»·æ ¼ä¸Šé™æ¨ªçº¿
        datasets.push({
          label: t('lpRange'),
          data: new Array(dayLabels.length).fill(transformData(Pu)),
          borderColor: "rgba(168, 85, 247, 0.5)", // äº®ç´«è‰²ï¼Œ50%é€æ˜åº¦
          backgroundColor: "transparent",
          borderWidth: 2,
          pointRadius: 0,
          pointHoverRadius: 0,
          tension: 0,
          fill: false
        });
      }

      monteCarloPathChartInstance = new Chart(chartCtx, {
        type: "line",
        data: {
          labels: dayLabels,
          datasets: datasets
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            intersect: false,
            mode: 'index'
          },
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              enabled: false
            }
          },
          scales: {
            x: {
              title: {
                display: true,
                text: t('daysAxisLabel'),
                color: "rgba(148, 163, 184, 0.9)",
                font: { size: 11 }
              },
              ticks: {
                color: "rgba(148, 163, 184, 0.9)",
                font: { size: 10 }
              },
              grid: {
                color: "rgba(148, 163, 184, 0.1)"
              }
            },
            y: {
              title: {
                display: true,
                text: monteCarloAxisMode === 'percentage' ? t('percentageLabel') : t('priceLabel'),
                color: "rgba(148, 163, 184, 0.9)",
                font: { size: 11 }
              },
              ticks: {
                color: "rgba(148, 163, 184, 0.9)",
                font: { size: 10 },
                callback: function(value) {
                  if (monteCarloAxisMode === 'percentage') {
                    return value.toFixed(2) + '%';
                  }
                  return value.toFixed(2);
                }
              },
              grid: {
                color: "rgba(148, 163, 184, 0.15)"
              }
            }
          },
          onClick: function(event, elements) {
            // Check if click is on Y-axis area (left 60px of chart)
            const chartArea = this.chartArea;
            if (chartArea && event.x < chartArea.left + 60) {
              toggleMonteCarloAxisMode();
            }
          }
        }
      });
    }

    function toggleMonteCarloAxisMode() {
      monteCarloAxisMode = monteCarloAxisMode === 'price' ? 'percentage' : 'price';
      
      // Update toggle button text
      const toggleText = document.getElementById('monteCarloAxisToggleText');
      if (toggleText) {
        toggleText.textContent = monteCarloAxisMode === 'price' ? t('priceLabel') : t('percentageLabel');
      }
      
      // Rebuild chart if it exists
      if (monteCarloPathChartInstance && monteCarloCurrentPrice) {
        // Rebuild chart with stored data
        if (window.monteCarloPathData) {
          const { dayLabels, pathPricesArray, currentPrice, sigmaDailyPct, days, Pl, Pu } = window.monteCarloPathData;
          buildMonteCarloPathChart(dayLabels, pathPricesArray, currentPrice, sigmaDailyPct, days, Pl, Pu);
        }
      }
    }

    // è®¾ç½® Price lower bound çš„å‡½æ•°
    function setLowerBound(percentage) {
      const p0El = document.getElementById("ilP0");
      const lowerEl = document.getElementById("ilLower");
      
      if (!p0El || !lowerEl) return;
      
      const currentPrice = parseFloat(p0El.value);
      if (isNaN(currentPrice) || currentPrice <= 0) {
        return; // Current price ä¸ºç©ºæˆ–æ— æ•ˆï¼Œä¸æ‰§è¡Œæ“ä½œ
      }
      
      // è®¡ç®— lower bound: currentPrice * (1 + percentage/100)
      // percentage æ˜¯è´Ÿæ•°ï¼Œä¾‹å¦‚ -0.05 è¡¨ç¤º -0.05%
      const lowerBound = currentPrice * (1 + percentage / 100);
      lowerEl.value = lowerBound.toFixed(4);
    }

    // è®¾ç½® Price upper bound çš„å‡½æ•°
    function setUpperBound(percentage) {
      const p0El = document.getElementById("ilP0");
      const upperEl = document.getElementById("ilUpper");
      
      if (!p0El || !upperEl) return;
      
      const currentPrice = parseFloat(p0El.value);
      if (isNaN(currentPrice) || currentPrice <= 0) {
        return; // Current price ä¸ºç©ºæˆ–æ— æ•ˆï¼Œä¸æ‰§è¡Œæ“ä½œ
      }
      
      // è®¡ç®— upper bound: currentPrice * (1 + percentage/100)
      // percentage æ˜¯æ­£æ•°ï¼Œä¾‹å¦‚ 0.05 è¡¨ç¤º +0.05%
      const upperBound = currentPrice * (1 + percentage / 100);
      upperEl.value = upperBound.toFixed(4);
    }

    function runIlSimulation() {
      const lowerEl = document.getElementById("ilLower");
      const upperEl = document.getElementById("ilUpper");
      const p0El = document.getElementById("ilP0");
      const sigmaDailyEl = document.getElementById("ilSigmaDaily");
      const daysEl = document.getElementById("ilDays");
      const pathsEl = document.getElementById("ilPaths");
      const statusEl = document.getElementById("ilStatus");
      const errorEl = document.getElementById("ilError");

      const expectedEl = document.getElementById("ilExpected");
      const ciEl = document.getElementById("ilCI");
      const stdEl = document.getElementById("ilStd");
      const aprEl = document.getElementById("ilApr");
      const feeBreakEvenEl = document.getElementById("ilFeeBreakEven");

      errorEl.textContent = "";
      statusEl.textContent = t('runningSimulation');
      expectedEl.textContent = "â€“";
      ciEl.textContent = "â€“";
      stdEl.textContent = "â€“";
      if (aprEl) aprEl.textContent = "â€“";
      if (feeBreakEvenEl) feeBreakEvenEl.textContent = "â€“";

      const Pl = Number(lowerEl.value);
      const Pu = Number(upperEl.value);
      const P0 = Number(p0El.value);
      const sigmaDailyPct = Number(sigmaDailyEl.value);
      const days = Number(daysEl.value);
      let paths = Number(pathsEl.value);

      if (!Number.isFinite(Pl) || !Number.isFinite(Pu) || !Number.isFinite(P0)) {
        errorEl.textContent = t('invalidPriceInput');
        statusEl.textContent = "";
        return;
      }
      if (Pl <= 0 || Pu <= 0 || P0 <= 0) {
        errorEl.textContent = t('priceMustBePositive');
        statusEl.textContent = "";
        return;
      }
      if (Pl >= Pu) {
        errorEl.textContent = t('lowerBoundMustBeLess');
        statusEl.textContent = "";
        return;
      }
      if (!Number.isFinite(sigmaDailyPct) || sigmaDailyPct <= 0) {
        errorEl.textContent = t('invalidVolatility');
        statusEl.textContent = "";
        return;
      }
      if (!Number.isFinite(days) || days <= 0) {
        errorEl.textContent = t('daysMustBePositive');
        statusEl.textContent = "";
        return;
      }
      // æ¨¡æ‹Ÿå¤©æ•°ä¸Šé™ä¸º3650
      if (days > 3650) {
        errorEl.textContent = t('daysExceedsLimit');
        statusEl.textContent = "";
        return;
      }
      if (!Number.isFinite(paths) || paths < 100) {
        paths = 1000;
      }
      // æ¨¡æ‹Ÿæ¬¡æ•°ä¸Šé™ä¸º1000000ï¼Œè¶…è¿‡åˆ™æŠ¥é”™
      if (paths > 1000000) {
        errorEl.textContent = t('pathsExceedsLimit');
        statusEl.textContent = "";
        return;
      }

      const sigmaDaily = sigmaDailyPct / 100;
      const T = days;

      const L = 1;
      const xy0 = uniswapV3XYForPrice(P0, Pl, Pu, L);
      const x0 = xy0.x;
      const y0 = xy0.y;

      const ils = new Array(paths);
      // è®¡ç®—è¦å±•ç¤ºçš„è·¯å¾„æ•°é‡ï¼šæ¨¡æ‹Ÿæ¬¡æ•°^(1/3)ï¼Œå‘ä¸‹å–æ•´ï¼Œä¸Šé™ä¸º100
      const pathsToShow = Math.min(Math.floor(Math.pow(paths, 1/3)), 100);
      // å±•ç¤ºå¤©æ•°ä¸Šé™ä¸º365
      const daysToShow = Math.min(days, 365);
      const pathPricesArray = []; // å­˜å‚¨å¤šæ¡è·¯å¾„çš„æ¯æ—¥ä»·æ ¼

      for (let i = 0; i < paths; i++) {
        // å¯¹äºå‰pathsToShowæ¡è·¯å¾„ï¼Œè®°å½•æ¯æ—¥ä»·æ ¼
        if (i < pathsToShow) {
          const pathPrices = [P0]; // ä»å½“å‰ä»·æ ¼å¼€å§‹
          let currentPrice = P0;
          
          // é€æ—¥è®¡ç®—ä»·æ ¼å˜åŒ–ï¼Œå®Œæ•´è®¡ç®—æ‰€æœ‰å¤©æ•°ç”¨äºILè®¡ç®—ï¼Œä½†åªè®°å½•å‰365å¤©ç”¨äºå±•ç¤º
          for (let day = 1; day <= days; day++) {
            const z = randnBoxMuller();
            const logP = Math.log(currentPrice) +
              (-0.5 * sigmaDaily * sigmaDaily) * 1 + // æ¯å¤©çš„æ—¶é—´æ­¥é•¿ä¸º1
              sigmaDaily * Math.sqrt(1) * z;
            currentPrice = Math.exp(logP);
            // åªè®°å½•å‰365å¤©çš„æ•°æ®ç”¨äºå›¾è¡¨å±•ç¤º
            if (day <= daysToShow) {
              pathPrices.push(currentPrice);
            }
          }
          
          pathPricesArray.push(pathPrices);
          
          // ä½¿ç”¨æœ€åä¸€æ¬¡çš„ä»·æ ¼ï¼ˆå®Œæ•´æ¨¡æ‹Ÿå¤©æ•°åçš„ä»·æ ¼ï¼‰è®¡ç®—IL
          const PT = currentPrice;
          const xyT = uniswapV3XYForPrice(PT, Pl, Pu, L);
          const xT = xyT.x;
          const yT = xyT.y;

          const vHodl = x0 * PT + y0;
          const vLp = xT * PT + yT;

          const il = vLp / vHodl - 1;
          ils[i] = il;
        } else {
          // å…¶ä»–æ¨¡æ‹Ÿè·¯å¾„ï¼Œç›´æ¥è®¡ç®—æœ€ç»ˆä»·æ ¼ï¼ˆä¿æŒåŸæœ‰é€»è¾‘ï¼‰
          const z = randnBoxMuller();
          const logPT =
            Math.log(P0) +
            (-0.5 * sigmaDaily * sigmaDaily) * T +
            sigmaDaily * Math.sqrt(T) * z;
          const PT = Math.exp(logPT);

          const xyT = uniswapV3XYForPrice(PT, Pl, Pu, L);
          const xT = xyT.x;
          const yT = xyT.y;

          const vHodl = x0 * PT + y0;
          const vLp = xT * PT + yT;

          const il = vLp / vHodl - 1;
          ils[i] = il;
        }
      }

      ils.sort((a, b) => a - b);

      const n = ils.length;
      const mean =
        ils.reduce((acc, v) => acc + v, 0) / n;

      let variance = 0;
      for (let i = 0; i < n; i++) {
        const d = ils[i] - mean;
        variance += d * d;
      }
      variance = variance / Math.max(1, n - 1);
      const std = Math.sqrt(variance);

      const idx5 = Math.floor(0.05 * (n - 1));
      const idx95 = Math.floor(0.95 * (n - 1));
      const il5 = ils[idx5];
      const il95 = ils[idx95];

      const toPercent = (x) => (x * 100).toFixed(3) + " %";

      expectedEl.textContent = toPercent(mean);
      ciEl.textContent = `${toPercent(il5)}  ~  ${toPercent(il95)}`;
      stdEl.textContent = toPercent(std);

      // è®¡ç®—ç­‰æ•ˆ IL APRï¼šå°† IL å¹´åŒ–
      // mean æ˜¯å°æ•°å½¢å¼ï¼ˆä¾‹å¦‚ -0.025 è¡¨ç¤º -2.5%ï¼‰
      // ç­‰æ•ˆ APR = (mean / days) * 365ï¼ˆå°æ•°å½¢å¼ï¼Œä¾‹å¦‚ -0.30417 è¡¨ç¤º -30.417%ï¼‰
      const equivalentIlApr = (mean / days) * 365;
      if (aprEl) {
        aprEl.textContent = toPercent(equivalentIlApr);
      }

      // è®¡ç®—æ‰‹ç»­è´¹ç›ˆäºå¹³è¡¡çº¿ APRï¼šéœ€è¦å¤šå°‘æ‰‹ç»­è´¹ APR æ‰èƒ½æŠµæ¶ˆ IL æŸå¤±
      // æ‰‹ç»­è´¹ç›ˆäºå¹³è¡¡çº¿ = |ç­‰æ•ˆ IL APR|
      const feeBreakEvenApr = Math.abs(equivalentIlApr);
      if (feeBreakEvenEl) {
        feeBreakEvenEl.textContent = toPercent(feeBreakEvenApr);
      }

      const minIl = ils[0];
      const maxIl = ils[n - 1];
      let lo = minIl;
      let hi = maxIl;
      if (hi - lo < 1e-6) {
        lo -= 0.0005;
        hi += 0.0005;
      }

      const binCount = 30;
      const binSize = (hi - lo) / binCount;
      const counts = new Array(binCount).fill(0);
      const labels = new Array(binCount);

      for (let i = 0; i < binCount; i++) {
        const mid = lo + (i + 0.5) * binSize;
        labels[i] = (mid * 100).toFixed(2) + "%";
      }

      for (let i = 0; i < n; i++) {
        let idx = Math.floor((ils[i] - lo) / binSize);
        if (idx < 0) idx = 0;
        if (idx >= binCount) idx = binCount - 1;
        counts[idx] += 1;
      }

      buildIlDistributionChart(labels, counts);

      // ç»˜åˆ¶å¤šæ¡æ¨¡æ‹Ÿè·¯å¾„çš„ä»·æ ¼è·¯å¾„å›¾
      if (pathPricesArray && pathPricesArray.length > 0) {
        const daysToShow = Math.min(days, 365);
        const dayLabels = Array.from({ length: daysToShow + 1 }, (_, i) => i.toString());
        // ç¡®ä¿æ¯æ¡è·¯å¾„æ•°æ®åªåŒ…å«å‰365å¤©çš„æ•°æ®
        const trimmedPathPricesArray = pathPricesArray.map(prices => 
          prices.slice(0, daysToShow + 1)
        );
        // Store data for toggle functionality
        window.monteCarloPathData = {
          dayLabels,
          pathPricesArray: trimmedPathPricesArray,
          currentPrice: P0,
          sigmaDailyPct,
          days: daysToShow,
          Pl,
          Pu
        };
        buildMonteCarloPathChart(dayLabels, trimmedPathPricesArray, P0, sigmaDailyPct, daysToShow, Pl, Pu);
      }

      statusEl.textContent = t('simulationDone', { paths, days, sigma: sigmaDailyPct });
    }

    const runIlBtn = document.getElementById("runIlBtn");
    if (runIlBtn) {
      runIlBtn.addEventListener("click", runIlSimulation);
    }

    // Monte Carlo axis toggle button
    const monteCarloAxisToggle = document.getElementById("monteCarloAxisToggle");
    if (monteCarloAxisToggle) {
      monteCarloAxisToggle.addEventListener("click", toggleMonteCarloAxisMode);
    }

    // å†å²æ³¢åŠ¨ç‡è®¡ç®—æŒ‰é’®äº‹ä»¶
    const calcHvBtn0 = document.getElementById("calcHvBtn0");
    if (calcHvBtn0) {
      calcHvBtn0.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        calculateAndFillHv('token0');
      });
    }

    const calcHvBtn1 = document.getElementById("calcHvBtn1");
    if (calcHvBtn1) {
      calcHvBtn1.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        calculateAndFillHv('token1');
      });
    }

    const calcRatioVolBtn = document.getElementById("calcRatioVolBtn");
    if (calcRatioVolBtn) {
      calcRatioVolBtn.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        calculateAndFillRatioVolatility();
      });
    }

    // å¤©æ•°å¿«é€Ÿé€‰æ‹©æŒ‰é’®äº‹ä»¶
    const daysQuickBtns = document.querySelectorAll(".days-quick-btn");
    daysQuickBtns.forEach(btn => {
      btn.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        const days = parseInt(btn.getAttribute("data-days"));
        const daysEl = document.getElementById("ilDays");
        if (daysEl && !isNaN(days) && days > 0) {
          daysEl.value = days;
          // è§¦å‘inputäº‹ä»¶ï¼Œç¡®ä¿UIæ›´æ–°
          daysEl.dispatchEvent(new Event('input', { bubbles: true }));
        }
      });
    });

    // åˆå§‹æƒ…å†µä¸‹å°±è¿è¡Œæ¨¡æ‹Ÿï¼Œä½¿ç”¨é»˜è®¤å‚æ•°
    window.addEventListener("load", () => {
      setTimeout(() => {
        runIlSimulation();
      }, 1000); // å»¶è¿Ÿ1ç§’ç¡®ä¿DOMå’Œå›¾è¡¨åº“å®Œå…¨åŠ è½½
    });
  </script>
</body>
</html>
